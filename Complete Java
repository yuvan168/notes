# Complete Java Language Guide: Notes, Examples & Interview Q&A

## Table of Contents
1. [Fundamentals](#fundamentals)
2. [OOP Concepts](#oop-concepts)
3. [Collections Framework](#collections-framework)
4. [Exception Handling](#exception-handling)
5. [Multithreading](#multithreading)
6. [File I/O](#file-io)
7. [Streams API](#streams-api)
8. [Design Patterns](#design-patterns)
9. [Interview Q&A](#interview-qa)

---

## Fundamentals

### Data Types

**Primitive Data Types:**
```java
// Primitive types (8 types)
byte b = 100;           // 8-bit integer (-128 to 127)
short s = 10000;        // 16-bit integer (-32,768 to 32,767)
int i = 100000;         // 32-bit integer
long l = 10000000000L;  // 64-bit integer
float f = 3.14f;        // 32-bit floating point
double d = 3.14159;     // 64-bit floating point
boolean bool = true;    // true/false
char c = 'A';           // 16-bit character (Unicode)
```

**Non-Primitive (Reference) Types:**
```java
String str = "Hello";
int[] arr = {1, 2, 3};
Object obj = new Object();
```

### Variables & Scope

```java
public class ScopeExample {
    static int staticVar = 10;      // Class/static scope
    int instanceVar = 20;            // Instance scope
    
    public void method() {
        int localVar = 30;           // Local scope (method level)
        {
            int blockVar = 40;       // Block scope
        }
        // System.out.println(blockVar); // ERROR: out of scope
    }
}
```

### Operators

```java
// Arithmetic Operators
int sum = 10 + 5;       // 15
int diff = 10 - 5;      // 5
int prod = 10 * 5;      // 50
int div = 10 / 3;       // 3 (integer division)
int mod = 10 % 3;       // 1

// Comparison Operators
boolean result = 10 > 5;    // true
result = 10 <= 5;           // false
result = 10 == 5;           // false
result = 10 != 5;           // true

// Logical Operators
result = true && false;     // false (AND)
result = true || false;     // true (OR)
result = !true;             // false (NOT)

// Ternary Operator
String grade = (marks >= 80) ? "A" : "B";

// Bitwise Operators
int a = 5;         // 0101
int b = 3;         // 0011
int and = a & b;   // 0001 = 1
int or = a | b;    // 0111 = 7
int xor = a ^ b;   // 0110 = 6
int not = ~a;      // inverts bits

// Shift Operators
int leftShift = 5 << 1;   // 10 (5 * 2)
int rightShift = 5 >> 1;  // 2 (5 / 2)
```

### String Basics

```java
// String creation
String s1 = "Hello";           // String literal (in pool)
String s2 = new String("Hello"); // New object (heap)
String s3 = "Hello";           // Same reference as s1

System.out.println(s1 == s3);  // true (same reference)
System.out.println(s1 == s2);  // false (different objects)
System.out.println(s1.equals(s2)); // true (same value)

// String methods
String text = "Hello World";
int length = text.length();              // 11
String upper = text.toUpperCase();       // "HELLO WORLD"
String lower = text.toLowerCase();       // "hello world"
String sub = text.substring(0, 5);       // "Hello"
int index = text.indexOf("World");       // 6
boolean contains = text.contains("World"); // true
String[] parts = text.split(" ");        // ["Hello", "World"]
String trimmed = "  text  ".trim();      // "text"

// String concatenation
String concat = "Hello" + " " + "World"; // "Hello World"
String format = String.format("Name: %s, Age: %d", "John", 25); // "Name: John, Age: 25"

// StringBuilder (mutable, faster for concatenation)
StringBuilder sb = new StringBuilder();
sb.append("Hello");
sb.append(" ");
sb.append("World");
String result = sb.toString();  // "Hello World"
```

---

## OOP Concepts

### Classes and Objects

```java
public class Car {
    // Instance variables
    private String brand;
    private int year;
    
    // Constructor
    public Car(String brand, int year) {
        this.brand = brand;
        this.year = year;
    }
    
    // Methods
    public void drive() {
        System.out.println(brand + " is driving");
    }
    
    // Getter
    public String getBrand() {
        return brand;
    }
    
    // Setter
    public void setBrand(String brand) {
        this.brand = brand;
    }
}

// Usage
Car car = new Car("Toyota", 2022);
car.drive();  // Toyota is driving
```

### Inheritance

```java
// Parent class
public class Animal {
    protected String name;
    
    public Animal(String name) {
        this.name = name;
    }
    
    public void sound() {
        System.out.println("Animal makes a sound");
    }
}

// Child class
public class Dog extends Animal {
    public Dog(String name) {
        super(name);  // Call parent constructor
    }
    
    @Override
    public void sound() {
        System.out.println(name + " barks");
    }
    
    public void fetch() {
        System.out.println(name + " fetches the ball");
    }
}

// Usage
Dog dog = new Dog("Buddy");
dog.sound();   // Buddy barks
dog.fetch();   // Buddy fetches the ball
```

### Polymorphism

```java
// Method Overriding (Runtime/Dynamic Polymorphism)
Animal animal = new Dog("Max");
animal.sound();  // Max barks (Dog's implementation called)

// Method Overloading (Compile-time/Static Polymorphism)
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
    
    public double add(double a, double b) {
        return a + b;
    }
    
    public int add(int a, int b, int c) {
        return a + b + c;
    }
}

Calculator calc = new Calculator();
System.out.println(calc.add(5, 10));           // 15
System.out.println(calc.add(5.5, 10.5));       // 16.0
System.out.println(calc.add(5, 10, 15));       // 30
```

### Encapsulation

```java
public class BankAccount {
    private double balance;  // Private - hidden from outside
    private String accountNumber;
    
    public BankAccount(String accountNumber, double initialBalance) {
        this.accountNumber = accountNumber;
        this.balance = initialBalance;
    }
    
    // Controlled access through methods
    public void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
        }
    }
    
    public void withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
        }
    }
    
    public double getBalance() {
        return balance;
    }
}
```

### Abstraction

```java
// Abstract class
public abstract class Shape {
    abstract void draw();
    abstract double area();
    
    public void info() {
        System.out.println("This is a shape");
    }
}

// Concrete class
public class Circle extends Shape {
    private double radius;
    
    public Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    void draw() {
        System.out.println("Drawing circle");
    }
    
    @Override
    double area() {
        return Math.PI * radius * radius;
    }
}

// Interface
public interface Vehicle {
    void start();
    void stop();
    double getSpeed();  // Public abstract by default
}

public class Car implements Vehicle {
    @Override
    public void start() {
        System.out.println("Car started");
    }
    
    @Override
    public void stop() {
        System.out.println("Car stopped");
    }
    
    @Override
    public double getSpeed() {
        return 120.5;
    }
}
```

### Access Modifiers

```java
public class AccessModifiers {
    public int publicVar = 1;           // Accessible everywhere
    protected int protectedVar = 2;     // Accessible in same package and subclasses
    int defaultVar = 3;                 // Accessible in same package (default/package-private)
    private int privateVar = 4;         // Accessible only in this class
}
```

### Static Members

```java
public class Counter {
    static int count = 0;  // Shared across all instances
    
    public Counter() {
        count++;
    }
    
    static void printCount() {
        System.out.println("Count: " + count);
    }
}

Counter c1 = new Counter();
Counter c2 = new Counter();
Counter.printCount();  // Count: 2

// Static block
public class Initialization {
    static int value;
    
    static {
        value = 100;  // Executes when class is loaded
        System.out.println("Static block executed");
    }
}
```

### Final Keyword

```java
// Final class - cannot be extended
public final class ImmutableClass {
}

// Final method - cannot be overridden
public class Parent {
    public final void importantMethod() {
    }
}

// Final variable - cannot be reassigned
public class Constants {
    final int MAX_SIZE = 100;
    // MAX_SIZE = 200; // ERROR
}
```

---

## Collections Framework

### List Interface

```java
import java.util.*;

// ArrayList - dynamic array, O(1) access, O(n) insertion/deletion
List<String> list = new ArrayList<>();
list.add("Apple");
list.add("Banana");
list.add("Cherry");
list.add(1, "Blueberry");  // Insert at index 1
System.out.println(list.get(0));  // "Apple"
System.out.println(list.size());  // 4
list.remove(1);  // Remove "Blueberry"

// LinkedList - doubly-linked list, O(n) access, O(1) insertion/deletion at ends
LinkedList<Integer> linkedList = new LinkedList<>();
linkedList.add(1);
linkedList.addFirst(0);
linkedList.addLast(2);
linkedList.removeFirst();
linkedList.removeLast();

// Vector (synchronized, slower) and Stack
Vector<Integer> vector = new Vector<>();
Stack<Integer> stack = new Stack<>();
stack.push(1);
stack.push(2);
System.out.println(stack.pop());  // 2
System.out.println(stack.peek()); // 1
```

### Set Interface

```java
// HashSet - unordered, unique elements, O(1) average operations
Set<String> hashSet = new HashSet<>();
hashSet.add("Apple");
hashSet.add("Banana");
hashSet.add("Apple");  // Duplicate ignored
System.out.println(hashSet.size());  // 2

// LinkedHashSet - maintains insertion order
Set<String> linkedHashSet = new LinkedHashSet<>();
linkedHashSet.add("Apple");
linkedHashSet.add("Banana");
linkedHashSet.add("Cherry");
// Iteration order: Apple, Banana, Cherry

// TreeSet - sorted order, O(log n) operations
Set<Integer> treeSet = new TreeSet<>();
treeSet.add(5);
treeSet.add(2);
treeSet.add(8);
treeSet.add(1);
// Sorted: 1, 2, 5, 8

// Custom sorting with TreeSet
Set<String> sortedStrings = new TreeSet<>(Collections.reverseOrder());
sortedStrings.add("Apple");
sortedStrings.add("Banana");
sortedStrings.add("Cherry");
// Order: Cherry, Banana, Apple
```

### Map Interface

```java
// HashMap - O(1) average, unordered
Map<String, Integer> hashMap = new HashMap<>();
hashMap.put("Alice", 25);
hashMap.put("Bob", 30);
hashMap.put("Charlie", 28);
System.out.println(hashMap.get("Alice"));  // 25
hashMap.remove("Bob");
System.out.println(hashMap.containsKey("Charlie"));  // true
System.out.println(hashMap.size());  // 2

// Iterate
for (String key : hashMap.keySet()) {
    System.out.println(key + ": " + hashMap.get(key));
}

for (Map.Entry<String, Integer> entry : hashMap.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}

// LinkedHashMap - maintains insertion order
Map<String, String> linkedHashMap = new LinkedHashMap<>();
linkedHashMap.put("Name", "John");
linkedHashMap.put("Age", "25");
linkedHashMap.put("City", "NYC");
// Iteration order maintains insertion

// TreeMap - sorted by key, O(log n)
Map<Integer, String> treeMap = new TreeMap<>();
treeMap.put(3, "Third");
treeMap.put(1, "First");
treeMap.put(2, "Second");
// Sorted by key: 1, 2, 3

// Hashtable (synchronized, legacy)
Hashtable<String, Integer> hashtable = new Hashtable<>();
hashtable.put("Key", 1);
```

### Queue and Deque

```java
// Queue (FIFO - First In First Out)
Queue<Integer> queue = new LinkedList<>();
queue.add(1);
queue.add(2);
queue.add(3);
System.out.println(queue.peek());   // 1 (view front)
System.out.println(queue.poll());   // 1 (remove front)
System.out.println(queue.size());   // 2

// Priority Queue (heap-based)
Queue<Integer> pq = new PriorityQueue<>();
pq.add(5);
pq.add(1);
pq.add(3);
while (!pq.isEmpty()) {
    System.out.println(pq.poll());  // 1, 3, 5 (sorted order)
}

// Deque (Double Ended Queue)
Deque<Integer> deque = new LinkedList<>();
deque.addFirst(1);
deque.addLast(2);
deque.addLast(3);
System.out.println(deque.removeFirst());  // 1
System.out.println(deque.removeLast());   // 3
```

### Collections Utility Methods

```java
List<Integer> list = Arrays.asList(3, 1, 4, 1, 5, 9, 2, 6);

// Sorting
Collections.sort(list);
System.out.println(list);  // [1, 1, 2, 3, 4, 5, 6, 9]

// Reverse sorting
Collections.sort(list, Collections.reverseOrder());

// Searching (list must be sorted)
int index = Collections.binarySearch(list, 5);

// Min/Max
int min = Collections.min(list);
int max = Collections.max(list);

// Reverse
Collections.reverse(list);

// Shuffle
Collections.shuffle(list);

// Copy
List<Integer> copy = new ArrayList<>(list);

// Frequency
int count = Collections.frequency(list, 1);  // How many times 1 appears

// Fill
Collections.fill(list, 0);  // Fill all with 0

// Unmodifiable collections
List<String> unmodifiable = Collections.unmodifiableList(list);
```

---

## Exception Handling

### Try-Catch-Finally

```java
try {
    int[] arr = {1, 2, 3};
    System.out.println(arr[5]);  // IndexOutOfBoundsException
} catch (IndexOutOfBoundsException e) {
    System.out.println("Index out of bounds: " + e.getMessage());
} catch (Exception e) {
    System.out.println("General exception: " + e.getMessage());
} finally {
    System.out.println("Finally block always executes");
}
```

### Exception Hierarchy

```
Object
  └─ Throwable
      ├─ Error (not recoverable: OutOfMemoryError, StackOverflowError)
      └─ Exception
          ├─ Checked Exception (must handle or declare)
          │  ├─ IOException
          │  ├─ SQLException
          │  └─ FileNotFoundException
          └─ Unchecked Exception (RuntimeException - optional to handle)
             ├─ NullPointerException
             ├─ ArithmeticException
             ├─ ArrayIndexOutOfBoundsException
             └─ ClassCastException
```

### Custom Exceptions

```java
// Custom checked exception
public class InvalidAgeException extends Exception {
    public InvalidAgeException(String message) {
        super(message);
    }
}

// Custom unchecked exception
public class InvalidEmailException extends RuntimeException {
    public InvalidEmailException(String message) {
        super(message);
    }
}

// Usage
public class User {
    public void setAge(int age) throws InvalidAgeException {
        if (age < 0 || age > 120) {
            throw new InvalidAgeException("Age must be between 0 and 120");
        }
    }
}

// Handling
try {
    user.setAge(150);
} catch (InvalidAgeException e) {
    System.out.println("Error: " + e.getMessage());
}
```

### Try-with-Resources

```java
// Automatically closes resources that implement AutoCloseable
try (FileReader reader = new FileReader("file.txt")) {
    int data = reader.read();
} catch (IOException e) {
    System.out.println("Error: " + e.getMessage());
}
// FileReader automatically closed
```

---

## Multithreading

### Creating Threads

```java
// Method 1: Extend Thread class
class MyThread extends Thread {
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println("Thread: " + i);
            try {
                Thread.sleep(1000);  // 1 second
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

MyThread t1 = new MyThread();
t1.start();  // Start thread (calls run())

// Method 2: Implement Runnable (preferred)
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Running in thread");
    }
}

Thread t2 = new Thread(new MyRunnable());
t2.start();

// Or using lambda
Thread t3 = new Thread(() -> {
    System.out.println("Running in thread using lambda");
});
t3.start();
```

### Thread Methods

```java
Thread t = Thread.currentThread();

String name = t.getName();
int priority = t.getPriority();  // 1-10, default 5
t.setPriority(Thread.MAX_PRIORITY);

boolean alive = t.isAlive();
t.join();  // Wait for thread to complete

// Thread states
// NEW, RUNNABLE, RUNNING, BLOCKED, WAITING, TERMINATED
```

### Synchronization

```java
// Synchronized method
public class Counter {
    private int count = 0;
    
    public synchronized void increment() {
        count++;
    }
    
    public synchronized int getCount() {
        return count;
    }
}

// Synchronized block
public class MyClass {
    private int value = 0;
    private Object lock = new Object();
    
    public void method() {
        synchronized(lock) {
            value++;
        }
    }
}

// Lock interface
import java.util.concurrent.locks.*;

public class LockExample {
    private Lock lock = new ReentrantLock();
    
    public void method() {
        lock.lock();
        try {
            // Critical section
        } finally {
            lock.unlock();
        }
    }
}
```

### Thread Pool (Executor Framework)

```java
import java.util.concurrent.*;

// Fixed thread pool
ExecutorService executor = Executors.newFixedThreadPool(3);

// Submit tasks
for (int i = 0; i < 10; i++) {
    executor.submit(() -> {
        System.out.println("Task executed by " + Thread.currentThread().getName());
    });
}

executor.shutdown();
executor.awaitTermination(10, TimeUnit.SECONDS);

// Other executor types
ExecutorService cachedPool = Executors.newCachedThreadPool();
ExecutorService singlePool = Executors.newSingleThreadExecutor();

// ScheduledExecutorService
ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(2);
scheduledExecutor.scheduleAtFixedRate(() -> {
    System.out.println("Scheduled task");
}, 0, 2, TimeUnit.SECONDS);
```

### Callable and Future

```java
import java.util.concurrent.*;

Callable<Integer> task = () -> {
    Thread.sleep(2000);
    return 10 + 20;
};

ExecutorService executor = Executors.newSingleThreadExecutor();
Future<Integer> future = executor.submit(task);

try {
    Integer result = future.get();  // Blocks until result available
    System.out.println("Result: " + result);
} catch (InterruptedException | ExecutionException e) {
    e.printStackTrace();
}

executor.shutdown();
```

---

## File I/O

### Reading and Writing Files

```java
import java.io.*;
import java.nio.file.*;

// FileReader and FileWriter (character stream)
try (FileWriter writer = new FileWriter("file.txt")) {
    writer.write("Hello, World!");
} catch (IOException e) {
    e.printStackTrace();
}

try (FileReader reader = new FileReader("file.txt")) {
    int character;
    while ((character = reader.read()) != -1) {
        System.out.print((char) character);
    }
} catch (IOException e) {
    e.printStackTrace();
}

// BufferedReader and BufferedWriter (faster)
try (BufferedWriter writer = new BufferedWriter(new FileWriter("file.txt"))) {
    writer.write("Line 1");
    writer.newLine();
    writer.write("Line 2");
} catch (IOException e) {
    e.printStackTrace();
}

try (BufferedReader reader = new BufferedReader(new FileReader("file.txt"))) {
    String line;
    while ((line = reader.readLine()) != null) {
        System.out.println(line);
    }
} catch (IOException e) {
    e.printStackTrace();
}

// FileInputStream and FileOutputStream (byte stream)
try (FileOutputStream fos = new FileOutputStream("data.bin")) {
    byte[] data = "Hello".getBytes();
    fos.write(data);
} catch (IOException e) {
    e.printStackTrace();
}

try (FileInputStream fis = new FileInputStream("data.bin")) {
    byte[] data = new byte[1024];
    int bytesRead = fis.read(data);
    System.out.println(new String(data, 0, bytesRead));
} catch (IOException e) {
    e.printStackTrace();
}
```

### NIO (New I/O)

```java
import java.nio.file.*;
import java.nio.charset.StandardCharsets;

// Read entire file
List<String> lines = Files.readAllLines(Paths.get("file.txt"));
String content = Files.readString(Paths.get("file.txt"));

// Write file
Files.writeString(Paths.get("output.txt"), "Hello, World!");
Files.write(Paths.get("lines.txt"), Arrays.asList("Line 1", "Line 2"));

// Check file existence
if (Files.exists(Paths.get("file.txt"))) {
    System.out.println("File exists");
}

// Create directory
Files.createDirectory(Paths.get("mydir"));
Files.createDirectories(Paths.get("dir/subdir/nested"));

// Delete
Files.delete(Paths.get("file.txt"));

// List files
Files.list(Paths.get(".")).forEach(System.out::println);

// Walk directory tree
Files.walk(Paths.get("."), FileVisitOption.FOLLOW_LINKS)
    .forEach(System.out::println);
```

### Serialization

```java
import java.io.*;

public class Person implements Serializable {
    private static final long serialVersionUID = 1L;
    private String name;
    private int age;
    transient private String password;  // Won't be serialized
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // Getters
}

// Serialization
Person person = new Person("John", 30);
try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("person.ser"))) {
    oos.writeObject(person);
} catch (IOException e) {
    e.printStackTrace();
}

// Deserialization
try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("person.ser"))) {
    Person deserializedPerson = (Person) ois.readObject();
    System.out.println(deserializedPerson.getName());
} catch (IOException | ClassNotFoundException e) {
    e.printStackTrace();
}
```

---

## Streams API

### Stream Basics

```java
import java.util.stream.*;

List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// Filter
Stream<Integer> filtered = numbers.stream()
    .filter(n -> n > 5);
// Output: 6, 7, 8, 9, 10

// Map
Stream<Integer> mapped = numbers.stream()
    .map(n -> n * 2);
// Output: 2, 4, 6, 8, 10, 12, 14, 16, 18, 20

// FlatMap
List<List<Integer>> nested = Arrays.asList(
    Arrays.asList(1, 2),
    Arrays.asList(3, 4),
    Arrays.asList(5, 6)
);
Stream<Integer> flattened = nested.stream()
    .flatMap(list -> list.stream());
// Output: 1, 2, 3, 4, 5, 6

// Distinct
Stream<Integer> distinct = numbers.stream()
    .distinct();

// Sorted
Stream<Integer> sorted = numbers.stream()
    .sorted();

// Sorted descending
Stream<Integer> sortedDesc = numbers.stream()
    .sorted(Collections.reverseOrder());

// Peek (for debugging)
numbers.stream()
    .peek(n -> System.out.println("Processing: " + n))
    .filter(n -> n > 5)
    .forEach(System.out::println);
```

### Terminal Operations

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// forEach
numbers.stream().forEach(System.out::println);

// collect
List<Integer> doubled = numbers.stream()
    .map(n -> n * 2)
    .collect(Collectors.toList());

Set<Integer> set = numbers.stream()
    .collect(Collectors.toSet());

String joined = numbers.stream()
    .map(String::valueOf)
    .collect(Collectors.joining(", "));  // "1, 2, 3, 4, 5"

// reduce
Optional<Integer> sum = numbers.stream()
    .reduce((a, b) -> a + b);
// Output: Optional[15]

int product = numbers.stream()
    .reduce(1, (a, b) -> a * b);  // With initial value
// Output: 120

// count
long count = numbers.stream()
    .filter(n -> n > 3)
    .count();
// Output: 2

// anyMatch, allMatch, noneMatch
boolean anyGreater5 = numbers.stream().anyMatch(n -> n > 5);    // false
boolean allPositive = numbers.stream().allMatch(n -> n > 0);    // true
boolean noneNegative = numbers.stream().noneMatch(n -> n < 0);  // true

// findFirst, findAny
Optional<Integer> first = numbers.stream()
    .filter(n -> n > 3)
    .findFirst();
// Output: Optional[4]

// min, max
Optional<Integer> min = numbers.stream().min(Integer::compareTo);
Optional<Integer> max = numbers.stream().max(Integer::compareTo);

// min, max with comparator
List<String> words = Arrays.asList("apple", "banana", "cherry");
Optional<String> longest = words.stream()
    .max(Comparator.comparingInt(String::length));
```

### Grouping and Partitioning

```java
List<String> words = Arrays.asList("apple", "apricot", "banana", "blueberry", "cherry");

// Group by first character
Map<Character, List<String>> grouped = words.stream()
    .collect(Collectors.groupingBy(w -> w.charAt(0)));
// {a=[apple, apricot], b=[banana, blueberry], c=[cherry]}

// Group by length
Map<Integer, List<String>> byLength = words.stream()
    .collect(Collectors.groupingBy(String::length));
// {5=[apple], 7=[apricot, blueberry], 6=[banana, cherry]}

// Partition (true/false)
Map<Boolean, List<Integer>> partition = numbers.stream()
    .collect(Collectors.partitioningBy(n -> n > 3));
// {false=[1, 2, 3], true=[4, 5]}

// Counting in groups
Map<Character, Long> counts = words.stream()
    .collect(Collectors.groupingBy(
        w -> w.charAt(0),
        Collectors.counting()
    ));
// {a=2, b=2, c=1}

// Mapping in groups
Map<Character, List<Integer>> lengthsByFirstChar = words.stream()
    .collect(Collectors.groupingBy(
        w -> w.charAt(0),
        Collectors.mapping(String::length, Collectors.toList())
    ));
```

### Parallel Streams

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// Sequential stream
numbers.stream()
    .filter(n -> n > 5)
    .forEach(System.out::println);

// Parallel stream
numbers.parallelStream()
    .filter(n -> n > 5)
    .forEach(System.out::println);

// Convert to parallel
numbers.stream()
    .parallel()
    .filter(n -> n > 5)
    .forEach(System.out::println);

// Convert to sequential
numbers.parallelStream()
    .sequential()
    .forEach(System.out::println);
```

---

## Design Patterns

### Singleton Pattern

```java
// Eager initialization
public class Singleton {
    private static final Singleton INSTANCE = new Singleton();
    
    private Singleton() {
    }
    
    public static Singleton getInstance() {
        return INSTANCE;
    }
}

// Lazy initialization (thread-safe)
public class LazySingleton {
    private static LazySingleton instance;
    
    private LazySingleton() {
    }
    
    public static synchronized LazySingleton getInstance() {
        if (instance == null) {
            instance = new LazySingleton();
        }
        return instance;
    }
}

// Double-checked locking
public class DoubleCheckedSingleton {
    private static volatile DoubleCheckedSingleton instance;
    
    private DoubleCheckedSingleton() {
    }
    
    public static DoubleCheckedSingleton getInstance() {
        if (instance == null) {
            synchronized (DoubleCheckedSingleton.class) {
                if (instance == null) {
                    instance = new DoubleCheckedSingleton();
                }
            }
        }
        return instance;
    }
}

// Bill Pugh Singleton (class loader ensures thread-safety)
public class BillPughSingleton {
    private BillPughSingleton() {
    }
    
    private static class SingletonHelper {
        private static final BillPughSingleton INSTANCE = new BillPughSingleton();
    }
    
    public static BillPughSingleton getInstance() {
        return SingletonHelper.INSTANCE;
    }
}
```

### Factory Pattern

```java
// Simple Factory
public class Shape {
}

public class Circle extends Shape {
}

public class Rectangle extends Shape {
}

public class ShapeFactory {
    public static Shape createShape(String type) {
        switch (type.toLowerCase()) {
            case "circle":
                return new Circle();
            case "rectangle":
                return new Rectangle();
            default:
                throw new IllegalArgumentException("Unknown shape: " + type);
        }
    }
}

// Abstract Factory Pattern
interface Button {
    void click();
}

interface TextBox {
    void focus();
}

interface UIFactory {
    Button createButton();
    TextBox createTextBox();
}

class WindowsButton implements Button {
    public void click() {
        System.out.println("Windows button clicked");
    }
}

class MacButton implements Button {
    public void click() {
        System.out.println("Mac button clicked");
    }
}

class WindowsFactory implements UIFactory {
    public Button createButton() {
        return new WindowsButton();
    }
    
    public TextBox createTextBox() {
        return new WindowsTextBox();
    }
}
```

### Observer Pattern

```java
import java.util.*;

interface Observer {
    void update(String message);
}

class ConcreteObserver implements Observer {
    private String name;
    
    public ConcreteObserver(String name) {
        this.name = name;
    }
    
    public void update(String message) {
        System.out.println(name + " received: " + message);
    }
}

class Subject {
    private List<Observer> observers = new ArrayList<>();
    
    public void attach(Observer observer) {
        observers.add(observer);
    }
    
    public void detach(Observer observer) {
        observers.remove(observer);
    }
    
    public void notifyObservers(String message) {
        for (Observer observer : observers) {
            observer.update(message);
        }
    }
}

// Usage
Subject subject = new Subject();
Observer obs1 = new ConcreteObserver("Observer 1");
Observer obs2 = new ConcreteObserver("Observer 2");
subject.attach(obs1);
subject.attach(obs2);
subject.notifyObservers("Event occurred");
```

### Strategy Pattern

```java
interface Strategy {
    void execute();
}

class ConcreteStrategyA implements Strategy {
    public void execute() {
        System.out.println("Executing Strategy A");
    }
}

class ConcreteStrategyB implements Strategy {
    public void execute() {
        System.out.println("Executing Strategy B");
    }
}

class Context {
    private Strategy strategy;
    
    public Context(Strategy strategy) {
        this.strategy = strategy;
    }
    
    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }
    
    public void performAction() {
        strategy.execute();
    }
}

// Usage
Context context = new Context(new ConcreteStrategyA());
context.performAction();  // Executing Strategy A
context.setStrategy(new ConcreteStrategyB());
context.performAction();  // Executing Strategy B
```

### Decorator Pattern

```java
interface Component {
    void operation();
}

class ConcreteComponent implements Component {
    public void operation() {
        System.out.println("Basic operation");
    }
}

abstract class Decorator implements Component {
    protected Component component;
    
    public Decorator(Component component) {
        this.component = component;
    }
    
    public void operation() {
        component.operation();
    }
}

class ConcreteDecoratorA extends Decorator {
    public ConcreteDecoratorA(Component component) {
        super(component);
    }
    
    public void operation() {
        super.operation();
        System.out.println("Added feature A");
    }
}

class ConcreteDecoratorB extends Decorator {
    public ConcreteDecoratorB(Component component) {
        super(component);
    }
    
    public void operation() {
        super.operation();
        System.out.println("Added feature B");
    }
}

// Usage
Component component = new ConcreteComponent();
component = new ConcreteDecoratorA(component);
component = new ConcreteDecoratorB(component);
component.operation();
// Output:
// Basic operation
// Added feature A
// Added feature B
```

---

## Interview Q&A

### Core Java Concepts

**Q1: What is the difference between `==` and `.equals()`?**

A: 
- `==` compares reference/memory address (for objects)
- `.equals()` compares content/values
```java
String s1 = "Hello";
String s2 = "Hello";
String s3 = new String("Hello");

s1 == s2;           // true (same reference in string pool)
s1 == s3;           // false (different objects)
s1.equals(s3);      // true (same content)
```

**Q2: What is the difference between `String`, `StringBuilder`, and `StringBuffer`?**

A:
- `String`: Immutable, thread-safe
- `StringBuilder`: Mutable, NOT thread-safe, faster
- `StringBuffer`: Mutable, thread-safe (synchronized), slower

```java
String str = "Hello";
str = str + " World";  // Creates new String object

StringBuilder sb = new StringBuilder("Hello");
sb.append(" World");   // Modifies existing object

StringBuffer sfb = new StringBuffer("Hello");
sfb.append(" World");  // Thread-safe
```

**Q3: What is the difference between Array and ArrayList?**

A:
| Feature | Array | ArrayList |
|---------|-------|-----------|
| Size | Fixed | Dynamic |
| Type | Can hold primitives or objects | Only objects |
| Performance | Faster | Slightly slower |
| Methods | Limited | Rich API |
| Synchronization | N/A | Not synchronized |

```java
int[] arr = new int[5];        // Fixed size
List<Integer> list = new ArrayList<>();  // Dynamic size
list.add(10);
list.remove(0);
```

**Q4: What is the difference between `HashMap` and `Hashtable`?**

A:
| Feature | HashMap | Hashtable |
|---------|---------|-----------|
| Synchronization | Not synchronized | Synchronized |
| Thread-safe | No | Yes |
| Performance | Faster | Slower |
| Null keys | Allows one | No null keys |
| Null values | Allows | No null values |

**Q5: What is garbage collection in Java?**

A: Garbage collection automatically frees memory by removing unreferenced objects. The `System.gc()` or `Runtime.getRuntime().gc()` can request it, but it's not guaranteed.

```java
public class GCExample {
    public void example() {
        User user = new User();  // Object created
    }
    // user reference lost, eligible for GC
}
```

**Q6: What are access modifiers?**

A:
| Modifier | Class | Package | Subclass | World |
|----------|-------|---------|----------|-------|
| public | ✓ | ✓ | ✓ | ✓ |
| protected | ✓ | ✓ | ✓ | ✗ |
| default (none) | ✓ | ✓ | ✗ | ✗ |
| private | ✓ | ✗ | ✗ | ✗ |

**Q7: What is the difference between `checked` and `unchecked` exceptions?**

A:
- **Checked**: Must be caught or declared (IOException, SQLException)
- **Unchecked**: RuntimeException subclasses, optional to catch (NullPointerException, ArithmeticException)

```java
// Checked
try {
    FileReader reader = new FileReader("file.txt");
} catch (FileNotFoundException e) {  // Must catch
    e.printStackTrace();
}

// Unchecked
int result = 10 / 0;  // ArithmeticException - optional to catch
```

**Q8: What is the difference between `throw` and `throws`?**

A:
- `throw`: Explicitly throws an exception
- `throws`: Declares that method might throw exception

```java
public void method() throws IOException {  // declares
    if (error) {
        throw new IOException("Error occurred");  // explicitly throws
    }
}
```

**Q9: What is the `super` keyword?**

A: Used to refer to parent class members:
```java
class Parent {
    int value = 10;
    void method() { }
}

class Child extends Parent {
    int value = 20;
    
    void display() {
        System.out.println(super.value);  // 10
        super.method();  // calls parent's method
    }
    
    Child() {
        super();  // calls parent constructor
    }
}
```

**Q10: What is the `this` keyword?**

A: Refers to current object:
```java
class Car {
    String color;
    
    Car(String color) {
        this.color = color;  // distinguish instance variable
    }
    
    void print() {
        System.out.println(this.color);  // current object's color
    }
    
    Car returnThis() {
        return this;  // return current object
    }
}
```

### OOP Concepts

**Q11: What are the 4 pillars of OOP?**

A:
1. **Encapsulation**: Bundling data and methods together, hiding internal details
2. **Inheritance**: Deriving new classes from existing ones
3. **Polymorphism**: Objects can take multiple forms
4. **Abstraction**: Hiding complexity, showing only necessary details

**Q12: What is polymorphism? Explain with examples.**

A: Objects behave differently based on context.

```java
// Compile-time polymorphism (Method Overloading)
class Calculator {
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; }
}

// Runtime polymorphism (Method Overriding)
class Animal {
    void sound() { System.out.println("Some sound"); }
}

class Dog extends Animal {
    @Override
    void sound() { System.out.println("Bark"); }
}

Animal animal = new Dog();
animal.sound();  // Bark (runtime decision)
```

**Q13: What is method overriding?**

A: Child class provides implementation of parent's method:
```java
class Animal {
    public void sound() {
        System.out.println("Animal sound");
    }
}

class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("Woof!");
    }
}
```

Rules:
- Must have same method signature
- Return type must be same or covariant
- Access modifier must be same or broader
- Cannot throw checked exceptions not in parent

**Q14: What is method overloading?**

A: Same method name with different parameters:
```java
public class Test {
    public void show(int a) { }
    public void show(String a) { }
    public void show(int a, int b) { }
    public void show(double a, int b) { }
}
```

**Q15: Can you override static methods?**

A: No, static methods cannot be overridden (they're hidden instead):
```java
class Parent {
    static void staticMethod() {
        System.out.println("Parent static");
    }
}

class Child extends Parent {
    static void staticMethod() {  // Hides, doesn't override
        System.out.println("Child static");
    }
}

Parent p = new Child();
p.staticMethod();  // Parent static (determined at compile time)
```

**Q16: Can you override private methods?**

A: No, private methods are not accessible in subclass:
```java
class Parent {
    private void privateMethod() { }
}

class Child extends Parent {
    public void privateMethod() { }  // Not overriding, new method
}
```

### Collections and Data Structures

**Q17: What is the difference between `ArrayList` and `LinkedList`?**

A:
| Operation | ArrayList | LinkedList |
|-----------|-----------|-----------|
| Access | O(1) | O(n) |
| Insert/Delete at end | O(1) amortized | O(1) |
| Insert/Delete at middle | O(n) | O(n) but less data movement |
| Insert/Delete at start | O(n) | O(1) |
| Memory | Less overhead | More overhead (pointers) |

```java
List<String> arrayList = new ArrayList<>();   // Use for random access
List<String> linkedList = new LinkedList<>(); // Use for add/remove at ends
```

**Q18: What is the difference between `HashSet` and `TreeSet`?**

A:
| Feature | HashSet | TreeSet |
|---------|---------|---------|
| Order | No | Sorted |
| Null elements | Allows | No (throws NPE) |
| Performance | O(1) | O(log n) |
| Implementation | Hash table | Red-black tree |
| Duplicate | No | No |

```java
Set<Integer> hashSet = new HashSet<>();
hashSet.add(3);
hashSet.add(1);
hashSet.add(2);
// Order: random

Set<Integer> treeSet = new TreeSet<>();
treeSet.add(3);
treeSet.add(1);
treeSet.add(2);
// Order: 1, 2, 3
```

**Q19: What is the difference between `HashMap` and `TreeMap`?**

A:
| Feature | HashMap | TreeMap |
|---------|---------|---------|
| Order | No | Sorted by key |
| Null keys | One allowed | No |
| Null values | Yes | Yes |
| Performance | O(1) | O(log n) |
| Thread-safe | No | No |

**Q20: What is the Collections.synchronizedList()?**

A: Creates thread-safe wrapper around a list:
```java
List<String> unsafeList = new ArrayList<>();
List<String> safeList = Collections.synchronizedList(unsafeList);
// Synchronized list for concurrent access
```

**Q21: How do you sort a list?**

A:
```java
List<Integer> numbers = Arrays.asList(3, 1, 4, 1, 5, 9);

// Sort ascending
Collections.sort(numbers);

// Sort descending
Collections.sort(numbers, Collections.reverseOrder());

// Custom comparator
Collections.sort(numbers, (a, b) -> b - a);  // Descending

// Sorting strings
List<String> words = Arrays.asList("apple", "banana", "cherry");
Collections.sort(words);  // Ascending alphabetically
Collections.sort(words, String::compareTo);  // Same
Collections.sort(words, Comparator.reverseOrder());  // Descending

// Sort custom objects
class Person {
    String name;
    int age;
}

List<Person> people = new ArrayList<>();
// By age
people.sort((p1, p2) -> p1.age - p2.age);
// By name
people.sort((p1, p2) -> p1.name.compareTo(p2.name));
// Using Comparator
people.sort(Comparator.comparingInt(p -> p.age));
```

### Multithreading

**Q22: What are the different ways to create threads?**

A:
```java
// Method 1: Extend Thread
class MyThread extends Thread {
    public void run() {
        System.out.println("Running");
    }
}

// Method 2: Implement Runnable
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Running");
    }
}

new Thread(new MyRunnable()).start();

// Method 3: Lambda
new Thread(() -> System.out.println("Running")).start();

// Method 4: Callable (with return value)
Callable<Integer> task = () -> {
    return 10 + 20;
};
```

**Q23: What is the difference between `start()` and `run()`?**

A:
- `start()`: Creates new thread, calls run()
- `run()`: Executes in current thread (no new thread)

```java
Thread t = new MyThread();
t.start();  // Creates new thread
t.run();    // Executes in main thread
```

**Q24: What is synchronization?**

A: Ensures only one thread accesses critical section at a time:
```java
public class Counter {
    private int count = 0;
    
    // Synchronized method
    public synchronized void increment() {
        count++;
    }
    
    // Synchronized block
    public void decrement() {
        synchronized(this) {
            count--;
        }
    }
}
```

**Q25: What is the difference between `notify()` and `notifyAll()`?**

A:
- `notify()`: Wakes one random waiting thread
- `notifyAll()`: Wakes all waiting threads

```java
synchronized(obj) {
    obj.notify();      // Wake one
    obj.notifyAll();   // Wake all
}
```

**Q26: What is deadlock?**

A: Two or more threads wait for each other indefinitely:
```java
// Example of deadlock
Thread t1 = new Thread(() -> {
    synchronized(lock1) {
        Thread.sleep(100);
        synchronized(lock2) {
            // ...
        }
    }
});

Thread t2 = new Thread(() -> {
    synchronized(lock2) {
        Thread.sleep(100);
        synchronized(lock1) {
            // ...
        }
    }
});
```

**How to avoid deadlock:**
- Always acquire locks in same order
- Use timeout
- Use concurrent utilities

**Q27: What is volatile keyword?**

A: Ensures visibility of changes across threads:
```java
public class VolatileExample {
    private volatile int flag = 0;
    
    public void setFlag() {
        flag = 1;  // Visible to all threads immediately
    }
}
```

**Q28: What are thread states?**

A:
1. **NEW**: Just created, not started
2. **RUNNABLE**: Ready to run or running
3. **BLOCKED**: Waiting for lock
4. **WAITING**: Waiting for other thread (wait(), join())
5. **TIMED_WAITING**: Waiting with timeout
6. **TERMINATED**: Finished execution

### Advanced Topics

**Q29: What is the `finally` block used for?**

A: Executes regardless of exception:
```java
try {
    int result = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("Exception caught");
} finally {
    System.out.println("Always executes");  // Always runs
}
```

**Q30: What is the difference between interface and abstract class?**

A:
| Feature | Interface | Abstract Class |
|---------|-----------|-----------------|
| Methods | All abstract (until Java 8) | Mix of abstract and concrete |
| Variables | Constants (public static final) | Any type |
| Constructor | No | Yes |
| Multiple inheritance | Yes | No (extends) |
| Access modifier | Public | Any |
| Purpose | Define contract | Share code |

```java
interface Shape {
    void draw();  // Abstract
    default void describe() {  // Concrete (Java 8+)
        System.out.println("Shape");
    }
}

abstract class Animal {
    abstract void sound();  // Abstract
    void sleep() {  // Concrete
        System.out.println("Sleeping");
    }
}
```

**Q31: What is immutability?**

A: Object cannot be modified after creation:
```java
public final class ImmutableClass {
    private final String name;
    private final int age;
    
    public ImmutableClass(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public String getName() {
        return name;
    }
    
    public int getAge() {
        return age;
    }
    
    // No setters
}
```

**Q32: What is the difference between `package` and `import`?**

A:
- `package`: Groups related classes, defines namespace
- `import`: Brings class into current namespace

```java
package com.example;  // File must be in com/example directory

import java.util.ArrayList;
import java.io.*;  // Import all from java.io

public class MyClass {
}
```

**Q33: What is generics?**

A: Type-safe way to use collections:
```java
// Before generics (unsafe)
List list = new ArrayList();
list.add("Hello");
String str = (String) list.get(0);  // Casting required

// With generics (safe)
List<String> list = new ArrayList<>();
list.add("Hello");
String str = list.get(0);  // No casting

// Generic class
public class Container<T> {
    private T value;
    
    public void setValue(T value) {
        this.value = value;
    }
    
    public T getValue() {
        return value;
    }
}

Container<String> strContainer = new Container<>();
Container<Integer> intContainer = new Container<>();

// Generic method
public <T> void printArray(T[] arr) {
    for (T element : arr) {
        System.out.println(element);
    }
}

// Bounded type parameter
public <T extends Number> void process(T value) {
}
```

**Q34: What are wildcards in generics?**

A:
```java
// Unbounded wildcard
List<?> list = new ArrayList<>();

// Upper bounded wildcard
List<? extends Number> list1 = new ArrayList<Integer>();

// Lower bounded wildcard
List<? super Integer> list2 = new ArrayList<Number>();
```

**Q35: What is functional interface?**

A: Interface with single abstract method:
```java
@FunctionalInterface
interface Calculator {
    int add(int a, int b);
}

// Lambda implementation
Calculator calc = (a, b) -> a + b;

// Common functional interfaces
Predicate<Integer> isPositive = n -> n > 0;
Function<Integer, Integer> square = n -> n * n;
Consumer<String> print = System.out::println;
Supplier<String> supplier = () -> "Hello";
```

**Q36: What is lambda expression?**

A: Anonymous function (functional programming):
```java
// Old way
button.setOnClickListener(new OnClickListener() {
    public void onClick() {
        System.out.println("Clicked");
    }
});

// Lambda way
button.setOnClickListener(() -> System.out.println("Clicked"));

// With parameters
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.forEach(n -> System.out.println(n));

// Multiple statements
numbers.forEach(n -> {
    System.out.println("Number: " + n);
    System.out.println("Square: " + (n * n));
});

// Method reference
numbers.forEach(System.out::println);
```

**Q37: What is `new` keyword?**

A: Creates new instance of a class:
```java
String str = new String("Hello");  // Creates object in heap
int[] arr = new int[5];            // Creates array
Object obj = new Object();         // Creates new object
```

### Performance and Optimization

**Q38: How do you optimize Java code?**

A:
1. Use appropriate data structures (ArrayList vs LinkedList)
2. Minimize object creation
3. Use StringBuilder instead of String concatenation
4. Use enhanced for loop over Iterator
5. Avoid synchronized when possible
6. Use streams for filtering/mapping
7. Cache results
8. Use appropriate algorithms

```java
// Avoid
for (int i = 0; i < list.size(); i++) {  // Calls size() every iteration
    System.out.println(list.get(i));
}

// Better
int size = list.size();
for (int i = 0; i < size; i++) {
    System.out.println(list.get(i));
}

// Best
for (String item : list) {
    System.out.println(item);
}
```

**Q39: What is memory leak in Java?**

A: Objects no longer needed but still referenced, preventing garbage collection:
```java
// Memory leak example
public class MemoryLeak {
    static List<byte[]> list = new ArrayList<>();
    
    public void allocateMemory() {
        for (int i = 0; i < 1000; i++) {
            list.add(new byte[1024 * 1024]);  // 1MB each
        }
        // List keeps growing, can cause OutOfMemoryError
    }
}

// Fix
public void allocateMemory() {
    List<byte[]> localList = new ArrayList<>();
    for (int i = 0; i < 1000; i++) {
        localList.add(new byte[1024 * 1024]);
    }
    // localList goes out of scope, eligible for GC
}
```

**Q40: What is the difference between Stack and Heap memory?**

A:
| Feature | Stack | Heap |
|---------|-------|------|
| Storage | Primitives, references | Objects |
| Size | Smaller, fixed | Larger, dynamic |
| Thread-safe | Yes (per thread) | No (shared) |
| Speed | Faster | Slower |
| Access | LIFO | Random |
| Memory leak | No | Yes (possible) |

```java
public void method() {
    int age = 25;           // Stack
    String name = "John";   // Reference on stack, object on heap
    Person person = new Person();  // Reference on stack, object on heap
}
// age, name, person cleaned up when method returns
```

---

## Key Takeaways

1. **SOLID Principles**:
   - Single Responsibility
   - Open/Closed
   - Liskov Substitution
   - Interface Segregation
   - Dependency Inversion

2. **Best Practices**:
   - Use meaningful variable and method names
   - Keep methods small and focused
   - Use exceptions, not return codes
   - Prefer composition over inheritance
   - Code to interface, not implementation

3. **Testing**:
   - Write unit tests (JUnit)
   - Use mocking (Mockito)
   - Aim for high code coverage
   - Test edge cases

4. **Performance**:
   - Choose right data structures
   - Avoid premature optimization
   - Profile before optimizing
   - Use caching when appropriate

5. **Security**:
   - Validate user input
   - Use parameterized queries
   - Never hardcode credentials
   - Use HTTPS for network communication
   - Keep sensitive data out of logs
