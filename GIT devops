# Git Complete Notes - Theory & Practice

## Table of Contents
1. [Introduction](#introduction)
2. [Git Basics](#git-basics)
3. [Configuration](#configuration)
4. [Creating and Cloning Repositories](#creating-and-cloning-repositories)
5. [Basic Workflow](#basic-workflow)
6. [Staging and Committing](#staging-and-committing)
7. [Viewing History](#viewing-history)
8. [Branching](#branching)
9. [Merging](#merging)
10. [Remote Repositories](#remote-repositories)
11. [Undoing Changes](#undoing-changes)
12. [Stashing](#stashing)
13. [Rebasing](#rebasing)
14. [Cherry-Picking](#cherry-picking)
15. [Tags](#tags)
16. [Advanced Workflows](#advanced-workflows)
17. [Conflict Resolution](#conflict-resolution)
18. [Best Practices](#best-practices)
19. [Common Issues and Solutions](#common-issues-and-solutions)
20. [Complete Git Commands Reference](#complete-git-commands-reference)
21. [Interview Questions](#interview-questions)

---

## Introduction

### What is Git?

Git is a **distributed version control system (DVCS)** that tracks changes in code and allows multiple developers to collaborate efficiently.

### Key Concepts

- **Version Control**: Track changes to files over time
- **Distributed**: Every developer has a full copy of the repository
- **Fast**: All operations are local until explicitly pushed
- **Branching**: Easy to create and switch between branches
- **Merging**: Combine changes from different branches
- **History**: Complete audit trail of all changes

### Git vs Other VCS

| Feature | Git | SVN | Mercurial |
|---------|-----|-----|-----------|
| Distributed | Yes | No | Yes |
| Branching | Fast, Easy | Slow | Fast, Easy |
| Performance | Very Fast | Slow | Fast |
| Learning Curve | Moderate | Easy | Easy |
| Offline Work | Yes | No | Yes |
| Industry Standard | Yes | Declining | Niche |

### Why Git?

1. **Distributed Nature**: Work offline, full history locally
2. **Branching**: Lightweight branches enable feature isolation
3. **Merging**: Intelligent merge tracking
4. **Speed**: All operations are fast
5. **Community**: Largest community, most tools
6. **GitHub/GitLab**: Industry-standard platforms built on Git

---

## Git Basics

### Core Concepts

#### Repository (Repo)
A directory that contains your project files and Git's tracking information (.git folder).

#### Commit
A snapshot of your project at a specific point in time. Contains:
- Changes made
- Author information
- Timestamp
- Commit message
- Parent commit reference

#### Branch
A pointer to a specific commit. Allows parallel development.

#### Working Directory
The actual files on your computer that you edit.

#### Staging Area (Index)
An intermediate area between working directory and repository. Allows selective committing.

#### Remote
A version of your repository hosted on a server (like GitHub, GitLab).

### The Three States of Git

```
Working Directory → Staging Area → Git Repository
     (Modified)       (Staged)        (Committed)
```

1. **Modified**: You've changed files but not committed
2. **Staged**: You've marked modified files to be committed
3. **Committed**: Data is safely stored in Git

---

## Configuration

### Global Configuration

```bash
# Set global username
git config --global user.name "John Doe"

# Set global email
git config --global user.email "john@example.com"

# Set default editor
git config --global core.editor "vim"

# Set default branch name
git config --global init.defaultBranch main

# View all global config
git config --global --list

# View specific config
git config --global user.name
```

### Local Configuration

```bash
# Set configuration for specific repository only
git config user.name "Project Specific Name"

# View local config
git config --local --list

# Remove configuration
git config --global --unset user.name
```

### Configuration File Locations

- **Global**: `~/.gitconfig` or `~/.config/git/config`
- **Local**: `.git/config` (inside repository)
- **System**: `/etc/gitconfig`

### Useful Configuration

```bash
# Create command aliases
git config --global alias.st status
git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.ci commit
git config --global alias.unstage 'restore --staged'
git config --global alias.last 'log -1 HEAD'
git config --global alias.visual 'log --graph --oneline --all'

# Now use shortcuts
git st          # Instead of git status
git co branch   # Instead of git checkout branch

# Configure line endings (Windows)
git config --global core.autocrlf true

# Configure line endings (Mac/Linux)
git config --global core.autocrlf input

# Show colors in output
git config --global color.ui true

# Default pull strategy
git config --global pull.rebase true
```

---

## Creating and Cloning Repositories

### Initialize a New Repository

```bash
# Create new directory and initialize Git
mkdir my-project
cd my-project
git init

# This creates a .git directory with all Git metadata
ls -la  # Shows .git folder

# Initialize with default branch name
git init --initial-branch=main

# Or create from existing project
cd existing-project
git init
```

### Clone an Existing Repository

```bash
# Clone with default branch
git clone https://github.com/user/repo.git

# Clone into specific directory
git clone https://github.com/user/repo.git my-directory

# Clone specific branch
git clone --branch main https://github.com/user/repo.git

# Clone with depth (for large repos)
git clone --depth 1 https://github.com/user/repo.git

# Clone specific branch with depth
git clone --branch feature-x --depth 1 https://github.com/user/repo.git

# Clone with different name
git clone https://github.com/user/repo.git local-name
```

### Initialize with README

```bash
# After git init
echo "# My Project" > README.md
git add README.md
git commit -m "Initial commit"
```

---

## Basic Workflow

### The Typical Git Workflow

```
1. Make changes to files
2. Stage changes (git add)
3. Commit changes (git commit)
4. Push to remote (git push)
5. Pull changes from others (git pull)
```

### Detailed Example

```bash
# 1. Check status
git status
# On branch main
# Your branch is up to date with 'origin/main'.
# nothing to commit, working tree clean

# 2. Create/modify a file
echo "Hello World" > hello.txt

# 3. Check status again
git status
# Untracked files: hello.txt

# 4. Stage the file
git add hello.txt

# 5. Check status
git status
# Changes to be committed: hello.txt

# 6. Commit
git commit -m "Add hello.txt"

# 7. Check status
git status
# working tree clean

# 8. View log
git log

# 9. Push to remote
git push origin main
```

---

## Staging and Committing

### Adding Files to Staging Area

```bash
# Add specific file
git add hello.txt

# Add all files in current directory
git add .

# Add all files in repository
git add -A

# Add with pattern
git add *.js     # Add all JavaScript files
git add src/     # Add all files in src directory

# Stage part of a file (interactive)
git add -p       # Or --patch
# Shows hunks, choose which to stage

# Stage only modified files (not new)
git add -u       # Or --update

# Add files interactively
git add -i       # Or --interactive
```

### Committing

```bash
# Basic commit
git commit -m "Add hello.txt file"

# Commit with detailed message
git commit -m "Add hello.txt file" -m "This file contains a greeting message"

# Commit all tracked files without staging
git commit -a -m "Update all files"

# Amend last commit (add files or change message)
git commit --amend

# Amend with new message only
git commit --amend -m "Better commit message"

# Amend without changing message
git commit --amend --no-edit

# Create empty commit (for testing)
git commit --allow-empty -m "Empty commit for testing"
```

### Viewing What's Being Committed

```bash
# See staged changes (what will be committed)
git diff --staged
# Or
git diff --cached

# See unstaged changes (modifications not staged)
git diff

# See differences for specific file
git diff filename.txt

# Show summary of changes
git diff --stat

# See what specific commit changed
git show commit-hash
```

### .gitignore

```bash
# Create .gitignore file
touch .gitignore

# Common patterns to ignore
# In .gitignore:
node_modules/        # Ignore node_modules folder
*.log               # Ignore all .log files
.env                # Ignore .env file
build/              # Ignore build folder
dist/               # Ignore dist folder
*.o                 # Ignore object files
.DS_Store           # Ignore macOS files
.vscode/            # Ignore VS Code settings
!important.log      # Except important.log (! means don't ignore)
```

---

## Viewing History

### Log Command

```bash
# View commit history
git log

# View recent 5 commits
git log -5

# One commit per line
git log --oneline

# Pretty graph view
git log --graph --oneline --all

# With author information
git log --pretty=format:"%h %an %ad %s" --date=short

# Show statistics
git log --stat

# Show changes in commits
git log -p              # Shows full diff
git log -p -1           # Shows last commit's changes

# Filter by author
git log --author="John"

# Filter by date
git log --since="2024-01-01"
git log --until="2024-12-31"
git log --since="2 weeks ago"

# Filter by commit message
git log --grep="bug fix"

# Search for specific change
git log -S "removed_function"  # Commits that added/removed this string

# Show merge commits only
git log --merges

# Show non-merge commits
git log --no-merges

# Combine filters
git log --author="John" --since="2024-01-01" --grep="bug" --oneline
```

### Showing Specific Commits

```bash
# Show specific commit
git show commit-hash

# Show changes in specific file at specific commit
git show commit-hash:path/to/file

# Show specific file history
git log -- path/to/file

# Show blame (who changed each line)
git blame filename.txt

# Show specific lines blame
git blame -L 10,20 filename.txt

# Show last commit on branch
git show HEAD

# Show before previous commit
git show HEAD~1

# Show grandparent commit
git show HEAD~2

# Show parent of current commit
git show HEAD^
```

### Useful Log Aliases

```bash
# Create useful aliases
git config --global alias.log1 'log --oneline'
git config --global alias.logg 'log --graph --oneline --all'
git config --global alias.logp 'log -p'

# Use them
git log1      # One line log
git logg      # Graph log
git logp      # Log with changes
```

---

## Branching

### Understanding Branches

A branch is a lightweight pointer to a commit. The default branch is usually `main` or `master`.

```
main:  A --- B --- C --- D
                    \
develop:             E --- F
                      \
feature:              G --- H
```

### Creating and Switching Branches

```bash
# Create new branch
git branch feature-x

# Create and switch to new branch
git checkout -b feature-x
# Or (newer syntax)
git switch -c feature-x

# Switch to existing branch
git checkout feature-x
# Or (newer syntax)
git switch feature-x

# Create branch from specific commit
git checkout -b feature-from-commit commit-hash

# Create branch from remote
git checkout --track origin/feature-x
# Or
git checkout -b feature-x origin/feature-x
```

### Viewing Branches

```bash
# List local branches
git branch

# List local branches with last commit
git branch -v

# List remote branches
git branch -r

# List all branches (local and remote)
git branch -a

# Show current branch
git branch --show-current
# Or
git symbolic-ref --short HEAD

# Show merged branches
git branch --merged

# Show unmerged branches
git branch --no-merged

# Show branch tracking information
git branch -vv
```

### Renaming Branches

```bash
# Rename current branch
git branch -m new-name

# Rename specific branch
git branch -m old-name new-name

# Rename remote branch (must push deletion and new name)
git push origin :old-name new-name
git push origin -u origin new-name
```

### Deleting Branches

```bash
# Delete local branch (safe, won't delete if not merged)
git branch -d feature-x

# Force delete local branch
git branch -D feature-x

# Delete remote branch
git push origin --delete feature-x
# Or
git push origin :feature-x

# Delete multiple branches
git branch -d feature-x feature-y

# Delete all local branches except main
git branch | grep -v "main" | xargs git branch -d
```

### Branch Protection Rules (GitHub/GitLab)

```bash
# These are configured on GitHub/GitLab, not Git itself
# But important to know about:
# - Require pull request reviews
# - Require status checks to pass
# - Require branches to be up to date
# - Restrict who can push
```

---

## Merging

### Understanding Merges

Merging combines changes from one branch into another.

### Types of Merges

#### Fast-Forward Merge
```
Before:
main:  A --- B
           \
feature:    C --- D

After (fast-forward):
main:  A --- B --- C --- D
feature: (same as main)
```

```bash
git switch main
git merge feature
# Since main hasn't changed, just move main pointer forward
```

#### Three-Way Merge
```
Before:
main:  A --- B --- E
           \      /
feature:    C --- D

After:
main:  A --- B --- E --- M (merge commit)
           \      /     /
feature:    C --- D ---/
```

```bash
git switch main
git merge feature
# Creates a new merge commit since both branches have unique commits
```

### Merging Branches

```bash
# Merge feature branch into current branch (main)
git switch main
git merge feature

# Merge with custom message
git merge feature -m "Merge feature into main"

# Merge without fast-forward (always create merge commit)
git merge --no-ff feature
# Results in merge commit even if fast-forward possible

# Preview merge without actually merging
git merge --no-commit --no-ff feature
# Review changes
git merge --abort  # Cancel the merge

# Abort a merge in progress
git merge --abort

# Merge specific commit (not whole branch)
git merge commit-hash

# Show commits being merged
git merge --stat feature
```

### Merge Strategies

```bash
# Default (recursive or ort)
git merge feature

# Resolve conflicts by taking ours version for conflicts
git merge -X ours feature

# Resolve conflicts by taking theirs version
git merge -X theirs feature

# Merge strategy for specific file
git merge -X ours feature -- path/to/file

# Squash commits before merging
git merge --squash feature
# Then commit manually

# Rebase instead of merge
git merge --rebase feature
```

---

## Remote Repositories

### Understanding Remotes

A remote is a reference to a repository hosted on a server.

```bash
# Add remote
git remote add origin https://github.com/user/repo.git

# View remotes
git remote
git remote -v  # Shows URLs

# Remove remote
git remote remove origin

# Rename remote
git remote rename origin upstream

# Show remote details
git remote show origin

# Change remote URL
git remote set-url origin https://github.com/user/new-repo.git
```

### Pushing

```bash
# Push current branch to remote
git push

# Push to specific remote
git push origin main

# Push all branches
git push --all

# Push with tags
git push --tags

# Push specific branch
git push origin feature-x

# Create remote branch
git push -u origin feature-x
# -u sets upstream, making git push work without specifying branch

# Force push (use carefully!)
git push --force
# Or safer force with lease
git push --force-with-lease

# Push specific commit
git push origin commit-hash:branch-name
```

### Pulling

```bash
# Fetch and merge (pull = fetch + merge)
git pull

# Fetch and rebase instead of merge
git pull --rebase

# Pull specific branch
git pull origin feature-x

# Pull with tags
git pull --tags

# Fetch only (doesn't merge)
git fetch

# Fetch all remotes
git fetch --all

# Fetch specific remote
git fetch origin
```

### Upstream Branch

```bash
# Set upstream when pushing
git push -u origin feature-x

# Set upstream after creating branch
git branch --set-upstream-to=origin/feature-x

# View upstream
git branch -vv

# Remove upstream
git branch --unset-upstream

# Pull from upstream automatically
git pull  # Works because upstream is set
```

---

## Undoing Changes

### Before Committing

```bash
# Discard changes in working directory
git restore filename.txt
# Or (older)
git checkout -- filename.txt

# Unstage file (keep changes)
git restore --staged filename.txt
# Or (older)
git reset HEAD filename.txt

# Discard all changes
git restore .

# Discard changes and staged changes
git reset --hard
```

### After Committing

```bash
# View previous commits
git log --oneline

# Undo last commit, keep changes staged
git reset --soft HEAD~1

# Undo last commit, keep changes unstaged
git reset --mixed HEAD~1
# Or just
git reset HEAD~1

# Undo last commit, discard changes
git reset --hard HEAD~1

# Undo multiple commits
git reset --hard HEAD~3  # Last 3 commits

# Revert commit (creates new commit that undoes it)
git revert commit-hash

# Revert last commit
git revert HEAD

# Revert without auto-committing
git revert --no-commit commit-hash
# Make changes if needed
git commit

# View reflog (history of HEAD changes)
git reflog

# Recover deleted commit using reflog
git log  # Shows lost commit
git checkout commit-hash
git switch -c recovered-branch
```

### Understanding Reset Modes

```
--soft   : Undo commit, keep changes staged
--mixed  : Undo commit, keep changes unstaged (default)
--hard   : Undo commit, discard changes

Example:
Current state: Committed "A", changes to file.txt staged

git reset --soft HEAD~1
  → Committed A removed, changes to file.txt still staged

git reset --mixed HEAD~1
  → Committed A removed, changes to file.txt unstaged

git reset --hard HEAD~1
  → Committed A removed, changes to file.txt deleted
```

---

## Stashing

### Understanding Stash

Stash temporarily saves changes without committing them. Useful for:
- Switching branches without committing incomplete work
- Cleaning working directory
- Saving work in progress

```bash
# Stash changes
git stash

# Stash with message
git stash save "WIP: implementing feature"

# Stash including untracked files
git stash -u
# Or
git stash --include-untracked

# View stash list
git stash list

# Show specific stash
git stash show stash@{0}

# Show stash differences
git stash show -p stash@{0}

# Apply stash (keep stash)
git stash apply stash@{0}
# Or latest
git stash apply

# Apply and delete stash
git stash pop

# Delete specific stash
git stash drop stash@{0}

# Delete all stashes
git stash clear

# Create branch from stash
git stash branch feature-x stash@{0}

# Partial stash (interactive)
git stash push -p  # Choose which hunks to stash

# Stash specific file
git stash push filename.txt
```

### Stash Workflow Example

```bash
# Working on feature-a
# Need to switch to urgent bug fix

# 1. Stash work
git stash

# 2. Switch branch
git switch -c bugfix

# 3. Fix bug and commit
echo "fix" > bug.txt
git add bug.txt
git commit -m "Fix urgent bug"

# 4. Go back to feature work
git switch feature-a

# 5. Restore work
git stash pop
```

---

## Rebasing

### Understanding Rebase

Rebase replays commits from one branch onto another. Creates linear history.

```
Before rebase:
main:  A --- B --- C
            \
feature:     D --- E

git rebase main feature

After rebase:
main:  A --- B --- C
                    \
feature:             D' --- E'
```

### Interactive Rebase

Interactive rebase allows editing commits during rebase.

```bash
# Rebase current branch onto main
git rebase main

# Interactive rebase last 3 commits
git rebase -i HEAD~3

# Interactive rebase onto specific commit
git rebase -i commit-hash

# Continue after resolving conflicts
git rebase --continue

# Abort rebase
git rebase --abort

# Skip conflicting commit
git rebase --skip
```

### Interactive Rebase Commands

When in interactive mode, you can:

```
pick   : Use commit
reword : Use commit but edit message
squash : Use commit but combine with previous (keep previous message)
fixup  : Like squash but discard message
drop   : Remove commit
edit   : Use commit but stop for amending
exec   : Execute shell command
```

### Interactive Rebase Example

```bash
# View last 3 commits
git log --oneline -3
# abc1234 Fix typo in docs
# def5678 Add new feature
# ghi9012 Initial commit

# Start interactive rebase
git rebase -i HEAD~3

# Editor opens with:
# pick ghi9012 Initial commit
# pick def5678 Add new feature
# pick abc1234 Fix typo in docs

# Change to:
# pick ghi9012 Initial commit
# pick def5678 Add new feature
# fixup abc1234 Fix typo in docs

# Result: Fix typo commit is combined with Add feature commit

# Or reword to change message:
# pick ghi9012 Initial commit
# pick def5678 Add new feature (change message to "Add amazing feature")
# pick abc1234 Fix typo in docs
```

### Rebase vs Merge

| Aspect | Rebase | Merge |
|--------|--------|-------|
| History | Linear | Non-linear |
| Readability | Cleaner | Shows actual flow |
| Safety | More dangerous with shared branches | Safer |
| Use Case | Local branches | Shared branches |

```bash
# When to use rebase:
# Local feature branch that hasn't been pushed
git rebase main

# When to use merge:
# Public branches or shared work
git merge feature
```

---

## Cherry-Picking

### Understanding Cherry-Pick

Cherry-pick applies changes from specific commits to current branch.

```
main:  A --- B --- C
            \
feature:     D --- E --- F

After cherry-picking E:
main:  A --- B --- C --- E'
```

```bash
# Cherry-pick specific commit
git cherry-pick commit-hash

# Cherry-pick multiple commits
git cherry-pick commit1 commit2 commit3

# Cherry-pick range of commits
git cherry-pick commit1..commit4
# Includes commit1 to commit4 (inclusive of commit4, exclusive of commit1)

# Cherry-pick range inclusive
git cherry-pick commit1^..commit4

# Cherry-pick without auto-committing
git cherry-pick --no-commit commit-hash

# Edit message when cherry-picking
git cherry-pick --edit commit-hash

# Continue after resolving conflicts
git cherry-pick --continue

# Abort cherry-pick
git cherry-pick --abort

# Skip conflicting commit
git cherry-pick --skip
```

### Cherry-Pick Use Cases

```bash
# Apply bug fix from one branch to another
git switch main
git cherry-pick bugfix-commit-hash

# Apply feature from feature branch to hotfix
git switch hotfix-branch
git cherry-pick feature-commit-hash

# Select specific commits to merge
git cherry-pick selective-commit-1 selective-commit-2
```

---

## Tags

### Understanding Tags

Tags are references to specific commits, typically used for releases.

### Creating Tags

```bash
# Create lightweight tag (just a pointer)
git tag v1.0.0

# Create annotated tag (full object with metadata)
git tag -a v1.0.0 -m "Version 1.0.0 release"

# Create tag for specific commit
git tag v1.0.0 commit-hash

# View tags
git tag

# List tags with pattern
git tag -l "v1.*"

# Show tag details
git show v1.0.0
```

### Working with Tags

```bash
# Push specific tag
git push origin v1.0.0

# Push all tags
git push origin --tags

# Delete local tag
git tag -d v1.0.0

# Delete remote tag
git push origin --delete v1.0.0
# Or
git push origin :v1.0.0

# Checkout specific tag
git checkout v1.0.0
# This creates detached HEAD state

# Create branch from tag
git checkout -b release-branch v1.0.0

# Tag with current date
git tag v1.0.0 -a -m "Release $(date)"
```

### Semantic Versioning

```bash
# Format: MAJOR.MINOR.PATCH

git tag v1.0.0  # MAJOR change (breaking)
git tag v1.1.0  # MINOR change (new feature, backward compatible)
git tag v1.0.1  # PATCH change (bug fix)

# Pre-release versions
git tag v1.0.0-alpha
git tag v1.0.0-beta
git tag v1.0.0-rc1
```

---

## Advanced Workflows

### Git Flow Workflow

Git Flow is a branching model using multiple long-running branches.

```
main (production)
  ↑
  ├← release (release preparation)
  │     ↑
  │     └← hotfix (urgent fixes)
  │
develop (development)
  ↑
  └← feature (new features)
```

```bash
# Initialize git flow
git flow init

# Start feature
git flow feature start feature-name

# Finish feature
git flow feature finish feature-name

# Start release
git flow release start v1.0.0

# Finish release
git flow release finish v1.0.0

# Start hotfix
git flow hotfix start v1.0.1

# Finish hotfix
git flow hotfix finish v1.0.1
```

### GitHub Flow

Simpler flow using main and feature branches.

```
main (always deployable)
  ↑
  └← feature branches (merged via pull request)
```

```bash
# Create feature branch
git switch -c add-user-authentication

# Make changes and commits
git add .
git commit -m "Add user authentication"

# Push feature branch
git push origin add-user-authentication

# Create Pull Request on GitHub
# Request review, discuss changes
# Merge PR when approved

# Delete feature branch
git push origin --delete add-user-authentication
git branch -d add-user-authentication
```

### Trunk-Based Development

Single main branch, frequent small commits.

```bash
# Short-lived branches (< 1 day)
git switch -c quick-fix
# Make small focused change
git add .
git commit -m "Quick fix"
git push
# Create PR, get approved, merge immediately
```

---

## Conflict Resolution

### Understanding Conflicts

Conflicts occur when Git can't automatically merge changes.

```
File content in both branches:
Branch A: Hello World
Branch B: Hello there

Git can't decide which to keep
```

### Detecting Conflicts

```bash
# Try to merge
git merge feature-branch

# Git indicates conflicts:
# CONFLICT (content): Merge conflict in file.txt
# Auto-merging file.txt
# CONFLICT (add/delete): Conflict in other-file.txt

# View conflicted files
git status

# Show conflicted files
git diff --name-only --diff-filter=U
```

### Conflict Markers

When conflict occurs, Git marks the conflict:

```
<<<<<<< HEAD
Hello World    (current branch changes)
=======
Hello there    (incoming branch changes)
>>>>>>> feature-branch
```

### Resolving Conflicts

```bash
# 1. Open file and resolve manually
# Edit the file, remove markers, keep desired content
# Save file

# 2. Or use merge tool
git mergetool

# 3. Stage resolved file
git add file.txt

# 4. Complete merge
git commit

# Abort merge if too complex
git merge --abort

# Or use ours strategy (keep current)
git checkout --ours file.txt
git add file.txt

# Or use theirs strategy (keep incoming)
git checkout --theirs file.txt
git add file.txt
```

### Merge Conflict Strategies

```bash
# Accept our version for all conflicts
git merge -X ours feature-branch

# Accept their version for all conflicts
git merge -X theirs feature-branch

# Merge specific file keeping ours
git checkout --ours path/to/file
git add path/to/file

# Show original version before merge
git show :1:file.txt  # Original
git show :2:file.txt  # Ours
git show :3:file.txt  # Theirs
```

### Rebase Conflicts

```bash
# Conflicts during rebase show differently
# You're replaying commits, conflicts happen per commit

# Resolve same way
# Edit conflicted files
git add .
git rebase --continue

# Or skip commit
git rebase --skip

# Or abort
git rebase --abort
```

---

## Best Practices

### Commit Messages

```bash
# Good commit message structure:
<type>(<scope>): <subject>

<body>

<footer>

# Example:
feat(auth): add user login functionality

Implement login form and authentication flow
Handles both email and username
Includes password reset functionality

Fixes #123
Closes #456

# Types:
# feat: new feature
# fix: bug fix
# docs: documentation changes
# style: code style (formatting, missing semicolons)
# refactor: refactoring code
# perf: performance improvements
# test: adding or updating tests

# Conventional Commits
git commit -m "feat(api): add new endpoint"
git commit -m "fix(bug): resolve race condition"
git commit -m "docs: update README"
```

### Branching Strategy

```bash
# Use meaningful branch names
git switch -c feature/user-authentication
git switch -c bugfix/login-redirect
git switch -c hotfix/payment-processing
git switch -c docs/update-readme

# Not:
git switch -c my-changes
git switch -c work
git switch -c fix1
```

### Code Review Workflow

```bash
# Push feature branch
git push origin feature-x

# Create Pull Request on GitHub/GitLab
# Wait for review and approval

# Make requested changes
git add .
git commit -m "Address review comments"
git push

# Merge when approved
# Delete branch after merge
```

### Keep History Clean

```bash
# Before pushing, clean up commits
git rebase -i origin/main

# Combine related commits
# Edit commit messages for clarity

# Push cleaned history
git push --force-with-lease
```

### Regular Pulling

```bash
# Keep branch up to date
git pull --rebase origin main

# Or fetch then rebase
git fetch origin
git rebase origin/main
```

### Backup Before Destructive Operations

```bash
# Before force push, rebase, reset
git branch backup-before-dangerous-operation

# Then if something goes wrong
git reset --hard backup-before-dangerous-operation
```

---

## Common Issues and Solutions

### Accidentally Committed Wrong Thing

```bash
# Committed to wrong branch
git reset --soft HEAD~1  # Undo commit, keep changes
git stash  # Save changes
git switch correct-branch
git stash pop  # Restore changes
git commit  # Commit on correct branch

# Committed on master instead of branch
git branch feature-x  # Create branch at current position
git reset --hard origin/master  # Reset master to remote
git switch feature-x  # Switch to branch with your commit
```

### Accidentally Deleted Branch

```bash
# View reflog to find deleted branch
git reflog

# Create new branch from the commit
git branch recovered-branch commit-hash
```

### Accidentally Pushed Sensitive Data

```bash
# Remove from history (complex, use with caution)
git filter-branch --tree-filter 'rm -f sensitive-file.txt' HEAD

# Or use BFG Repo-Cleaner (easier)
bfg --delete-files sensitive-file.txt

# Force push to remove from remote
git push --force-with-lease

# Or revert commit if not too late
git revert commit-hash
```

### Large File Accidentally Committed

```bash
# Remove large file from history
git filter-branch --tree-filter 'rm -f large-file.iso' HEAD

# Add to .gitignore
echo "large-file.iso" >> .gitignore

# Force push
git push --force-with-lease

# Or use Git LFS for large files going forward
git lfs install
git lfs track "*.iso"
```

### Merge Conflicts Won't Resolve

```bash
# Abort and try different approach
git merge --abort

# Try different merge strategy
git merge -s ours feature-branch  # Keep all of ours
git merge -s theirs feature-branch  # Keep all of theirs

# Or use merge tool with visual interface
git mergetool
```

### Lost Commits

```bash
# Check reflog
git reflog

# Find the commit
git log commit-hash

# Recover to branch
git branch recovered commit-hash
```

### Stuck in Detached HEAD

```bash
# Current state: detached HEAD
git log
# Shows you're not on a branch

# Create branch to save your commits
git branch recovery-branch

# Switch to a branch
git switch main
```

---

## Complete Git Commands Reference

This section provides a comprehensive reference of all essential Git commands with complete explanations and usage examples.

### Setup & Configuration Commands

#### git config
Manage Git configuration settings at global, local, or system level.

```bash
# Set global user name
git config --global user.name "John Doe"
# Explanation: Sets the name associated with commits globally

# Set global email
git config --global user.email "john@example.com"
# Explanation: Sets email for all commits

# List all global config
git config --global --list
# Explanation: Shows all global settings

# Set local config (repository only)
git config user.name "Project Name"
# Explanation: Sets name for this repo only

# Create aliases
git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.ci commit
git config --global alias.st status
# Explanation: Create shortcuts for commands

# Remove configuration
git config --global --unset user.name
# Explanation: Removes a configuration setting

# View specific setting
git config user.name
# Explanation: Shows the value of specific config

# Open config file in editor
git config --global --edit
# Explanation: Edit global config file directly
```

### Repository Initialization & Cloning Commands

#### git init
Initialize a new Git repository.

```bash
# Initialize in current directory
git init
# Process: Creates .git folder with repository structure
# Creates local Git repository

# Initialize with specific branch
git init --initial-branch=main
# Process: Creates repo with 'main' as default branch

# Initialize new directory
mkdir my-project && cd my-project && git init
# Process: Creates new directory and initializes Git

# Verify initialization
ls -la
# Shows .git folder confirming initialization
```

#### git clone
Clone existing repository to local machine.

```bash
# Basic clone
git clone https://github.com/user/repo.git
# Process:
# 1. Downloads entire repository
# 2. Creates local copy
# 3. Sets up remote tracking (origin)
# 4. Checks out main branch

# Clone into specific directory
git clone https://github.com/user/repo.git my-folder
# Process: Clones into 'my-folder' instead of default name

# Clone specific branch
git clone --branch develop https://github.com/user/repo.git
# Process: Clones only specified branch initially

# Shallow clone (limited history)
git clone --depth 1 https://github.com/user/repo.git
# Process: Clones only latest commit (faster, smaller)

# Clone with depth and branch
git clone --branch main --depth 1 https://github.com/user/repo.git
# Process: Shallow clone of specific branch

# Clone with SSH
git clone git@github.com:user/repo.git
# Process: Uses SSH authentication instead of HTTPS

# Clone with timeout
git clone --timeout=60 https://github.com/user/repo.git
# Process: Sets timeout for network operations

# Recursive clone (with submodules)
git clone --recursive https://github.com/user/repo.git
# Process: Clones repo including all submodule repositories
```

### Status & Information Commands

#### git status
Show working directory and staging area status.

```bash
# Check status
git status
# Output shows:
# - Current branch
# - Changes to commit
# - Changes not staged
# - Untracked files

# Short format
git status -s
# Or
git status --short
# Output: M = modified, A = added, D = deleted, ?? = untracked

# Show branch information
git status -b
# Shows upstream branch tracking info

# Only show untracked files
git status --untracked-files=no
# Ignores untracked files in output

# Show ignored files
git status --ignored
# Shows files ignored by .gitignore
```

#### git diff
Show differences between versions.

```bash
# Show unstaged changes
git diff
# Process: Compares working directory with staging area

# Show staged changes
git diff --staged
# Or
git diff --cached
# Process: Shows what will be committed

# Show all changes (staged and unstaged)
git diff HEAD
# Process: Compares working directory with last commit

# Show differences between branches
git diff main feature
# Process: Shows differences between two branches

# Show differences for specific file
git diff file.txt
# Compares specific file's changes

# Show statistics
git diff --stat
# Shows summary without full diff

# Show words instead of lines
git diff --word-diff
# Highlights word-level changes

# Show color output
git diff --color
# Colorizes output for readability

# Compare commits
git diff commit1 commit2
# Shows differences between two commits
```

#### git log
View commit history.

```bash
# View full history
git log
# Shows: commit hash, author, date, message

# View recent commits
git log -5
# Shows last 5 commits

# One line per commit
git log --oneline
# Compact format, easier to scan

# Graph visualization
git log --graph --oneline --all
# Shows branching structure graphically

# Show author information
git log --author="John"
# Shows commits by specific author

# Show commits since date
git log --since="2024-01-01"
# Shows commits after date

# Show commits until date
git log --until="2024-12-31"
# Shows commits before date

# Show commits in date range
git log --since="1 month ago" --until="1 week ago"
# Shows commits between dates

# Search commit messages
git log --grep="bug fix"
# Shows commits matching pattern

# Show file history
git log -- filename.txt
# Shows commits affecting specific file

# Show changes in commits
git log -p
# Shows full diff for each commit

# Show statistics
git log --stat
# Shows files changed, insertions, deletions

# Formatted output
git log --pretty=format:"%h %an %ad %s" --date=short
# Custom format: hash, author, date (short), message

# Show merge commits
git log --merges
# Shows only merge commits

# Show non-merge commits
git log --no-merges
# Shows all except merge commits

# Combine multiple filters
git log --author="John" --since="2024-01-01" --grep="feature"
# Shows commits matching all criteria
```

#### git show
Display detailed information about specific commit or object.

```bash
# Show specific commit
git show commit-hash
# Displays: commit info, author, diff of changes

# Show latest commit
git show HEAD
# Shows current commit details

# Show previous commit
git show HEAD~1
# Shows parent commit

# Show specific file at commit
git show commit-hash:path/to/file
# Shows file content at that commit

# Show tag details
git show tag-name
# Shows annotated tag information

# Show tree object
git show tree-hash
# Shows directory structure at that point

# Show blob object
git show blob-hash
# Shows file content

# Show commit stats
git show --stat commit-hash
# Shows files changed without full diff
```

#### git blame
Show who changed each line of file.

```bash
# See line-by-line changes
git blame filename.txt
# Shows: commit hash, author, date, code

# Show specific line range
git blame -L 10,20 filename.txt
# Shows blame for lines 10-20

# Show email instead of name
git blame -e filename.txt
# Displays author emails

# Show dates in different format
git blame --date=short filename.txt
# Shows shortened date format

# Ignore whitespace changes
git blame -w filename.txt
# Ignores whitespace when finding changes

# Track line movements between files
git blame -C filename.txt
# Finds where lines came from if moved
```

### Staging Area Commands

#### git add
Stage changes for commit.

```bash
# Add specific file
git add filename.txt
# Process: Moves file from working directory to staging area

# Add all changes
git add .
# Process: Stages all modified files in current directory

# Add all in repository
git add -A
# Or
git add --all
# Process: Stages all changes everywhere in repo

# Add only modified files (not new)
git add -u
# Or
git add --update
# Process: Updates already-tracked files only

# Add interactively
git add -i
# Or
git add --interactive
# Process: Interactive menu to choose what to stage

# Add by patch (hunk selection)
git add -p
# Or
git add --patch
# Process: Review each change, choose to stage

# Add files matching pattern
git add *.js
# Process: Stages all JavaScript files

# Add directory
git add src/
# Process: Stages all files in directory

# Force add ignored files
git add -f ignored-file.txt
# Process: Stages file even if in .gitignore

# Preview what will be staged
git add --dry-run
# Process: Shows what would be added without actually adding
```

#### git restore
Restore files to previous state.

```bash
# Discard working directory changes
git restore filename.txt
# Process: Reverts file to last staged version

# Restore from specific commit
git restore --source=commit-hash filename.txt
# Process: Reverts file to that commit's version

# Unstage file
git restore --staged filename.txt
# Process: Removes file from staging area, keeps changes

# Discard all changes
git restore .
# Process: Reverts all files in working directory

# Preview before restoring
git restore --dry-run filename.txt
# Process: Shows what would be restored
```

### Commit Commands

#### git commit
Save staged changes to repository.

```bash
# Basic commit
git commit -m "Commit message"
# Process: Creates new commit with staged changes

# Commit with detailed message
git commit -m "Title" -m "Detailed description"
# Process: First line is title, second is body

# Interactive commit message
git commit
# Process: Opens editor for detailed message

# Commit all tracked files
git commit -a -m "Message"
# Or
git commit --all -m "Message"
# Process: Stages and commits all tracked files

# Amend last commit
git commit --amend
# Process: Modifies last commit message and/or adds files

# Amend without changing message
git commit --amend --no-edit
# Process: Adds staged files to last commit

# Force amend (rewrite history)
git commit --amend --force
# Process: Changes last commit completely

# Empty commit (for testing)
git commit --allow-empty -m "Empty commit"
# Process: Creates commit with no changes

# Sign commit (GPG)
git commit -S -m "Message"
# Process: Signs commit with GPG key

# Commit specific lines
git commit -p -m "Message"
# Process: Choose specific hunks to commit

# Verbose commit (show diff)
git commit -v
# Process: Shows diff in commit message editor

# Dry run (preview without committing)
git commit --dry-run
# Process: Shows what would be committed

# Use template
git commit -t template.txt
# Process: Pre-fills message from template
```

### Branch Commands

#### git branch
Manage branches.

```bash
# Create new branch
git branch feature-x
# Process: Creates branch at current commit, doesn't switch

# Create branch from specific commit
git branch feature-x commit-hash
# Process: Creates branch pointing to that commit

# List local branches
git branch
# Shows all local branches, * marks current

# List with descriptions
git branch -v
# Shows branches with last commit

# List remote branches
git branch -r
# Shows all remote branches

# List all branches
git branch -a
# Shows local and remote branches

# Show current branch
git branch --show-current
# Process: Displays current branch name

# Show merged branches
git branch --merged
# Shows branches already merged to current

# Show unmerged branches
git branch --no-merged
# Shows branches not yet merged

# Rename branch
git branch -m old-name new-name
# Or locally
git branch -m new-name
# Process: Renames branch

# Delete branch (safe)
git branch -d branch-name
# Process: Deletes only if merged

# Force delete branch
git branch -D branch-name
# Process: Deletes regardless of merge status

# Delete multiple branches
git branch -d branch1 branch2
# Process: Deletes multiple branches

# Set upstream branch
git branch -u origin/main
# Process: Sets tracking branch

# Show tracking info
git branch -vv
# Shows upstream branches

# Create and track remote branch
git branch --track feature origin/feature
# Process: Creates local branch tracking remote

# Copy branch
git branch -c old-branch new-branch
# Process: Creates copy of branch

# Show remote-tracking branches
git branch -r
# Shows branches from remote
```

#### git checkout
Switch branches or restore files.

```bash
# Switch to existing branch
git checkout main
# Process: Changes HEAD to main branch

# Create and switch to new branch
git checkout -b feature-x
# Process: Creates branch and switches immediately

# Create from specific commit
git checkout -b feature commit-hash
# Process: Creates and switches to new branch at commit

# Switch to remote branch
git checkout origin/feature
# Process: Creates detached HEAD at remote branch

# Create local branch from remote
git checkout --track origin/feature
# Or
git checkout -b feature origin/feature
# Process: Creates local branch tracking remote

# Discard file changes
git checkout -- filename.txt
# Process: Reverts file to last committed state

# Discard multiple files
git checkout -- *.txt
# Process: Reverts all .txt files

# Restore deleted file
git checkout HEAD filename.txt
# Process: Restores deleted file from last commit

# Switch to previous branch
git checkout -
# Process: Switches to previously checked out branch

# Checkout specific commit
git checkout commit-hash
# Process: Detached HEAD at that commit

# Detached HEAD: Create branch from current position
git checkout -b new-branch
# Saves commits made in detached state
```

#### git switch
Switch branches (newer, clearer alternative to checkout).

```bash
# Switch to branch
git switch main
# Process: Changes to main branch

# Create and switch
git switch -c feature-x
# Or
git switch --create feature-x
# Process: Creates and switches to new branch

# Switch to previous branch
git switch -
# Process: Switches to previously used branch

# Create from specific commit
git switch -c feature commit-hash
# Process: Creates branch at commit and switches

# Detach HEAD (checkout specific commit)
git switch --detach commit-hash
# Process: Moves to specific commit
```

### Merge & Rebase Commands

#### git merge
Combine branches together.

```bash
# Merge feature into current branch
git merge feature
# Process:
# 1. Compares current branch with feature branch
# 2. If fast-forward possible, moves pointer
# 3. If not, creates merge commit

# Merge specific commit
git merge commit-hash
# Process: Merges that specific commit

# Merge with custom message
git merge feature -m "Merge feature branch"
# Process: Uses custom commit message

# No fast-forward merge
git merge --no-ff feature
# Process: Always creates merge commit

# Squash before merge
git merge --squash feature
# Process: Combines all feature commits into one

# Preview before merging
git merge --no-commit --no-ff feature
# Process: Stages merge without committing

# Abort merge
git merge --abort
# Process: Cancels merge, restores previous state

# Merge strategy (ours)
git merge -X ours feature
# Process: Takes our version for conflicts

# Merge strategy (theirs)
git merge -X theirs feature
# Process: Takes their version for conflicts

# Merge with specific file strategy
git merge -X ours feature -- path/to/file
# Process: For that file, takes ours

# Show statistics
git merge --stat feature
# Shows file changes without full diff

# Verbose merge
git merge -v feature
# Shows detailed merge information

# Dry run
git merge --no-commit --no-ff feature
# Process: Test merge without committing

# Trust marker (continue merge)
git merge --continue
# Process: Continues merge after conflict resolution
```

#### git rebase
Replay commits on different base.

```bash
# Rebase on branch
git rebase main
# Process:
# 1. Find common ancestor
# 2. Temporarily save commits
# 3. Apply base branch's commits
# 4. Replay saved commits on top

# Interactive rebase
git rebase -i HEAD~3
# Process: Opens editor to modify last 3 commits

# Rebase onto specific commit
git rebase commit-hash
# Process: Replays current commits on that base

# Continue rebase
git rebase --continue
# Process: Continue after resolving conflicts

# Skip commit during rebase
git rebase --skip
# Process: Omits conflicting commit

# Abort rebase
git rebase --abort
# Process: Cancels rebase, returns to original state

# Autostash during rebase
git rebase --autostash main
# Process: Automatically stashes changes

# Force rebase with merge commits
git rebase -p main
# Or
git rebase --preserve-merges main
# Process: Preserves merge commits

# Rebase from upstream
git rebase upstream main
# Process: Rebases main onto upstream

# Rebase only (no merge)
git pull --rebase
# Process: Pulls with rebase instead of merge

# Force rebase local commits
git rebase -f origin/main
# Process: Force rebase even if already rebased
```

### Push & Pull Commands

#### git push
Upload changes to remote repository.

```bash
# Push current branch
git push
# Process: Pushes to default remote (origin)

# Push to specific remote
git push origin main
# Process: Pushes main branch to origin

# Push all branches
git push --all
# Process: Pushes all local branches

# Push specific branch
git push origin feature
# Process: Pushes feature branch to origin

# Create remote branch
git push -u origin feature
# Or
git push --set-upstream origin feature
# Process: Pushes and sets upstream tracking

# Push all commits with tags
git push --follow-tags
# Process: Pushes commits and associated tags

# Push tags only
git push --tags
# Process: Pushes all local tags

# Push specific tag
git push origin v1.0.0
# Process: Pushes specific tag to remote

# Force push (dangerous!)
git push --force
# Or
git push -f
# Process: Overwrites remote with local (use carefully)

# Safe force push
git push --force-with-lease
# Process: Force push only if remote hasn't changed

# Delete remote branch
git push origin --delete feature
# Or
git push origin :feature
# Process: Removes branch from remote

# Delete remote tag
git push origin --delete v1.0.0
# Or
git push origin :v1.0.0
# Process: Removes tag from remote

# Push to multiple remotes
git push origin develop upstream develop
# Process: Pushes develop to both origin and upstream

# Push specific commit
git push origin commit-hash:branch-name
# Process: Pushes single commit to remote

# Dry run
git push --dry-run
# Process: Shows what would be pushed

# Verbose
git push -v
# Shows detailed push information

# Atomic push (all or nothing)
git push --atomic origin main develop
# Process: Either all branches push or none do

# Prune remote branches
git push origin --prune
# Process: Deletes remote branches no longer in local
```

#### git pull
Download and merge remote changes.

```bash
# Basic pull
git pull
# Process:
# 1. Fetches from default remote
# 2. Merges remote changes

# Pull with rebase
git pull --rebase
# Process: Pulls with rebase instead of merge

# Pull specific branch
git pull origin main
# Process: Fetches and merges specific branch

# Pull from specific remote
git pull upstream main
# Process: Pulls from different remote

# Pull without merge
git fetch
# Process: Only downloads without merging

# Pull with tags
git pull --tags
# Process: Includes tags in pull

# Dry run
git pull --dry-run
# Process: Shows what would be pulled

# Verbose
git pull -v
# Shows detailed information

# Rebase with autostash
git pull --rebase --autostash
# Process: Stashes, rebases, applies stash

# Only fast-forward
git pull --ff-only
# Process: Fails if non-fast-forward merge required

# Create merge commit even if FF
git pull --no-ff
# Process: Always creates merge commit
```

#### git fetch
Download changes without merging.

```bash
# Fetch from default remote
git fetch
# Process: Downloads latest changes from origin

# Fetch from specific remote
git fetch origin
# Process: Gets updates from origin only

# Fetch specific branch
git fetch origin main
# Process: Gets specific branch from remote

# Fetch all remotes
git fetch --all
# Process: Fetches from all configured remotes

# Fetch with tags
git fetch --tags
# Process: Includes tags in fetch

# Fetch and prune
git fetch --prune
# Or
git fetch -p
# Process: Removes deleted remote branches locally

# Fetch all tags
git fetch origin 'refs/tags/*:refs/tags/*'
# Process: Fetches all tags

# Dry run
git fetch --dry-run
# Shows what would be fetched

# Verbose
git fetch -v
# Shows detailed information

# Update remote branches
git fetch origin --force
# Process: Force update local tracking branches
```

### Remote Commands

#### git remote
Manage remote repositories.

```bash
# List remotes
git remote
# Shows remote names (usually 'origin')

# List remotes with URLs
git remote -v
# Or
git remote --verbose
# Shows URL for each remote

# Add remote
git remote add origin https://github.com/user/repo.git
# Process: Creates new remote reference

# Add with different name
git remote add upstream https://github.com/upstream/repo.git
# Process: Creates additional remote

# Remove remote
git remote remove origin
# Or
git remote rm origin
# Process: Deletes remote reference

# Rename remote
git remote rename origin backup
# Process: Renames remote

# Show remote details
git remote show origin
# Shows: URL, branches, tracking info

# Change remote URL
git remote set-url origin new-url
# Process: Updates remote's URL

# Add additional URL
git remote set-url origin --add new-url
# Process: Remote can push to multiple URLs

# Remove URL
git remote set-url origin --delete url
# Process: Removes specific URL

# Set push URL
git remote set-url origin --push new-url
# Process: Sets different URL for pushing

# Get remote URL
git config --get remote.origin.url
# Shows the URL for origin remote

# Prune branches
git remote prune origin
# Process: Removes local branches for deleted remote branches
```

### Stash Commands

#### git stash
Temporarily save changes without committing.

```bash
# Save work in progress
git stash
# Or
git stash save
# Process: Saves all changes, reverts working directory

# Save with message
git stash save "WIP: feature implementation"
# Process: Stashes with descriptive message

# Stash untracked files
git stash -u
# Or
git stash --include-untracked
# Process: Includes new files in stash

# Stash only staged changes
git stash --staged
# Or
git stash -k
# Process: Keeps unstaged changes in working directory

# Stash specific file
git stash push filename.txt
# Process: Stashes only specific file

# Interactive stash
git stash push -p
# Or
git stash -p
# Process: Choose specific hunks to stash

# List all stashes
git stash list
# Shows all saved stashes with messages

# Show stash details
git stash show stash@{0}
# Or
git stash show
# Shows files in latest stash

# Show stash diff
git stash show -p
# Or
git stash show -p stash@{0}
# Shows full diff of stash

# Apply latest stash
git stash apply
# Or
git stash apply stash@{0}
# Process: Applies stash without removing it

# Apply specific stash
git stash apply stash@{2}
# Process: Applies older stash

# Apply and remove stash
git stash pop
# Or
git stash pop stash@{0}
# Process: Applies and deletes stash

# Delete stash
git stash drop
# Or
git stash drop stash@{0}
# Process: Removes stash without applying

# Delete all stashes
git stash clear
# Process: Removes all stashes

# Create branch from stash
git stash branch feature-x
# Or
git stash branch feature-x stash@{0}
# Process: Creates branch and applies stash

# Stash dirty directory
git stash push -m "Save work" -u
# Saves all changes including untracked
```

### Undo & Reset Commands

#### git reset
Undo commits or staging.

```bash
# Undo last commit (keep changes staged)
git reset --soft HEAD~1
# Process: Removes commit, keeps changes in staging area

# Undo last commit (keep changes unstaged)
git reset --mixed HEAD~1
# Or just
git reset HEAD~1
# Process: Removes commit, keeps changes in working directory

# Undo last commit (discard changes)
git reset --hard HEAD~1
# Process: Removes commit and all changes

# Undo multiple commits
git reset --hard HEAD~3
# Process: Removes last 3 commits

# Reset to specific commit
git reset --soft commit-hash
# Process: Resets to that commit (soft/mixed/hard)

# Unstage all files
git reset HEAD
# Process: Removes everything from staging area

# Unstage specific file
git reset HEAD filename.txt
# Process: Removes file from staging area

# Hard reset to remote
git reset --hard origin/main
# Process: Discards all local changes, matches remote

# Reset with reflog
git reset --hard reflog-entry
# Recovers from deleted commits

# Dry run reset
git reset --dry-run --hard HEAD~1
# Shows what would be reset

# Reset file to commit
git reset commit-hash -- filename.txt
# Resets specific file to that commit
```

#### git revert
Create commit that undoes changes.

```bash
# Revert last commit
git revert HEAD
# Process: Creates new commit undoing the changes

# Revert specific commit
git revert commit-hash
# Process: Creates new commit undoing that commit

# Revert multiple commits
git revert commit1 commit2 commit3
# Process: Creates commits undoing each

# Revert with custom message
git revert commit-hash -m "Undo feature"
# Process: Uses custom message

# Revert without auto-commit
git revert --no-commit commit-hash
# Process: Stages revert without committing

# Continue after resolving conflicts
git revert --continue
# Process: Continues revert after conflict fix

# Abort revert
git revert --abort
# Process: Cancels revert operation

# Revert merge commit
git revert -m 1 merge-commit-hash
# Process: Reverts merge (specify parent to keep)

# Dry run
git revert --no-commit commit-hash
# Shows what revert would do
```

#### git clean
Remove untracked files.

```bash
# Dry run (show what would be deleted)
git clean -n
# Or
git clean --dry-run
# Process: Shows which files would be removed

# Delete untracked files
git clean -f
# Or
git clean --force
# Process: Removes untracked files (not directories)

# Delete files and directories
git clean -fd
# Or
git clean --force --directories
# Process: Removes untracked files and folders

# Interactive cleanup
git clean -i
# Or
git clean --interactive
# Process: Choose files to delete

# Remove ignored files too
git clean -fdx
# Or
git clean --force --directories --exclude
# Process: Also removes gitignored files

# Only remove gitignored files
git clean -fX
# Process: Removes only ignored files

# Dry run with all options
git clean -fdxn
# Shows everything that would be deleted
```

### Tag Commands

#### git tag
Manage version tags.

```bash
# Create lightweight tag
git tag v1.0.0
# Process: Creates simple pointer to current commit

# Create annotated tag
git tag -a v1.0.0 -m "Version 1.0.0"
# Process: Creates full tag object with message

# Create tag for specific commit
git tag v1.0.0 commit-hash
# Process: Tags that commit

# List tags
git tag
# Shows all tags

# List tags matching pattern
git tag -l "v1.*"
# Or
git tag --list "v1.*"
# Shows matching tags

# Show tag details
git show v1.0.0
# Shows annotated tag information

# Show lightweight tag
git show v1.0.0^{}
# Shows commit that tag points to

# Verify signed tag
git tag -v v1.0.0
# Verifies GPG signature

# Sign tag
git tag -s v1.0.0 -m "Signed release"
# Or
git tag --sign
# Creates GPG-signed tag

# Check tag exists
git rev-parse v1.0.0
# Returns commit hash if tag exists

# Delete tag
git tag -d v1.0.0
# Or
git tag --delete
# Removes local tag

# Rename tag
git tag new-name old-name
git tag -d old-name
git push origin new-name :old-name
# Process: Create new, delete old, update remote

# Push tag
git push origin v1.0.0
# Pushes specific tag to remote

# Push all tags
git push --tags
# Or
git push origin --all
# Pushes all local tags

# Delete remote tag
git push origin --delete v1.0.0
# Or
git push origin :v1.0.0
# Removes tag from remote

# Checkout tag
git checkout v1.0.0
# Creates detached HEAD at tag

# Create branch from tag
git checkout -b release-1.0 v1.0.0
# Creates branch at tagged commit
```

### Cherry-Pick Commands

#### git cherry-pick
Apply specific commits to current branch.

```bash
# Cherry-pick single commit
git cherry-pick commit-hash
# Process: Applies that commit's changes here

# Cherry-pick multiple commits
git cherry-pick commit1 commit2 commit3
# Process: Applies commits in order

# Cherry-pick range
git cherry-pick commit1..commit5
# Process: Applies commit1 to commit5 (exclusive of commit1)

# Cherry-pick inclusive range
git cherry-pick commit1^..commit5
# Process: Includes both endpoints

# Cherry-pick without committing
git cherry-pick --no-commit commit-hash
# Process: Stages changes without creating commit

# Cherry-pick with edit
git cherry-pick --edit commit-hash
# Or
git cherry-pick -e
# Opens editor to modify commit message

# Continue after conflict
git cherry-pick --continue
# Process: Resumes after resolving conflicts

# Abort cherry-pick
git cherry-pick --abort
# Process: Cancels operation, restores state

# Skip conflicting commit
git cherry-pick --skip
# Process: Skips current commit, continues

# Create merge commit
git cherry-pick -m 1 merge-commit
# Process: Specifies which parent to use

# Dry run
git cherry-pick --no-commit commit-hash
# Test without committing
```

### Search & Find Commands

#### git grep
Search for patterns in files.

```bash
# Search in working directory
git grep "function"
# Process: Finds all occurrences of 'function'

# Search in specific file
git grep "function" -- filename.txt
# Process: Searches specific file

# Show line numbers
git grep -n "function"
# Process: Includes line numbers in results

# Count matches
git grep -c "function"
# Shows count per file

# Show filenames only
git grep -l "function"
# Shows files containing match

# Inverse match (not containing)
git grep -v "function"
# Shows lines not matching

# Case insensitive
git grep -i "FUNCTION"
# Process: Ignores case

# Search at specific commit
git grep "function" HEAD
# Searches at that commit

# Search all commits
git log -p -S "function"
# Finds commits that added/removed

# Regular expression
git grep -E "func.*ion"
# Process: Uses regex pattern

# Show context
git grep -C 3 "function"
# Shows 3 lines before/after match
```

#### git log (search variations)
Find commits by content.

```bash
# Search commit messages
git log --grep="feature"
# Process: Finds commits matching message

# Search author
git log --author="John"
# Process: Commits by specific author

# Search by date
git log --since="2024-01-01" --until="2024-12-31"
# Process: Commits in date range

# Search code changes
git log -S "function_name"
# Process: Commits that added/removed this

# Search file changes
git log -- filename.txt
# Process: Commits affecting specific file

# Reverse log
git log --reverse
# Shows oldest commits first

# Follow renames
git log --follow -- filename.txt
# Tracks file through renames

# Search branches
git log --all --graph --oneline
# Shows all branches with commits
```

### Utility Commands

#### git help
Get help on Git commands.

```bash
# General help
git help
# Shows available commands

# Help for specific command
git help commit
# Or
git commit --help
# Shows detailed help

# List all commands
git help -a
# Or
git --help -a
# Shows complete command list

# Show guides
git help -g
# Shows available guides

# Online help
git help -w commit
# Opens help in web browser
```

#### git version
Show Git version.

```bash
# Check version
git --version
# Displays installed Git version

# Detailed version info
git version
# Shows version information
```

#### git reflog
Show reference logs (history of HEAD changes).

```bash
# Show reflog
git reflog
# Shows recent HEAD movements

# Show specific reference
git reflog main
# Shows main branch history

# Show with timestamps
git reflog --all --decorate
# Shows all with decorations

# Expire entries
git reflog expire --expire=1.month.ago --all
# Cleans old reflog entries

# Recover deleted commits
git show reflog-entry
# Uses reflog to find lost commits

# Check for garbage collection
git reflog --all
# Lists all recoverable commits
```

---

## Conclusion

### Q1: What is Git and why is it important?

**Answer:**
Git is a distributed version control system that:
- Tracks changes to code over time
- Enables collaboration between developers
- Provides complete history of all changes
- Allows parallel development with branching
- Is free and open source
- Is the industry standard (GitHub, GitLab, Bitbucket)

**Why important:**
- Prevents code loss
- Enables rollback if needed
- Facilitates code review and team collaboration
- Allows multiple developers to work on same project
- Provides audit trail of who changed what and when

---

### Q2: Explain the difference between Git and GitHub.

**Answer:**
- **Git**: Version control system (software)
- **GitHub**: Platform/service hosting Git repositories

**Git:**
- Local version control
- Command-line tool
- Free and open source
- Can be used with any server

**GitHub:**
- Web platform for hosting repositories
- Provides collaboration features
- Issue tracking, pull requests
- Free and paid tiers
- Social features (followers, profiles)

Other similar platforms: GitLab, Bitbucket

---

### Q3: What are the three states of Git?

**Answer:**
1. **Modified**: File changed but not staged
2. **Staged**: File marked for commit
3. **Committed**: Changes saved in Git

```
git add    (modified → staged)
git commit (staged → committed)
```

---

### Q4: Difference between fetch and pull?

**Answer:**
- **Fetch**: Downloads changes from remote, doesn't merge
  ```bash
  git fetch origin
  # Updates remote tracking branches
  # You can review before merging
  ```

- **Pull**: Fetch + Merge
  ```bash
  git pull origin main
  # Equivalent to:
  # git fetch origin
  # git merge origin/main
  ```

**When to use:**
- Use fetch when you want to review changes
- Use pull for quick update

---

### Q5: What is a merge conflict and how to resolve?

**Answer:**
Merge conflict occurs when Git can't automatically merge changes from two branches because they modified same part of file.

**Causes:**
- Both branches modify same lines
- One branch deletes file another modifies
- Both branches add different things to file

**Resolution:**
1. Identify conflicted files: `git status`
2. Edit file manually, remove conflict markers
3. Keep desired code
4. Stage file: `git add file.txt`
5. Complete merge: `git commit`

**Or use strategies:**
```bash
git merge -X ours branch   # Keep our version
git merge -X theirs branch # Keep their version
```

---

### Q6: Explain branching strategy (Git Flow, GitHub Flow).

**Answer:**

**Git Flow:**
- Multiple long-running branches
- `main` (production), `develop` (development)
- Feature branches from develop
- Release branches for releases
- Hotfix branches for urgent fixes
- Complex but good for scheduled releases

**GitHub Flow:**
- Simple, main-based approach
- `main` (always deployable)
- Feature branches merged via PR
- Used by GitHub itself
- Better for continuous deployment

**Trunk-Based Development:**
- Single main branch
- Short-lived feature branches (< 1 day)
- Frequent small commits
- Used by large teams

---

### Q7: What is rebase and when to use it?

**Answer:**
Rebase replays commits from one branch onto another, creating linear history.

```
Before:
main: A - B - C
           \
feature:    D - E

After rebase:
main: A - B - C
            \
feature:     D' - E'
```

**Advantages:**
- Linear history (easier to read)
- Clean commit log
- Easier to understand progression

**Disadvantages:**
- Rewrites history (dangerous on shared branches)
- Can be confusing for beginners

**When to use:**
- Local branches before pushing
- Features not shared with others

**When NOT to use:**
- Public/shared branches
- After pushing to remote

---

### Q8: What is cherry-pick?

**Answer:**
Cherry-pick applies specific commit(s) to current branch.

```bash
git cherry-pick commit-hash
```

**Use cases:**
- Apply bug fix from one branch to another
- Selective cherry-pick of commits
- Avoid merging entire branch

**Example:**
```bash
# Bug fix on feature branch, need on main too
git switch main
git cherry-pick bugfix-commit

# Creates new commit with same changes
```

---

### Q9: Difference between reset, revert, and checkout?

**Answer:**

| Command | Purpose | Safety | Use Case |
|---------|---------|--------|----------|
| reset | Undo commits | Dangerous | Local changes |
| revert | Create commit that undoes changes | Safe | Shared branches |
| checkout | Switch branches/files | Safe | Switching context |

**Reset:**
```bash
git reset --soft HEAD~1   # Undo commit, keep staged changes
git reset --mixed HEAD~1  # Undo commit, keep unstaged changes (default)
git reset --hard HEAD~1   # Undo commit, discard changes
```

**Revert:**
```bash
git revert commit-hash    # Creates new commit undoing changes
```

**Checkout:**
```bash
git checkout branch-name  # Switch to branch
git checkout -- file.txt  # Discard changes to file
```

---

### Q10: What are tags and why use them?

**Answer:**
Tags mark specific points in history, typically releases.

**Lightweight tags:**
```bash
git tag v1.0.0  # Just a pointer
```

**Annotated tags:**
```bash
git tag -a v1.0.0 -m "Version 1.0.0"  # Full object with metadata
```

**Uses:**
- Mark releases
- Reference specific versions
- Easy checkout of release version

**Semantic versioning:**
```
v MAJOR.MINOR.PATCH
v1.2.3

MAJOR: Breaking changes
MINOR: New features (backward compatible)
PATCH: Bug fixes
```

---

### Q11: What is .gitignore and how to use?

**Answer:**
.gitignore file specifies which files Git should ignore.

```bash
# Common patterns
node_modules/      # Ignore folder
*.log              # Ignore all .log files
.env               # Ignore specific file
build/             # Ignore build outputs
!important.log     # Don't ignore this (! negates)
```

**Rules:**
- One pattern per line
- `#` for comments
- `/` at start = match from root
- `/` at end = match directory
- `*` = wildcard
- `**` = match any number of directories
- `!` = negate pattern

---

### Q12: How to undo last commit?

**Answer:**

**Option 1: Keep changes (undo commit, keep staged)**
```bash
git reset --soft HEAD~1
git commit -m "New message"  # Recommit with new message
```

**Option 2: Keep changes unstaged**
```bash
git reset --mixed HEAD~1
# Or just git reset HEAD~1
```

**Option 3: Discard changes**
```bash
git reset --hard HEAD~1
```

**Option 4: Public branch (create new commit undoing)**
```bash
git revert HEAD
```

---

### Q13: What is stash and when to use?

**Answer:**
Stash temporarily saves changes without committing.

```bash
git stash              # Save work in progress
git stash pop          # Apply and delete stash
git stash apply        # Apply but keep stash
git stash list         # View all stashes
```

**When to use:**
- Need to switch branches without committing
- Saving incomplete work
- Cleaning working directory

**Example:**
```bash
# Working on feature-a, need to fix urgent bug
git stash
git switch hotfix-branch
# Fix and commit
git switch feature-a
git stash pop  # Resume work
```

---

### Q14: Explain fast-forward merge vs merge commit.

**Answer:**

**Fast-forward merge:**
```
Before:
main: A - B
          \
feature:   C - D

After:
main: A - B - C - D
```
Simply moves main pointer forward. No merge commit created.

```bash
git merge feature  # Fast-forward if possible
```

**Merge commit:**
```
Before:
main: A - B - E
          \   /
feature:   C - D

After:
main: A - B - E - M (merge commit)
          \   /
feature:   C - D
```
Creates new commit combining branches.

```bash
git merge --no-ff feature  # Force merge commit
```

**Differences:**
- Fast-forward: Linear history, no merge commit
- Merge commit: Shows branch merged, maintains history visibility
- Use `--no-ff` for clear merge records on main branch

---

### Q15: What is HEAD and detached HEAD?

**Answer:**
**HEAD**: Pointer to current commit/branch.

```bash
# Normal: HEAD points to branch
HEAD → main → commit-hash

# Detached HEAD: HEAD points directly to commit
HEAD → commit-hash (not on any branch)
```

**Detached HEAD state:**
```bash
git checkout commit-hash    # Detached HEAD
git checkout tag-name       # Detached HEAD
git switch branch-name      # Normal state again
```

**When it happens:**
- Checking out specific commit
- Checking out tag
- After rebase if something goes wrong

**Problem:**
- Commits made in detached state aren't on any branch
- Can be lost if not careful

**Solution:**
```bash
# Create branch to save commits
git branch save-work
git switch main
```

---

### Q16: How to collaborate using Git?

**Answer:**

**Workflow:**
1. Clone repository
2. Create feature branch
3. Make changes and commits
4. Push to remote
5. Create Pull Request
6. Code review and discussion
7. Merge when approved
8. Delete feature branch

**Commands:**
```bash
# Clone
git clone https://github.com/user/repo.git

# Create feature branch
git switch -c feature-x

# Make changes
git add .
git commit -m "Feature implementation"

# Push
git push -u origin feature-x

# Create PR on GitHub
# Get approval
# Merge PR

# Clean up
git switch main
git pull
git branch -d feature-x
git push origin --delete feature-x
```

---

### Q17: What is a Pull Request (PR)?

**Answer:**
Pull Request is mechanism to request merging changes from one branch to another.

**Purpose:**
- Code review before merging
- Discuss changes
- Ensure quality
- Enable collaboration
- Track who approved

**PR workflow:**
1. Push feature branch
2. Create PR on GitHub/GitLab
3. Add description, title
4. Request reviewers
5. Discuss and address feedback
6. Merge when approved
7. Delete branch

**Good PR practices:**
- Descriptive title and description
- Small focused PRs (easier to review)
- Link related issues
- Follow contribution guidelines
- Address all feedback

---

### Q18: How to handle merge conflicts?

**Answer:**
See "Conflict Resolution" section above for detailed answer.

**Quick summary:**
```bash
git merge feature  # Conflict occurs
git status         # See conflicted files

# Edit files manually, remove conflict markers
# Keep desired code

git add .
git commit  # Complete merge
```

---

### Q19: What is rebase and interactive rebase?

**Answer:**
See "Rebasing" and "Interactive Rebase" sections above for details.

**Quick summary:**
```bash
# Rebase: replay commits on top of another branch
git rebase main

# Interactive rebase: edit commits while rebasing
git rebase -i HEAD~3  # Last 3 commits
# Can pick, reword, squash, fix, drop, etc.
```

---

### Q20: Best practices for Git?

**Answer:**
1. **Clear commit messages**: Describe what and why
2. **Atomic commits**: One feature/fix per commit
3. **Regular pulling**: Keep branch up to date
4. **Meaningful branch names**: Use conventions
5. **Code review**: Always review before merging
6. **Avoid force push on shared branches**
7. **Rebase local commits before pushing**
8. **Keep history clean**
9. **Use .gitignore**: Ignore unnecessary files
10. **Meaningful tags**: Mark releases properly

---

## Git Concepts - Theory & Practice (Basic to Advanced)

### BASIC LEVEL CONCEPTS

#### 1. Repository (Repo)

**Definition:**
A repository is a directory containing your project files and Git's metadata (.git folder). It's the complete history and current state of your project.

**Theory:**
- Central storage for all version control information
- Contains `.git` directory with all commit history
- Can be local or remote

**Structure:**
```
my-project/
├── .git/                    # Git metadata (hidden)
│   ├── objects/            # Stored commits, trees, blobs
│   ├── refs/              # Pointers to commits
│   ├── HEAD               # Current branch reference
│   └── config             # Repository configuration
├── src/                    # Your project files
├── README.md
└── .gitignore
```

**Example:**
```bash
# Initialize repository
mkdir my-project
cd my-project
git init

# Repository created! .git folder now exists
ls -la  # Shows .git folder
```

**Key Points:**
- `.git` folder contains entire project history
- Local repo = everything is on your machine
- Remote repo = hosted on server (GitHub, GitLab)
- Each repository is independent and complete
- Can work without internet after cloning

---

#### 2. Commits

**Definition:**
A commit is a snapshot of your project at a point in time. It represents a set of changes with metadata (author, date, message).

**Theory:**
- Commits form a chain (linked list) of snapshots
- Each commit has unique hash (SHA-1)
- Contains: changes, author, timestamp, message, parent commit(s)
- Immutable (can't change committed data)

**Commit Structure:**
```
Commit Hash: abc123def456...
├── Author: John Doe <john@example.com>
├── Date: Mon Dec 24 10:30:00 2024
├── Message: "Add user authentication feature"
├── Changes: 
│   ├── Added: auth.service.ts (150 lines)
│   ├── Modified: app.module.ts (+5 lines, -3 lines)
│   └── Deleted: old-auth.js
└── Parent: parent-commit-hash (or multiple for merge commits)
```

**Example:**
```bash
# Create a file and commit
echo "Hello World" > hello.txt
git add hello.txt
git commit -m "Add hello.txt file"

# View commit
git log --oneline
# Output: abc1234 Add hello.txt file

# See commit details
git show abc1234
```

**Key Points:**
- Each commit is identified by unique SHA-1 hash
- HEAD points to current commit
- Commits are immutable (create new commits to undo)
- Good commit messages are crucial
- Commits should be logical units of work
- Parent reference creates history chain

---

#### 3. Branches

**Definition:**
A branch is a lightweight pointer to a specific commit. It allows parallel development without affecting other branches.

**Theory:**
```
Visual Branch Model:

main:    A --- B --- C --- D (main branch pointer here)
                      \
feature:               E --- F (feature branch pointer here)

Each branch is just a pointer to a commit
Both can coexist and develop independently
```

- Branches enable isolated development
- Default branch is usually `main` or `master`
- Lightweight (just a reference, not a copy)
- Fast to create and switch
- Merging combines branch changes

**Example:**
```bash
# Create branch (pointer to current commit)
git branch feature-login

# Switch to branch
git checkout feature-login
# Or newer syntax
git switch feature-login

# Make changes on feature branch
echo "function login() {}" > login.js
git add login.js
git commit -m "Add login function"

# Switch back to main
git switch main

# login.js doesn't exist here (still on main's history)
```

**Key Points:**
- Branches are cheap to create
- Each branch has independent history
- Default branch is `main`
- Branch names should be descriptive
- Switching branches updates working directory
- Branches are local until pushed
- Can have multiple branches for features, bugfixes, releases

---

#### 4. Staging Area (Index)

**Definition:**
The staging area is a buffer between working directory and repository. It lets you choose exactly what to commit.

**Theory:**
```
Workflow:
┌─────────────────┐
│ Working Dir     │  (modified files)
└────────┬────────┘
         │ git add
         ▼
┌─────────────────┐
│ Staging Area    │  (changes to be committed)
└────────┬────────┘
         │ git commit
         ▼
┌─────────────────┐
│ Repository      │  (saved in .git)
└─────────────────┘
```

**Example:**
```bash
# Modify multiple files
echo "var x = 1;" > script.js
echo "body { color: red; }" > style.css

# Stage only script.js
git add script.js

# Check status
git status
# Shows: script.js staged, style.css unstaged

# Commit only staged file
git commit -m "Add script"
# Only script.js is committed, style.css remains local

# Commit style.css
git add style.css
git commit -m "Add styling"
```

**Key Points:**
- Allows selective commits
- Use `git add` to stage
- Use `git diff` to see unstaged changes
- Use `git diff --staged` to see staged changes
- Can commit parts of files with `git add -p`
- Essential for clean, organized commits

---

#### 5. HEAD

**Definition:**
HEAD is a pointer indicating the current commit you're on. It's your "you are here" marker.

**Theory:**
```
Normal Case:
HEAD → main branch → commit abc123

Detached HEAD Case:
HEAD → commit abc123 (not on any branch)

After switching:
HEAD → develop branch → commit def456
```

**Example:**
```bash
# HEAD usually points to branch
git log --oneline -1
# abc1234 (HEAD -> main) Add feature

# Checkout specific commit (detached HEAD)
git checkout abc1234
# HEAD is now (detached HEAD)

# Create branch to save work in detached state
git branch save-work

# Normal: HEAD follows branch
git switch main
# HEAD now points to main branch
```

**Key Points:**
- HEAD shows where you are in history
- Usually points to current branch
- Can be in detached state (pointing to commit directly)
- Detached HEAD work can be lost if not saved
- References like HEAD~1, HEAD~2 refer to parent commits

---

### INTERMEDIATE LEVEL CONCEPTS

#### 6. Three-Way Merge

**Definition:**
A merge that combines changes from two branches with different histories.

**Theory:**
```
Before:
main:  A --- B --- C
            \     /
feature:     D --- E

Three-way merge combines:
1. Common ancestor: B (base)
2. Main changes: B → C
3. Feature changes: B → E

Result:
main:  A --- B --- C --- M (merge commit)
            \         /
feature:     D ----- E
```

**Process:**
```
1. Find common ancestor (B)
2. Compare A→B→C (what changed in main)
3. Compare A→B→E (what changed in feature)
4. Combine changes intelligently
5. If conflicts, let user resolve
6. Create merge commit
```

**Example:**
```bash
# Setup
git switch -c feature
echo "feature code" > feature.txt
git add feature.txt
git commit -m "Add feature"

# Meanwhile, main gets updates
git switch main
echo "main update" > main-file.txt
git add main-file.txt
git commit -m "Main update"

# Merge feature into main
git merge feature
# Three-way merge happens:
# - Common ancestor found
# - Changes combined
# - New merge commit created
```

**Key Points:**
- Combines changes from two branches
- Creates merge commit (two parents)
- Preserves both branch histories
- Git automatically merges non-conflicting changes
- User resolves conflicts
- Results in non-linear history

---

#### 7. Fast-Forward Merge

**Definition:**
A merge where the target branch simply advances to the source branch's tip without creating a merge commit.

**Theory:**
```
Before:
main:  A --- B
            \
feature:     C --- D

Fast-forward merge:
main:  A --- B --- C --- D
feature:              (same as main now)

No merge commit created, just pointer moves
```

**When It Happens:**
- Target branch (main) hasn't changed since feature was created
- Main is direct ancestor of feature
- Git can simply move the pointer forward

**Example:**
```bash
# Setup: feature branch only, main unchanged
git switch -c feature
echo "code" > file.txt
git add file.txt
git commit -m "Add code"

# Switch to main (no new commits here)
git switch main

# Merge feature
git merge feature
# Result: Fast-forward! main pointer moves to feature's tip

# No merge commit created, linear history maintained
```

**vs Non-Fast-Forward:**
```bash
# Force merge commit even if FF possible
git merge --no-ff feature
# Creates merge commit for tracking

# Check merge commits
git log --oneline --all
```

**Key Points:**
- Happens when main hasn't changed
- Simplest type of merge
- Results in linear history
- No merge commit needed
- Use `--no-ff` to force merge commit for tracking
- Common in feature branch workflows

---

#### 8. Conflict & Resolution

**Definition:**
A conflict occurs when Git can't automatically merge changes because the same lines were modified differently in both branches.

**Theory:**
```
Branch A modifies line 5: "Hello World"
Branch B modifies line 5: "Goodbye World"

Git can't decide which to keep
User must manually resolve
```

**Conflict Markers:**
```
<<<<<<< HEAD
Hello World     (current branch version)
=======
Goodbye World   (incoming branch version)
>>>>>>> feature-branch
```

**Resolution Steps:**
```
1. Identify conflict: git status shows "both modified"
2. Open file and find conflict markers
3. Choose version: keep ours, theirs, or combine
4. Remove conflict markers
5. Stage file: git add
6. Commit: git commit (merging message auto-added)
```

**Example:**
```bash
# Create conflict
git switch -c feature
echo "Feature version" > file.txt
git commit -am "Feature change"

git switch main
echo "Main version" > file.txt
git commit -am "Main change"

# Try to merge
git merge feature
# Conflict! File has both versions

# View conflict
cat file.txt
# <<<<<<< HEAD
# Main version
# =======
# Feature version
# >>>>>>> feature

# Resolve: keep desired version
echo "Final version" > file.txt

# Mark as resolved
git add file.txt
git commit -m "Resolve merge conflict"
```

**Key Points:**
- Conflicts are common in collaborative development
- Only content conflicts cause issues (Git handles structural changes)
- Must be resolved before committing
- Merge tools help with visual conflict resolution
- Communication with team prevents conflicts
- Practice resolving conflicts builds confidence

---

#### 9. Rebase vs Merge

**Definition:**
Two different ways to integrate changes from one branch into another.

**Theory:**

**Merge:**
```
Before:
main:  A --- B --- C
            \
feature:     D --- E

After merge:
main:  A --- B --- C --- M (merge commit)
            \         /
feature:     D ----- E
```
- Non-linear history
- Preserves branch history
- Shows actual development flow
- Safe for shared branches

**Rebase:**
```
Before:
main:  A --- B --- C
            \
feature:     D --- E

After rebase:
main:  A --- B --- C
                    \
feature:             D' --- E'
```
- Linear history
- Rewrites history (D' and E' are new commits)
- Cleaner, easier to read
- Dangerous on shared branches

**Example:**
```bash
# Merge approach
git switch main
git merge feature
# Creates merge commit

# Rebase approach
git switch feature
git rebase main
# Replays feature's commits on main's tip
# Then merge with main
git switch main
git merge feature  # Now FF merge
```

**When to Use:**

```bash
# Use merge:
# - For public branches
# - Team code
# - Important features
git merge feature

# Use rebase:
# - Local branches
# - Before pushing
# - Feature development
git rebase main
```

**Key Points:**
- Merge: safer, preserves history
- Rebase: cleaner, linear history
- Don't rebase shared/pushed branches
- Rebase locally, merge publicly
- Interactive rebase edits commits
- Both valid, choose based on context

---

#### 10. Remote Tracking Branches

**Definition:**
Local references to remote branches that track what's on the server.

**Theory:**
```
Local branches:
main
feature-x
develop

Remote tracking branches (copies of remote):
origin/main
origin/feature-x
origin/develop

They're separate from local branches
Updated with git fetch
```

**Relationship:**
```
Local main ────→ can push to ────→ origin/main (remote)
                                        ↑
                                   git fetch
```

**Example:**
```bash
# Clone creates tracking
git clone https://github.com/user/repo.git
# Sets up origin/main tracking local main

# View all branches
git branch -a
# Shows local and remote-tracking branches

# Check upstream
git branch -vv
# Shows which remote branches are tracked

# Fetch updates remote-tracking branches
git fetch origin
# Updates origin/main, origin/feature, etc.

# Local main is separate from origin/main
git log main..origin/main
# Shows commits on origin/main not in local main

# Pull = fetch + merge
git pull origin main
# Merges origin/main into local main
```

**Key Points:**
- Remote-tracking branches are local copies
- Format: `remote-name/branch-name` (e.g., `origin/main`)
- Updated with `git fetch`
- Local branches can track remotes
- Allows working offline and comparing with remote
- Essential for understanding distributed nature of Git

---

### ADVANCED LEVEL CONCEPTS

#### 11. Interactive Rebase

**Definition:**
Interactive rebase allows editing commits while replaying them, enabling commit history cleaning.

**Theory:**
```
Before (messy history):
A: Initial commit
B: Fix typo in A
C: Add feature
D: Fix typo in C
E: Update documentation

After interactive rebase:
A: Initial commit
C: Add feature (with B squashed in)
E: Update documentation (with D squashed in)
```

**Process:**
```
1. Start interactive rebase: git rebase -i HEAD~5
2. Editor opens with commit list
3. Choose action for each commit:
   - pick: use commit
   - reword: change message
   - squash: combine with previous
   - fixup: combine, discard message
   - drop: remove commit
4. Resolve any conflicts
5. Rebased history applied
```

**Example:**
```bash
# View last 3 commits
git log --oneline -3
# Fix typo in feature
# Add new feature
# Initial commit

# Start interactive rebase
git rebase -i HEAD~3

# Editor opens:
# pick abc1234 Initial commit
# pick def5678 Add new feature
# pick ghi9012 Fix typo in feature

# Change to:
# pick abc1234 Initial commit
# pick def5678 Add new feature
# fixup ghi9012 Fix typo in feature
# (fixup: combine with previous commit)

# Result:
# pick abc1234 Initial commit
# pick def5678 Add new feature (with typo fix)
```

**Use Cases:**
```bash
# Reword commit message
git rebase -i HEAD~5
# Change "pick" to "reword" for that commit
# Editor opens for new message

# Squash multiple commits
git rebase -i HEAD~5
# Change later commits to "squash"
# Combines into earlier commit

# Drop/remove commits
git rebase -i HEAD~5
# Change to "drop" to remove commit

# Reorder commits
git rebase -i HEAD~5
# Cut and paste lines to reorder

# Split commit
git rebase -i HEAD~5
# Change to "edit"
# git reset HEAD~1 (undo commit)
# git add part1 && git commit
# git add part2 && git commit
# git rebase --continue
```

**Key Points:**
- Powerful for history cleanup
- Rewrites history (don't use on shared branches)
- Learn it to create professional-looking histories
- Great for feature branches before pushing
- Combining commits improves readability
- Resolving conflicts during rebase is common

---

#### 12. Cherry-Pick

**Definition:**
Apply specific commits from one branch to another without merging the entire branch.

**Theory:**
```
Scenario: Bug fix on feature branch, but main needs it now

main:   A --- B --- C
             \
feature:      D(fix) --- E

Cherry-pick D to main:
main:   A --- B --- C --- D' (new commit with same changes)
             \
feature:      D(fix) --- E

Result: D' has same changes as D, but different hash
```

**Use Cases:**
```
1. Apply bugfix from one branch to another
2. Select specific commits to merge
3. Avoid merging entire branch
4. Hotfix application across branches
5. Copy commits between branches
```

**Example:**
```bash
# Bug discovered on feature branch
git switch feature
# Find bugfix commit
git log --oneline
# abc1234 Fix critical bug

# Switch to main and apply it
git switch main
git cherry-pick abc1234
# Commit abc1234's changes applied to main
# Creates new commit (different hash)

# Cherry-pick range
git cherry-pick abc1234..def5678
# Applies abc1234 through def5678

# Cherry-pick multiple
git cherry-pick abc1234 def5678 ghi9012
# Applies three specific commits

# Resolve conflicts
git cherry-pick abc1234
# Conflict! Resolve manually
git add .
git cherry-pick --continue

# Abort if too complex
git cherry-pick --abort
```

**Key Points:**
- Different from merge (creates new commits)
- Useful for selective change application
- Original commit remains on source branch
- Results in code duplication in history (intentional)
- Good for hotfixes and selective backporting
- Can cause merge conflicts

---

#### 13. Reflog (Reference Logs)

**Definition:**
Reference logs track changes to HEAD and branch references, enabling recovery of lost commits.

**Theory:**
```
Every time HEAD changes, reflog records it:

abc1234 HEAD@{0}: checkout: switching to main
def5678 HEAD@{1}: commit: Add feature
ghi9012 HEAD@{2}: rebase -i: pick
jkl3456 HEAD@{3}: checkout: switching to feature
```

**Recovery Example:**
```bash
# Accidentally lost commits with reset
git reset --hard wrong-commit
# Now realize you made a mistake

# Check reflog
git reflog
# Shows previous HEAD positions

# Find lost commit
git show abc1234

# Create branch to recover
git branch recovered-work abc1234

# Back to safety!
```

**Key Points:**
- Reflog is your safety net
- Local only (not shared with others)
- Kept for about 30 days by default
- Essential for undoing major mistakes
- Shows exact history of changes
- Practice with git reflog improves confidence

---

#### 14. Signed Commits & Tags

**Definition:**
Cryptographic signing of commits and tags ensures authenticity and integrity.

**Theory:**
```
Unsigned commit:
Author: John Doe
Message: Add feature

Signed commit (with GPG):
Author: John Doe [GPG Key: ABCD1234]
Signature: -----BEGIN PGP SIGNATURE-----
           ...
           -----END PGP SIGNATURE-----
```

**Verification:**
- Proves you made the commit
- Prevents impersonation
- Important for releases
- Required by some organizations

**Example:**
```bash
# Generate GPG key (setup once)
gpg --generate-key

# Sign commit
git commit -S -m "Signed commit"

# Sign tag
git tag -s v1.0.0 -m "Release 1.0.0"

# Verify signature
git verify-commit abc1234
git verify-tag v1.0.0

# Check commit is signed
git log --show-signature
```

**Key Points:**
- Proves commit authenticity
- Uses GPG encryption
- Setup required once
- Important for open source
- Branches of signed commits are trusted
- Enterprise and security critical projects require this

---

#### 15. Submodules & Subtrees

**Definition:**
Ways to include other Git repositories within your repository.

**Theory:**

**Submodules:**
```
Parent repo contains reference to child repo
Child repo is separate repository
Updates to child tracked separately
```

**Subtrees:**
```
Child repo fully merged into parent
Child files become part of parent
Easier to use, harder to maintain separate history
```

**Submodules Example:**
```bash
# Add submodule
git submodule add https://github.com/user/lib.git libs/mylib

# Clone with submodules
git clone --recursive https://github.com/user/main.git

# Update submodule
cd libs/mylib
git pull origin main

# Commit submodule update
git add libs/mylib
git commit -m "Update mylib to latest"
```

**Subtrees Example:**
```bash
# Add subtree
git subtree add --prefix=libs/mylib https://github.com/user/lib.git main

# Update subtree
git subtree pull --prefix=libs/mylib https://github.com/user/lib.git main

# Contribute back
git subtree push --prefix=libs/mylib https://github.com/user/lib.git main
```

**Key Points:**
- Submodules: maintain separation
- Subtrees: easier to use, harder to maintain
- Choose based on needs
- Useful for monorepos
- Version dependencies

---

#### 16. Hooks

**Definition:**
Scripts that run automatically at specific Git events.

**Theory:**
```
Git Workflow with Hooks:

git add
   ↓
pre-commit hook (lint, format)
   ↓
git commit
   ↓
commit-msg hook (validate message)
   ↓
post-commit hook (run tests)
   ↓
git push
   ↓
pre-push hook (final checks)
```

**Common Hooks:**
```
Client-side:
- pre-commit: before commit (lint, format)
- commit-msg: validate message
- pre-push: before push (tests)
- post-checkout: after switching branches

Server-side:
- pre-receive: before accepting push
- post-receive: after push received
- update: validate refs
```

**Example:**
```bash
# Create pre-commit hook
cat > .git/hooks/pre-commit << 'EOF'
#!/bin/bash
npm run lint
if [ $? -ne 0 ]; then
  echo "Linting failed, commit aborted"
  exit 1
fi
EOF

chmod +x .git/hooks/pre-commit

# Hook runs automatically before commit
# If script fails, commit is prevented
```

**Use Cases:**
```
- Enforce code standards
- Prevent commits with secrets
- Run tests before push
- Format code automatically
- Validate commit messages
- Enforce branch policies
```

**Key Points:**
- Automate quality checks
- Prevent bad commits
- Enforce standards
- Can be local or server-side
- Tools like Husky simplify setup
- Great for team collaboration

---

#### 17. Distributed Workflows

**Definition:**
Patterns for coordinating work across multiple developers and repositories.

**Theory:**

**Centralized Workflow:**
```
All developers push to single remote
Simple, like SVN
Good for small teams

main → origin/main (everyone)
```

**Feature Branch Workflow:**
```
Each feature gets own branch
Merged via PR when done
Enforces code review
Standard in industry

feature-x → PR → review → merge to main
```

**Gitflow:**
```
Multiple long-running branches
main, develop, release, hotfix
Scheduled releases
Formal process

develop → feature branches
develop → release branches → main
main → hotfix branches → develop + main
```

**Forking Workflow:**
```
Each contributor forks repo
Contributes via PR
Original maintainer reviews
Used in open source

your-fork → PR → upstream repo
```

**Example Gitflow:**
```bash
# Start feature
git flow feature start add-auth
# Creates feature/add-auth from develop

# Finish feature
git flow feature finish add-auth
# Merges to develop, deletes branch

# Prepare release
git flow release start v1.0.0
# creates release/v1.0.0

# Finish release
git flow release finish v1.0.0
# merges to main + develop, creates tag

# Hotfix
git flow hotfix start v1.0.1
# creates hotfix/v1.0.1
```

**Key Points:**
- Choose workflow based on team/project
- Consistent workflow improves collaboration
- Gitflow good for scheduled releases
- Feature branches essential for code review
- Forking good for open source
- Clear workflow prevents chaos

---

#### 18. Stash Advanced Usage

**Definition:**
Advanced stashing techniques for complex scenarios.

**Theory:**
```
Normal stash: saves all changes

Advanced stashing:
- Stash specific files
- Stash specific hunks
- Multiple stashes
- Stash from branch to branch
- Create branch from stash
```

**Example:**
```bash
# Stash only specific file
git stash push file1.txt
# Only file1.txt stashed, others remain

# Stash specific hunks
git stash push -p
# Interactive selection of hunks

# Stash untracked files
git stash -u
# Includes new files

# Create branch from stash
git stash branch feature-x
# Creates branch and applies stash
# Good for partial work

# Apply stash to different branch
git stash apply
# Can apply on any branch

# Multiple stashes
git stash list
# Shows all stashes
git stash apply stash@{2}
# Apply older stash
```

**Key Points:**
- More flexible than basic stash
- Allows selective stashing
- Can stash on one branch, apply on another
- Essential for context switching
- Better than losing work
- Combine with branches for complex workflows

---

#### 19. Filter Branch (History Rewriting)

**Definition:**
Advanced technique to modify repository history, removing sensitive data or restructuring.

**Theory:**
```
Example: Remove password file from history

Before:
Commit 1: Add app.js
Commit 2: Add config with password
Commit 3: Add tests

After:
Commit 1: Add app.js
Commit 2: Add config without password
Commit 3: Add tests
```

**Use Cases:**
```
- Remove committed secrets
- Remove large files
- Restructure directories
- Combine repositories
- Clean up history
```

**Example (Dangerous!):**
```bash
# Remove file from all history
git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
# Rewrites all commits

# Force push (required after filter-branch)
git push --force

# Better: use BFG Repo-Cleaner
bfg --delete-files passwords.txt
bfg --replace-text passwords.txt
```

**Key Points:**
- Powerful but dangerous
- Rewrites all history
- Affects all collaborators
- Use with extreme caution
- Backup first
- Notify team after using
- Modern alternative: BFG Repo-Cleaner

---

#### 20. Performance Optimization

**Definition:**
Techniques for optimizing Git performance in large repositories.

**Theory:**
```
Large Repo Challenges:
- Slow clones
- Slow fetches
- Large storage
- Shallow history ok locally, not for all
```

**Techniques:**
```bash
# Shallow clone (limited history)
git clone --depth 1 url
# Faster but limited history

# Partial clone (download objects on demand)
git clone --filter=blob:none url
# Only gets commits/trees, fetches blobs on need

# Sparse checkout (limited files)
git clone --sparse url
# Only checks out certain files

# Shallow fetch
git fetch --depth 1

# Garbage collection
git gc
# Optimizes repository size

# Monitoring
git count-objects
# Shows storage statistics
```

**For Large Teams:**
```
- Git LFS for large files
- Monorepo tools (Monorepo)
- Shallow clones by default
- Sparse checkout
- Regular garbage collection
```

**Key Points:**
- Important as project grows
- Shallow clones for most developers
- Full clone for maintainers
- Git LFS for binary files
- Regular maintenance keeps performance good
- Balance between speed and functionality

---

---

## Git Interview Questions & Answers

### Basic Level Questions

#### Q1: What is Git and why is it important?

**Answer:**
Git is a **distributed version control system** that tracks changes in files and allows multiple developers to collaborate.

**Key Points:**
- **Version Control**: Records all changes with history
- **Distributed**: Every developer has full repository copy
- **Branching**: Easy parallel development
- **Merging**: Intelligent change combination
- **Speed**: Fast local operations
- **Industry Standard**: Used by 93% of professionals

**Why Important:**
- Prevents code loss (complete history)
- Enables rollback if needed
- Facilitates code review and collaboration
- Allows multiple developers on same project
- Creates audit trail (who changed what, when)
- Essential for professional development

---

#### Q2: Explain the three states of Git.

**Answer:**
Git has three states where files can exist:

1. **Modified** - File changed but not staged
   ```bash
   git status  # Shows modified files
   ```

2. **Staged** - File marked for commit
   ```bash
   git add file.txt  # Moves to staged
   git diff --staged  # Shows staged changes
   ```

3. **Committed** - Changes saved in repository
   ```bash
   git commit -m "message"  # Moves to committed
   git log  # Shows committed changes
   ```

**Workflow:**
```
Working Dir → git add → Staging Area → git commit → Repository
(Modified)                (Staged)                    (Committed)
```

**Example:**
```bash
# 1. File is modified
echo "code" > file.txt
git status  # Shows: modified file.txt

# 2. Stage the file
git add file.txt
git status  # Shows: staged file.txt

# 3. Commit
git commit -m "Add code"
git status  # Shows: nothing to commit
```

---

#### Q3: What's the difference between Git and GitHub?

**Answer:**

| Aspect | Git | GitHub |
|--------|-----|--------|
| Type | Version Control System | Cloud Platform |
| Function | Tracks code changes | Hosts repositories |
| Installation | Local software | Web-based service |
| Cost | Free, open source | Free + Paid tiers |
| Features | Basic VCS | VCS + Collaboration |

**Git:**
- Local version control software
- Command-line tool
- Works offline
- Can use with any server

**GitHub:**
- Web platform hosting Git repos
- Provides collaboration features
- Pull requests, issue tracking
- Social features (profiles, followers)
- Free and paid plans

**Other Similar Platforms:**
- GitLab
- Bitbucket
- Gitea (self-hosted)

---

#### Q4: What is a commit?

**Answer:**
A commit is a **snapshot of your project** at a specific point in time.

**Commit Structure:**
```
commit abc123def456
Author: John Doe <john@example.com>
Date: Mon Dec 24 10:30:00 2024

Add user authentication feature

Changes:
├── Added: auth.service.ts (150 lines)
├── Modified: app.module.ts (+5, -3)
└── Deleted: old-auth.js
```

**Key Characteristics:**
- **Unique Hash**: SHA-1 identifier (abc123...)
- **Author Info**: Name and email
- **Timestamp**: When commit was made
- **Message**: Description of changes
- **Parent Reference**: Points to previous commit
- **Immutable**: Can't change committed data

**Example:**
```bash
git commit -m "Add authentication"
# Creates commit with staged changes

git log --oneline
# Shows commit hash and message

git show abc123
# Shows full commit details
```

---

#### Q5: What are branches?

**Answer:**
Branches are **lightweight pointers to specific commits** that allow parallel development.

**Key Concepts:**
```
main:    A --- B --- C --- D
                      \
feature:               E --- F
```

Each branch is independent, allowing:
- Isolated feature development
- Parallel work without conflicts
- Easy merging when ready
- Safe experimentation

**Example:**
```bash
# Create branch
git branch feature-login

# Switch to branch
git switch feature-login

# Make changes
echo "login code" > login.js
git add login.js
git commit -m "Add login"

# Switch back to main
git switch main

# login.js doesn't exist on main
```

**Key Points:**
- Branches are cheap to create
- Each has independent history
- Default is `main` or `master`
- Switch updates working directory
- Local until pushed
- Essential for feature isolation

---

#### Q6: Explain fast-forward merge.

**Answer:**
A **fast-forward merge** is when Git simply moves the pointer forward without creating a merge commit.

**Condition:**
Target branch hasn't changed since source branch was created.

**Example:**
```
Before:
main:  A --- B
            \
feature:     C --- D

After fast-forward:
main:  A --- B --- C --- D
feature:              (same as main)
```

**Code Example:**
```bash
# Create feature from main (no main changes)
git switch -c feature
echo "code" > feature.txt
git add feature.txt
git commit -m "Add feature"

# Main hasn't changed
git switch main

# Merge
git merge feature
# Result: Fast-forward! Linear history

# To force merge commit:
git merge --no-ff feature
# Creates merge commit even if FF possible
```

**Key Points:**
- Happens when base branch unchanged
- Simplest merge type
- Results in linear history
- No merge commit needed
- Use `--no-ff` to force merge commit
- Common in feature branch workflows

---

#### Q7: What is a merge conflict?

**Answer:**
A **conflict** occurs when Git can't automatically merge because same lines were modified differently.

**Conflict Markers:**
```
<<<<<<< HEAD
Keep this (current branch)
=======
Or this (incoming branch)
>>>>>>> feature-branch
```

**Resolution Steps:**
```
1. Identify: git status shows conflicts
2. Edit: Open file and choose version
3. Remove markers: Clean up conflict markers
4. Stage: git add file
5. Commit: git commit (auto-merges message)
```

**Example:**
```bash
# Create conflict
git switch -c feature
echo "Feature version" > file.txt
git commit -am "Feature change"

git switch main
echo "Main version" > file.txt
git commit -am "Main change"

# Try merge
git merge feature
# CONFLICT! Can't auto-merge

# View conflicts
cat file.txt
# <<<<<<< HEAD
# Main version
# =======
# Feature version
# >>>>>>> feature

# Resolve manually
echo "Final version" > file.txt

# Mark resolved
git add file.txt
git commit
```

**Prevention:**
- Communication with team
- Small focused changes
- Frequent pulling
- Code review before merging

---

### Intermediate Level Questions

#### Q8: Explain rebase and when to use it.

**Answer:**
**Rebase** replays commits from one branch onto another, creating linear history.

**vs Merge:**

**Merge:**
```
Before:
main:  A --- B --- C
            \
feature:     D --- E

After:
main:  A --- B --- C --- M (merge commit)
            \         /
feature:     D ----- E
```
- Non-linear
- Preserves history
- Safe for shared

**Rebase:**
```
Before:
main:  A --- B --- C
            \
feature:     D --- E

After:
main:  A --- B --- C
                    \
feature:             D' --- E'
```
- Linear history
- Rewrites history
- Dangerous on shared

**When to Use:**

```bash
# Use merge for:
# - Public branches
# - Shared work
# - Important features
git merge feature

# Use rebase for:
# - Local branches
# - Before pushing
# - Feature work
git rebase main
```

**Example:**
```bash
# Rebase approach
git switch feature
git rebase main
# Replays feature commits on main

git switch main
git merge feature  # FF merge now
```

**Key Points:**
- Don't rebase shared branches
- Rebase locally, merge publicly
- Interactive rebase edits commits
- Both valid, context-dependent

---

#### Q9: What is cherry-pick?

**Answer:**
**Cherry-pick** applies specific commits from one branch to another without merging entire branch.

**Use Cases:**
```
1. Apply bugfix from feature to main
2. Select specific commits
3. Avoid full merge
4. Hotfix application
5. Backporting changes
```

**Example:**
```
main:   A --- B --- C
             \
feature:      D(fix) --- E

Cherry-pick D:
main:   A --- B --- C --- D' (new commit)
             \
feature:      D(fix) --- E
```

**Code Example:**
```bash
# Find commit to apply
git switch feature
git log --oneline
# abc1234 Fix critical bug

# Apply to main
git switch main
git cherry-pick abc1234
# Creates new commit with same changes

# Multiple commits
git cherry-pick abc1234 def5678 ghi9012

# Range
git cherry-pick abc1234..def5678

# Resolve conflicts
git cherry-pick abc1234
# Conflict! Resolve
git add .
git cherry-pick --continue

# Abort
git cherry-pick --abort
```

**Key Points:**
- Creates new commits (different hash)
- Original remains on source branch
- Results in code duplication (intentional)
- Good for selective backporting
- Can cause merge conflicts

---

#### Q10: What is the difference between git pull and git fetch?

**Answer:**

**git fetch:**
- Downloads changes from remote
- Updates remote-tracking branches
- Doesn't merge or modify working directory
- Safe to review before merging

**git pull:**
- Fetch + Merge
- Downloads and applies changes
- Updates working directory
- Automatic merge (can cause conflicts)

**Comparison:**
```
git fetch origin
Result: origin/main updated locally
        Local main unchanged
        Working dir unchanged

git pull origin main
Result: origin/main fetched
        Merged into local main
        Working dir updated
```

**Example:**
```bash
# Fetch only
git fetch origin
# Check what changed
git diff main origin/main
# Merge manually
git merge origin/main

# Pull (fetch + merge)
git pull origin main
# Automatically merges

# Pull with rebase
git pull --rebase origin main
# Rebases instead of merges
```

**When to Use:**
```bash
# Use fetch:
# - Review before merging
# - Compare branches
# - Safe exploration
git fetch origin

# Use pull:
# - Quick update
# - CI/CD pipelines
# - Trust remote
git pull origin main
```

---

#### Q11: How do you undo changes in Git?

**Answer:**
Multiple ways depending on what you want to undo:

**1. Before Staging (Discard Changes)**
```bash
git restore filename.txt
# Or
git checkout -- filename.txt
```

**2. After Staging (Unstage)**
```bash
git restore --staged filename.txt
# Or
git reset HEAD filename.txt
```

**3. After Committing (Soft Reset)**
```bash
git reset --soft HEAD~1
# Undo commit, keep changes staged

git reset --mixed HEAD~1  # default
# Undo commit, keep changes unstaged

git reset --hard HEAD~1
# Undo commit, discard changes
```

**4. Public Branches (Revert)**
```bash
git revert commit-hash
# Creates new commit undoing changes
# Preserves history
```

**5. Lost Commits (Reflog)**
```bash
git reflog
# Shows previous HEAD positions
git show abc1234
# View lost commit
git branch recovery abc1234
# Recover branch
```

**Example:**
```bash
# Accidental change
git status  # Shows modified file

# Undo
git restore file.txt

# Staged wrong file
git status  # Shows staged file

# Unstage
git restore --staged file.txt

# Bad commit
git reset --soft HEAD~1
# Keep changes, retry commit

# Public branch mistake
git revert abc1234
# Undoes with new commit
```

**Key Points:**
- `restore` for working directory
- `reset` for commits (destructive)
- `revert` for shared branches (safe)
- `reflog` for recovery
- Always use backup for important changes

---

#### Q12: What is a remote and how do you work with them?

**Answer:**
A **remote** is a reference to repository hosted on server (like GitHub).

**Common Operations:**

```bash
# Add remote
git remote add origin https://github.com/user/repo.git

# List remotes
git remote
# Shows: origin, upstream, etc.

git remote -v
# Shows URLs

# Show remote details
git remote show origin
# URL, branches, tracking info

# Change remote URL
git remote set-url origin new-url

# Remove remote
git remote remove origin

# Add multiple URLs
git remote set-url origin --add https://github.com/user2/repo.git
```

**Pushing:**
```bash
# Push current branch
git push

# Push to specific remote
git push origin main

# Create remote branch
git push -u origin feature
# Sets upstream tracking

# Force push (dangerous!)
git push --force-with-lease
# Safer than --force

# Delete remote branch
git push origin --delete feature
# Or
git push origin :feature
```

**Pulling:**
```bash
# Pull from remote
git pull origin main

# Pull all branches
git pull --all

# Fetch without merge
git fetch origin
```

**Key Points:**
- Default remote is `origin`
- Can have multiple remotes
- Upstream tracking important
- Force push dangerous on shared
- Communicate before force push

---

### Advanced Level Questions

#### Q13: Explain interactive rebase.

**Answer:**
**Interactive rebase** allows editing commits while replaying them, enabling history cleanup.

**Process:**
```
1. Start: git rebase -i HEAD~N
2. Editor opens with commit list
3. Choose action per commit
4. Resolve conflicts if needed
5. History rewritten
```

**Commands:**
```
pick   : Use commit
reword : Change message
squash : Combine with previous
fixup  : Combine, discard message
drop   : Remove commit
edit   : Stop for amending
exec   : Run shell command
```

**Example:**
```bash
# View last 3 commits
git log --oneline -3
# abc1234 Initial commit
# def5678 Add feature
# ghi9012 Fix typo in feature

# Interactive rebase
git rebase -i HEAD~3

# Editor:
# pick abc1234 Initial commit
# pick def5678 Add feature
# squash ghi9012 Fix typo

# Result: Typo fix combined with feature

# Reword message
# pick abc1234 Initial commit
# reword def5678 Add feature
# (editor opens for new message)
```

**Common Use Cases:**
```bash
# Squash commits before pushing
git rebase -i origin/main
# Combine messy commits

# Reorder commits
# Cut/paste lines in editor

# Delete commits
# Change to "drop"

# Split commit
# Change to "edit"
# git reset HEAD~1
# git add part1 && git commit
# git add part2 && git commit
# git rebase --continue
```

**Key Points:**
- Powerful for history cleanup
- Rewrites history (don't use on shared)
- Great for feature branches
- Learn for professional histories
- Always practice locally first

---

#### Q14: What are hooks and how do they work?

**Answer:**
**Hooks** are scripts that run automatically at Git events.

**Common Hooks:**

**Client-Side:**
```
pre-commit    : Before commit (lint, format)
commit-msg    : Validate message
pre-push      : Before push (tests)
post-checkout : After branch switch
```

**Server-Side:**
```
pre-receive   : Before accepting push
post-receive  : After push received
update        : Validate refs
```

**Workflow:**
```
git add
  ↓
pre-commit (lint, tests)
  ↓
git commit
  ↓
commit-msg (validate)
  ↓
git push
  ↓
pre-push (final checks)
```

**Example:**
```bash
# Create pre-commit hook
cat > .git/hooks/pre-commit << 'EOF'
#!/bin/bash
npm run lint
if [ $? -ne 0 ]; then
  echo "Linting failed, commit aborted"
  exit 1
fi
EOF

chmod +x .git/hooks/pre-commit

# Hook runs automatically
# If fails, commit prevented
```

**Use Cases:**
```
- Enforce code standards
- Prevent secrets in commits
- Run tests before push
- Format code automatically
- Validate commit messages
- Enforce branch policies
```

**Tools:**
```
- Husky: Simplify hook setup
- Commitizen: Validate messages
- lint-staged: Run linters
- pre-commit: Framework
```

**Key Points:**
- Local and server-side variants
- Automate quality checks
- Prevent bad commits
- Tools simplify setup
- Great for team standards

---

#### Q15: Explain Gitflow workflow.

**Answer:**
**Gitflow** is a branching model using multiple long-running branches for structured releases.

**Branches:**
```
main (production-ready)
  ↑ (releases, hotfixes)
  
develop (development)
  ↑ (features)
  
feature/ (features)
release/ (release prep)
hotfix/  (urgent fixes)
```

**Workflow:**
```
1. Feature: develop → feature/feature-name → develop
2. Release: develop → release/v1.0.0 → main + develop
3. Hotfix: main → hotfix/v1.0.1 → main + develop
```

**Example:**
```bash
# Initialize
git flow init

# Start feature
git flow feature start add-auth
# Creates feature/add-auth from develop

# Work on feature
echo "auth code" > auth.ts
git add auth.ts
git commit -m "Add authentication"

# Finish feature
git flow feature finish add-auth
# Merges to develop, deletes branch

# Prepare release
git flow release start v1.0.0
# From develop, creates release/v1.0.0

# Release changes
echo "version 1.0.0" > version.txt
git commit -am "Release v1.0.0"

# Finish release
git flow release finish v1.0.0
# Merges to main + develop, creates tag

# Hotfix
git flow hotfix start v1.0.1
# From main, creates hotfix/v1.0.1

# Fix bug
echo "bug fix" > bug.ts
git commit -am "Fix critical bug"

# Finish hotfix
git flow hotfix finish v1.0.1
# Merges to main + develop
```

**Advantages:**
- Scheduled releases
- Parallel feature development
- Hotfix separation
- Clear structure
- Good documentation

**Disadvantages:**
- Complex for small teams
- Multiple branches to track
- Overkill for CI/CD

**Key Points:**
- Formal release process
- Good for products
- Less for continuous deployment
- Learn for enterprise projects

---

#### Q16: What is the reflog and how to recover lost commits?

**Answer:**
**Reflog (reference logs)** tracks changes to HEAD and branch references, enabling recovery.

**How It Works:**
```
Every time HEAD moves, reflog records it:

abc1234 HEAD@{0}: checkout: switching to main
def5678 HEAD@{1}: commit: Add feature
ghi9012 HEAD@{2}: rebase -i: pick
jkl3456 HEAD@{3}: checkout: switching to feature
```

**Recovery Example:**
```bash
# Accidentally reset
git reset --hard wrong-commit
# Lost commits!

# Check reflog
git reflog
# Shows previous HEAD positions

# Find lost commit
git show abc1234
# Verify it's the right one

# Recover
git branch recovered-work abc1234
# Creates branch from lost commit

# Back to safety!
git switch recovered-work
```

**Advanced Recovery:**
```bash
# View specific branch reflog
git reflog main
# Shows main's history

# With dates
git reflog --all --decorate

# Find specific action
git reflog | grep "commit"
# Shows commit operations

# Recover specific commit
git show reflog-entry
# View what was at that point

# Create branch from reflog
git branch save-work reflog-entry
```

**Key Points:**
- Reflog is safety net
- Local only (not shared)
- Kept ~30 days by default
- Essential for major mistakes
- Shows exact history
- Practice increases confidence

---

#### Q17: Explain signed commits and why they matter.

**Answer:**
**Signed commits** use GPG to cryptographically sign, proving authenticity.

**Benefits:**
```
- Proves you made the commit
- Prevents impersonation
- Important for releases
- Required by some orgs
- Shows verified badge on GitHub
```

**Setup:**
```bash
# Generate GPG key (once)
gpg --generate-key
# Generates new key pair

# Configure Git
git config --global user.signingkey ABC123
# Sets key for signing

# Or auto-sign all commits
git config --global commit.gpgsign true
```

**Usage:**
```bash
# Sign commit
git commit -S -m "Signed commit"

# Sign tag
git tag -s v1.0.0 -m "Release"

# Verify signature
git verify-commit abc1234
git verify-tag v1.0.0

# View signed commits
git log --show-signature

# Check commit is signed
git log --pretty=format:"%h %G? %s"
# G = good, B = bad, U = untrusted, N = no signature
```

**Example:**
```bash
# Make signed commit
git commit -S -m "Security: Add encryption"

# Push signed commits
git push origin main

# On GitHub: Shows "Verified" badge

# Verify before merging
git verify-commit origin/main~5
```

**Key Points:**
- Uses GPG encryption
- Setup required once
- Important for open source
- Critical for security
- Enterprise requirement
- Prevents impersonation

---

#### Q18: What is the difference between merge and rebase in terms of history?

**Answer:**

**Merge - Non-Linear History:**
```
Before:
main:  A --- B --- C
            \
feature:     D --- E

After:
main:  A --- B --- C --- M (merge commit)
            \         /
feature:     D ----- E

Graph shows merge happened
History preserved
Shows actual flow
```

**Rebase - Linear History:**
```
Before:
main:  A --- B --- C
            \
feature:     D --- E

After:
main:  A --- B --- C
                    \
feature:             D' --- E'

Clean line
History rewritten
Original commits gone
```

**History Visibility:**
```bash
# Merge history
git log --oneline --graph
# Shows branching and merging
# Visual representation of development

# Rebase history
git log --oneline
# Clean linear line
# Harder to see feature boundaries
```

**Trade-offs:**

**Merge:**
- ✅ Preserves history
- ✅ Shows actual flow
- ✅ Safe for shared
- ❌ Non-linear graph
- ❌ More commits

**Rebase:**
- ✅ Linear history
- ✅ Cleaner graph
- ✅ Easier to read
- ❌ Rewrites history
- ❌ Dangerous on shared

**When to Use:**
```bash
# Use merge:
git merge feature  # Public/shared

# Use rebase:
git rebase main    # Local/private
```

**Key Points:**
- Both valid approaches
- Context matters most
- Merge safer for teams
- Rebase cleaner for individuals
- Choose and stick with it

---

#### Q19: How do you handle large files in Git?

**Answer:**
Git struggles with large files. Multiple solutions exist.

**Problem:**
```
Large files (>100MB):
- Slow cloning
- Large storage
- Repository bloat
- Slow operations
```

**Solutions:**

**1. Git LFS (Recommended)**
```bash
# Install Git LFS
git lfs install

# Track large files
git lfs track "*.iso"
git lfs track "*.mp4"

# Commit as normal
git add large-file.iso
git commit -m "Add video"

# LFS handles storage
# Git stores pointer, not actual file
```

**2. Shallow Clone**
```bash
# Limited history
git clone --depth 1 url
# Only latest commit
# Much faster

git fetch --depth 1
# Limit depth on fetch
```

**3. Partial Clone**
```bash
# Download objects on demand
git clone --filter=blob:none url
# Gets commits/trees
# Fetches files only when needed
```

**4. Sparse Checkout**
```bash
# Download only needed files
git clone --sparse url
git sparse-checkout set src/
# Only checks out src/ directory
```

**5. Remove from History**
```bash
# BFG Repo-Cleaner (safer than filter-branch)
bfg --delete-files large-file.iso

# Cleanup
git reflog expire --all --expire=now
git gc --aggressive --prune=now
```

**Best Practices:**
```
- Use .gitignore for large files
- Git LFS for necessary large files
- Shallow clones for CI/CD
- Regular cleanup
- Monitor repository size
```

**Key Points:**
- Don't commit large files
- Use Git LFS when necessary
- Backup before history rewriting
- Shallow clones for speed
- Monitor size regularly

---

#### Q20: Explain a complete Git workflow for team collaboration.

**Answer:**
Complete workflow from feature start to deployment.

**Workflow Steps:**

```
1. Pull latest changes
2. Create feature branch
3. Make changes and commits
4. Push feature branch
5. Create Pull Request
6. Code review
7. Address feedback
8. Get approval
9. Merge to main
10. Delete feature branch
11. Deploy
```

**Detailed Example:**
```bash
# 1. Update main
git switch main
git pull origin main

# 2. Create feature branch
git switch -c feature/user-auth

# 3. Make changes
echo "function login() {}" > auth.ts
git add auth.ts
git commit -m "feat: Add login function"

echo "function logout() {}" > auth.ts
git add auth.ts
git commit -m "feat: Add logout function"

# 4. Push feature branch
git push -u origin feature/user-auth

# 5. Create Pull Request on GitHub
# Add description, request reviewers

# 6. Address feedback
# Make requested changes
echo "// Improved login" > auth.ts
git add auth.ts
git commit -m "refactor: Improve login logic"
git push

# 7. Get approval
# Reviewers approve PR

# 8. Merge PR (via GitHub UI or CLI)
git switch main
git pull origin main
git merge feature/user-auth
git push origin main

# 9. Delete feature branch
git branch -d feature/user-auth
git push origin --delete feature/user-auth

# 10. Deploy
# CI/CD triggers deployment
```

**Commit Message Convention:**
```
feat: Add new feature
fix: Fix bug
docs: Update documentation
style: Format code
refactor: Restructure code
perf: Performance improvement
test: Add tests
chore: Update dependencies

Example: feat(auth): Add user login
```

**Pull Request Template:**
```
## Description
What does this PR do?

## Related Issues
Fixes #123

## Changes Made
- Change 1
- Change 2

## Testing
How to test?

## Screenshots
If applicable
```

**Code Review Checklist:**
```
- Code follows style guide
- Tests included/passing
- Documentation updated
- No hardcoded values
- Performance acceptable
- Security concerns addressed
- Proper error handling
```

**Key Points:**
- Consistent workflow
- Clear commit messages
- Pull requests for code review
- One feature per branch
- Keep branches short-lived
- Regular communication
- Proper testing before merge
- Clean up branches

---

## Conclusion

Git is essential for modern software development. Key takeaways:

1. **Master Basics**: Commits, branches, staging
2. **Practice Workflows**: Branch strategies, PRs
3. **Understand History**: Merge vs rebase
4. **Safety First**: Understand destructive commands
5. **Team Communication**: Clear messages and reviews
6. **Continuous Learning**: Practice and experimentation

Regular practice builds proficiency and confidence!

