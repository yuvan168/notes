# PEGA (Pegasystems) Complete Guide - Theory & Practical Examples

## Table of Contents
1. [Introduction & Core Concepts](#introduction--core-concepts)
2. [PEGA Architecture Theory](#pega-architecture-theory)
3. [Business Process Management](#business-process-management)
4. [Rules Engine & Decision Logic](#rules-engine--decision-logic)
5. [Case Management](#case-management)
6. [Workflow & Process Design](#workflow--process-design)
7. [Data & Objects](#data--objects)
8. [User Interface & Channels](#user-interface--channels)
9. [Integration & Connectors](#integration--connectors)
10. [Analytics & Reporting](#analytics--reporting)
11. [Best Practices & Design Patterns](#best-practices--design-patterns)
12. [Practical Examples](#practical-examples)

---

## Introduction & Core Concepts

### What is PEGA?

**PEGA** (Pegasystems) is an **enterprise Business Process Management (BPM)** and **Customer Relationship Management (CRM)** platform. It provides:

- **Process Automation**: Automate complex business processes
- **Rules Engine**: Declarative business rules without coding
- **Case Management**: Handle flexible, knowledge-worker processes
- **Customer Engagement**: Multi-channel customer interaction
- **AI & Analytics**: Intelligent decision-making and insights

**Key Characteristics**:
- **Declarative**: Define WHAT to do, not HOW to do it
- **Configurable**: Low-code/no-code development
- **Scalable**: Enterprise-grade reliability
- **Intelligent**: AI-driven optimization
- **Customer-Centric**: Multi-channel experiences

### PEGA vs Traditional Development

| Aspect | PEGA | Traditional Code |
|--------|------|-----------------|
| **Development** | Declarative, visual | Imperative, text-based |
| **Speed** | Very fast (weeks) | Slower (months) |
| **Maintenance** | Easier (visual rules) | Complex (code review) |
| **Business Users** | Can understand/modify | Can't understand code |
| **Flexibility** | High (rules-based) | Fixed (hardcoded) |
| **Scalability** | Built-in clustering | Manual scaling |
| **Upgrades** | Smooth (backwards compatible) | Breaking changes |

### Core Principles

**1. Separation of Concerns**
- Rules separate from code
- UI separate from logic
- Data separate from processes

**2. Reusability**
- Rules can be reused across processes
- Objects can be shared
- Components are modular

**3. Maintainability**
- Changes in one place affect everywhere
- Easy to trace impacts
- Business users can update rules

**4. Performance**
- Compiled rules are optimized
- Caching strategies built-in
- Parallel execution support

---

## Key Concepts & Definitions

### Work Objects

**What is a Work Object?**

A Work Object (Work case) is the **primary unit of work** in PEGA. It represents a business entity that needs to be processed:

```
Characteristics:
├── Unique Identity: Each case has a unique ID (e.g., WC-12345)
├── Lifecycle: Has states (New → In Progress → Completed → Closed)
├── State-Based: Current status/stage determines available actions
├── Persistent: Stored in database, survives system restarts
├── Trackable: Full audit trail of all changes
└── Collaboratable: Multiple people can work on same case
```

**Examples of Work Objects**:
- Loan applications
- Insurance claims
- Support tickets
- Purchase orders
- Customer onboarding
- HR requests

**Work Object vs Data Object**:

```
Work Object:
├── Represents a piece of work
├── Has lifecycle/stages
├── Has assignments (who works on it)
├── Has SLAs/deadlines
└── Example: Mortgage Application (Work-MortgageApp)

Data Object:
├── Represents reference data
├── No lifecycle needed
├── Just stores information
├── Examples: Customer, Product, Account
```

### Properties

**What is a Property?**

A Property is a **data field** on a Work or Data object. Think of it like a database column:

```
Property: annual_income
├── Type: Decimal
├── Purpose: Store customer's yearly income
├── Used In: Loan qualification rules
├── Accessed As: .annual_income
└── Example Value: 75000.00
```

**Property Characteristics**:

```
Name: The field identifier
├── Example: credit_score
└── Used in rules as: .credit_score

Type: What kind of data
├── Text (string)
├── Number (integer, decimal)
├── Date/Time
├── Boolean (true/false)
├── Object (complex type)
└── List (array of values)

Usage: How it's used
├── Internal: Used only within PEGA
├── External: Exposed via APIs
├── Searchable: Can be indexed for queries
└── Reportable: Can be included in analytics

Rules: Additional constraints
├── Required: Must have a value
├── Unique: Cannot duplicate values
├── Read-only: Cannot be changed
├── Calculated: Auto-derived from other properties
└── Indexed: For fast lookups
```

**Built-in Properties** (Available on all cases):

```
.ID → Case ID (WC-12345)
.pxReferenceID → PEGA internal reference
.pzInsKey → Database primary key
.pyStatusWork → Current status
.pxCreateDateTime → When case created
.pxCreateOperatorID → Who created it
.pxUpdateDateTime → Last update time
.pxUpdateOperatorID → Who updated it
.pyAssignmentStatus → Assigned/Unassigned
.pxDeadlineTime → SLA deadline
```

### Rules

**What is a Rule?**

A Rule is a **unit of business logic** that defines behavior. Rules are PEGA's primary building blocks:

```
Rule Definition:
├── Name: Unique identifier (e.g., EvaluateLoanApproval)
├── Type: What kind of rule (Decision, Activity, Flow, etc.)
├── Purpose: What it does
├── Conditions: When it applies
└── Actions: What it executes
```

**Types of Rules**:

```
1. Decision Rules
   └─ Implement IF-THEN logic
   └─ Example: "IF credit_score > 700 THEN approve"

2. Activity Rules
   └─ Execute procedural steps
   └─ Example: "Calculate order total"

3. Flow Rules
   └─ Define process workflows
   └─ Example: "Order approval process"

4. Data Rules
   └─ Store information
   └─ Example: "Property definitions"

5. UI Rules
   └─ Define user interfaces
   └─ Example: "Customer portal layout"

6. Service Rules
   └─ Call external systems
   └─ Example: "Credit score lookup API"
```

**Rule Versions & Governance**:

```
Rule: CalculateOrderDiscount

Version 1.0 (Old)
├── Logic: 10% fixed discount
└── Effective: Jan 2024 - Aug 2024

Version 2.0 (Current)
├── Logic: Tiered discount based on loyalty
└── Effective: Sep 2024 - Present
└── Status: ACTIVE

Version 3.0 (Draft)
├── Logic: Dynamic discount with ML
└── Effective: Jan 2026 (planned)
└── Status: DEV

Retirement:
└── Version 1.0: Deprecated Dec 2024
```

### Activities

**What is an Activity?**

An Activity is a **reusable procedure** that executes steps. Activities are called from flows or other activities:

```
Purpose: Activities execute a sequence of steps

Structure:
├── Input Parameters: What activity receives
├── Steps: The actual work
│   ├── Call other activities
│   ├── Make decisions
│   ├── Call services
│   └── Update data
├── Output Parameters: What activity returns
└── Error Handling: What to do on failure

Reusability: Can be called multiple times
├── From different flows
├── From different activities
├── With different inputs
└── Same code executes
```

**Activity Execution Model**:

```
Called Activity: SendEmail

Input:
├── recipient: string
├── subject: string
└── body: string

Execution:
├── Step 1: Validate email format
├── Step 2: Connect to mail server
├── Step 3: Send message
└── Step 4: Log activity

Output:
├── success: boolean
├── message_id: string
└── delivery_time: datetime

Caller receives output and continues
```

### Flows

**What is a Flow?**

A Flow defines the **sequence of steps** in a process. It's the orchestration layer:

```
Purpose: Flows coordinate the work

Types:
├── Main Flow: Entry point for a case
├── Sub-Flow: Called from main or other flows
└── Service Flow: Calls external services

Characteristics:
├── Visual representation (flowchart)
├── Sequential steps
├── Decision points (branching)
├── Parallel processing
└── Error handling paths
```

**Flow Elements**:

```
Step: Do something
├── Call Activity
├── Call Another Flow
├── Make a Decision
├── Wait for time
└── Update Data

Decision: Branch logic
├── IF condition THEN path1 ELSE path2
└── Can have multiple branches

Assignment: Assign work
├── Assign to workgroup
├── Assign to individual
└── Assign based on rules

Wait: Pause processing
├── Wait for time period
├── Wait for event
└── Wait for condition
```

### Cases & Stages

**What is a Case?**

A Case is an **instance of a case type**. When you create a Work object, you're creating a case:

```
Case Type: Work-LoanApplication
Case Instance 1: WC-LOAN-2025-001 (John's application)
Case Instance 2: WC-LOAN-2025-002 (Sarah's application)
Case Instance 3: WC-LOAN-2025-003 (Mike's application)
```

**What is a Stage?**

A Stage is a **logical phase** in a case's lifecycle:

```
Case: Work-LoanApplication (WC-LOAN-2025-001)

Stages:
├── Stage 1: ApplicationSubmission
│   ├── Owner: Customer
│   ├── Actions: Fill form, submit
│   └── Exit: Submit button clicked
│
├── Stage 2: DocumentCollection
│   ├── Owner: System
│   ├── Actions: Request required docs
│   └── Exit: All docs received
│
├── Stage 3: CreditReview
│   ├── Owner: Loan Officer
│   ├── Actions: Review credit
│   └── Exit: Decision made
│
└── Stage 4: Funding
    ├── Owner: Payments
    ├── Actions: Process payment
    └── Exit: Funds transferred

Characteristics:
├── Sequential: Stages must complete in order
├── Assignable: Each stage has owner
├── Trackable: Time spent in each stage
└── Measurable: Performance metrics
```

### Assignments

**What is an Assignment?**

An Assignment is **work that someone needs to do**. It's like a task:

```
Assignment Example:

Case: WC-CL-2025-001234 (Insurance Claim)
Work Item: "Review claim documentation"
├── Assigned To: Claims Adjuster
├── Assigned Date: 2025-12-20
├── Due Date: 2025-12-25
├── Priority: High
├── Status: Open (not yet started)
└── Actions Available:
    ├── Open (start working)
    ├── Skip (reassign)
    └── Complete (finish)
```

**Assignment Lifecycle**:

```
NEW
  ↓ (User opens assignment)
IN_PROGRESS
  ↓ (User takes action)
  ├─ (User saves progress)
  ├─ (User reopens assignment)
  └─ (User completes assignment)
COMPLETED
  ↓ (System validates)
  ├─ (If validation passes)
  RESOLVED
  └─ (If validation fails)
  RE-OPENED
```

### Rules vs Activities vs Flows

**Key Differences**:

```
┌─────────────┬────────────────────┬──────────────────┬─────────────────┐
│ Aspect      │ Rule               │ Activity         │ Flow            │
├─────────────┼────────────────────┼──────────────────┼─────────────────┤
│ Purpose     │ Decision/Logic     │ Steps/Procedure  │ Orchestration   │
├─────────────┼────────────────────┼──────────────────┼─────────────────┤
│ Scope       │ Single decision    │ Multi-step task  │ Complete process│
├─────────────┼────────────────────┼──────────────────┼─────────────────┤
│ Example     │ "IF score>700"     │ "Calculate total"│ "Order process" │
├─────────────┼────────────────────┼──────────────────┼─────────────────┤
│ Returns     │ Result (yes/no)    │ Output data      │ Next step       │
├─────────────┼────────────────────┼──────────────────┼─────────────────┤
│ Visual      │ Table/Tree         │ Steps list       │ Flowchart       │
└─────────────┴────────────────────┴──────────────────┴─────────────────┘
```

**Composition**:

```
Flow
├── Calls Activity 1
│   ├── Uses Rule 1
│   ├── Uses Rule 2
│   └── Calls Service
├── Makes Decision (Rule 3)
└── Calls Activity 2
    ├── Uses Rule 4
    └── Calls Activity 3
        └── Uses Rule 5
```

### Connectors & Integration

**What is a Connector?**

A Connector is a **bridge to external systems**. It handles communication:

```
Purpose: Call external APIs/systems

Types:
├── REST Connector
│   ├── Call REST APIs
│   ├── HTTP methods: GET, POST, PUT, DELETE
│   └── Format: JSON/XML
│
├── SOAP Connector
│   ├── Call SOAP web services
│   ├── Protocol: SOAP/XML
│   └── Format: XML
│
├── Database Connector
│   ├── Query databases
│   ├── Methods: SELECT, INSERT, UPDATE, DELETE
│   └── Format: SQL
│
└── File Connector
    ├── Read/write files
    ├── Protocols: FTP, SFTP, HTTP
    └── Formats: CSV, JSON, XML
```

**Request/Response Cycle**:

```
PEGA System
    ↓
[Connector]
    ↓
(Map request data)
    ↓
Send HTTP/Request
    ↓
External System
    ↓
Process request
    ↓
Send response
    ↓
[Connector]
    ↓
(Map response data)
    ↓
PEGA System
    ↓
Continue flow
```

### Clipboard

**What is a Clipboard?**

The Clipboard is **temporary memory** used during case execution:

```
Purpose: Hold data during processing

Lifecycle:
├── Created: When case starts
├── Used: Throughout processing
└── Discarded: When case ends

Storage:
├── Case data
├── Temporary variables
├── Activity results
├── API responses
└── User inputs

Accessibility:
├── Read: . (dot notation)
   └─ Example: .customer_name
├── Write: Assignment statements
   └─ Example: .total = subtotal + tax
└── Scope: Available in all activities for case
```

**Clipboard Example**:

```
Clipboard During Order Processing:

┌─────────────────────────────────┐
│ Clipboard (Memory)              │
├─────────────────────────────────┤
│                                 │
│ customer_id: "CUST-12345"       │
│ items: [                         │
│   {id: "PROD-1", qty: 2, ...},  │
│   {id: "PROD-2", qty: 1, ...}   │
│ ]                               │
│ subtotal: 125.00                │
│ tax: 10.00                      │
│ total: 135.00                   │
│ payment_method: "CreditCard"    │
│ payment_status: "APPROVED"      │
│ fulfillment_id: "FO-78901"      │
│                                 │
└─────────────────────────────────┘
(All cleared when case completes)
```

### Data vs Work Objects

**Work Objects (Cases)**:

```
Characteristics:
├── Represent work to be done
├── Have lifecycle (stages)
├── Are assigned to users/teams
├── Have SLAs and deadlines
├── Have complex workflows
└── Example: LoanApplication, InsuranceClaim

Typical Use:
├── Customer requests
├── Applications
├── Incidents/Tickets
└── Any work needing human involvement
```

**Data Objects (Reference Data)**:

```
Characteristics:
├── Represent reference information
├── No lifecycle needed
├── Stored for lookup
├── Accessed by work objects
├── Usually read-only
└── Example: Customer, Product, Account

Typical Use:
├── Master data
├── Lookup tables
├── Configuration
└── Support data for decisions
```

**Relationship**:

```
Work Object → References → Data Objects

Example:
LoanApplication
├── Refers to → Customer (Data)
├── Refers to → Product (Data)
└── Refers to → Account (Data)
```

---

## Advanced Concepts

### SLAs (Service Level Agreements)

**What is an SLA?**

An SLA defines **performance expectations** for cases:

```
Purpose: Track and enforce response times

Components:
├── Target: Deadline for completion
├── Goal: Ideal completion time
└── Urgent: Escalation threshold
```

**SLA Example**:

```
Case Type: Work-SupportTicket

SLA Definition:
├── Response Target: 4 hours
│   └─ Must acknowledge ticket within 4 hours
├── Resolution Target: 24 hours
│   └─ Must resolve within 24 hours
└── Urgent Target: 1 hour
    └─ If not started after 1 hour, escalate
```

**SLA Monitoring**:

```
Timeline:
T0:00 → Ticket created
T0:30 → Agent starts work (ON TRACK)
T1:00 → URGENT threshold (if not started, escalate)
T4:00 → RESPONSE deadline
T24:00 → RESOLUTION deadline

Status:
├─ ON TRACK: Within timeline
├─ AT RISK: Within 80% of deadline
├─ OVERDUE: Passed deadline
└─ BREACHED: Missed deadline
```

### Workgroups & Assignment

**What is a Workgroup?**

A Workgroup is a **team of users** that shares assignments:

```
Purpose: Distribute work among team members

Structure:
├── Workgroup Name: "SalesTeam"
├── Members:
│   ├── John Smith (Sales Manager)
│   ├── Sarah Johnson (Sales Rep)
│   └── Mike Davis (Sales Rep)
├── Manager: John Smith
└── Assignments:
    ├── All unassigned sales cases
    ├── Available to any member
    └── Can be claimed by members
```

**Assignment Routing Rules**:

```
Strategy 1: Round-Robin
├── Distribute evenly
├── Person A gets first, Person B second, Person C third, repeat
└── Fairness-based

Strategy 2: Skill-Based
├── Route by expertise
├── Sales expert → sales cases
├── Tech expert → technical cases
└── Capability-based

Strategy 3: Load-Based
├── Route to least busy
├── Person with fewest open cases gets next
└── Balance workload

Strategy 4: Priority-Based
├── High priority → senior people
├── Medium priority → regular people
└── Low priority → junior people/pool
```

### Milestones

**What is a Milestone?**

A Milestone marks **significant points** in a case:

```
Purpose: Track progress and deadlines

Types:

1. Business Milestone
   ├── Example: "First Response"
   ├── Deadline: 1 hour from case creation
   └── Impact: Customer-facing, measured

2. System Milestone
   ├── Example: "Case Routed"
   ├── Deadline: Immediate (auto)
   └── Impact: Internal tracking

3. Custom Milestone
   ├── Example: "Manager Approval"
   ├── Deadline: Based on stage progress
   └── Impact: Process-specific
```

**Milestone Example**:

```
Case: Work-LoanApplication

Milestone 1: ApplicationComplete
├── Deadline: 2 hours after creation
├── Status: REACHED (1.5 hours in)
└── On time ✓

Milestone 2: DocumentsVerified
├── Deadline: 24 hours after creation
├── Status: AT_RISK (18 hours elapsed, 6 remaining)
└── 75% towards deadline

Milestone 3: Approved
├── Deadline: 5 days after creation
├── Status: PENDING (2 days elapsed, 3 remaining)
└── 40% towards deadline
```

### Correspondence

**What is Correspondence?**

Correspondence is **outbound communication** (emails, letters, SMS):

```
Purpose: Keep customers informed

Types:

1. Email Correspondence
   ├── Recipient: Email address
   ├── Template: Predefined format
   └── Triggered: By system events

2. Letter Correspondence
   ├── Recipient: Mailing address
   ├── Template: PDF format
   └── Triggered: By system events

3. SMS Correspondence
   ├── Recipient: Phone number
   ├── Message: Short text
   └── Triggered: For urgent notifications
```

**Correspondence Template**:

```
Template: LoanApprovalLetter

Variables:
├── {{applicant_name}}
├── {{loan_amount}}
├── {{approval_date}}
├── {{interest_rate}}
└── {{disbursement_date}}

Content:
Dear {{applicant_name}},

We are pleased to inform you that your loan application 
for ${{loan_amount}} has been approved.

Approval Date: {{approval_date}}
Interest Rate: {{interest_rate}}%
Expected Disbursement: {{disbursement_date}}

Sincerely,
Loan Department

Triggered When:
├── Case status = "APPROVED"
└── Customer has email on file
```

### Declarative Rules (Calculated Properties)

**What is a Declarative Rule?**

A Declarative Rule **automatically calculates** a value based on other properties:

```
Purpose: Keep derived data always in sync

How it works:
├── Define: How to calculate
├── PEGA tracks: Dependencies
├── Auto-recalculates: When dependencies change
└── Always current: No stale data
```

**Example: Calculate Age**:

```
Declarative Rule: CalculateAge

Definition:
├── Source: birthdate property
├── Formula: TODAY() - birthdate (in years)
└── Frequency: Auto on any access

Usage:
.birthdate = 1990-01-15
.age (accessed) → PEGA recalculates → 35 years

If birthdate changes:
.birthdate = 1995-06-20
.age (accessed) → PEGA recalculates → 30 years
(Always current, no manual update needed)
```

**Benefits**:

```
✓ No data inconsistency
✓ Always accurate
✓ No redundant storage
✓ Single source of truth
```

### Correspondence Pools

**What is a Correspondence Pool?**

A Correspondence Pool manages **outbound communication**:

```
Purpose: Queue and send correspondence

Process:

1. Generate
   └─ Create letter/email based on template

2. Queue
   └─ Add to correspondence queue

3. Process
   ├─ Batch processing (scheduled)
   └─ Individual (immediate)

4. Send
   ├─ Email: SMTP server
   ├─ Letter: Print + mail
   └─ SMS: SMS gateway

5. Track
   └─ Delivery status
```

### Audit Trail

**What is an Audit Trail?**

An Audit Trail **records all changes** to a case:

```
Purpose: Compliance, troubleshooting, accountability

Tracked Events:

1. Creation
   ├── When: 2025-12-20 09:00:00
   ├── Who: CustomerPortal (System)
   └── What: Case created

2. Changes
   ├── When: 2025-12-20 09:15:00
   ├── Who: john.smith@company.com
   ├── What: Property updated
   ├── Field: status
   ├── From: "New"
   └── To: "Under Review"

3. Correspondence
   ├── When: 2025-12-20 09:30:00
   ├── Who: System
   ├── What: Letter generated
   └── Type: "ApprovalNotice"

4. Assignments
   ├── When: 2025-12-20 10:00:00
   ├── Who: Manager
   ├── What: Case assigned
   └── To: Claims Team

Example Audit Report:

2025-12-20 09:00:00 | System      | CASE_CREATED
2025-12-20 09:15:00 | john.smith  | STATUS: New → Under Review
2025-12-20 09:30:00 | System      | CORRESPONDENCE_SENT: Email
2025-12-20 10:00:00 | manager     | ASSIGNED_TO: ClaimsTeam
2025-12-20 10:45:00 | sarah.j     | STATUS: Under Review → Approved
2025-12-20 11:00:00 | System      | CORRESPONDENCE_SENT: Letter
2025-12-20 11:30:00 | System      | CASE_COMPLETED
```

### Business Rules Engine (BRE)

**What is a Rules Engine?**

A Rules Engine **executes decision logic** without coding:

```
Purpose: Separate business logic from code

Components:

1. Rules Repository
   ├── Store all rules
   ├── Versioning
   └── Governance

2. Rules Compiler
   ├── Convert rules to executable
   ├── Optimize for performance
   └── Validate consistency

3. Rules Executor
   ├── Evaluate conditions
   ├── Execute actions
   └── Track decisions

4. Rules Analytics
   ├── Which rules execute most
   ├── Rule performance
   └── Decision patterns
```

**Execution Flow**:

```
Input Data
    ↓
[Rules Engine]
    ├─ Load applicable rules
    ├─ Evaluate conditions
    ├─ Apply transformations
    └─ Execute actions
    ↓
Output Data + Decision Log
```

### Inheritance

**What is Inheritance in PEGA?**

Inheritance allows **child classes to reuse** parent class rules:

```
Purpose: Avoid duplication, maintain consistency

Structure:

Parent Class: Rule-Abstract
├── Common rules
├── Shared properties
└── Standard procedures

Child Class: Work-Application
├── Inherits from parent
├── Can override rules
├── Adds specific logic
└── More specialized

Multi-Level Inheritance:

Work-Application (Abstract)
    ├─ Work-LoanApplication
    │  ├─ Work-LoanApplication-Auto
    │  └─ Work-LoanApplication-Mortgage
    └─ Work-CreditCardApplication
       ├─ Work-CreditCardApplication-Secured
       └─ Work-CreditCardApplication-Unsecured
```

**Inheritance Benefits**:

```
✓ Reuse common rules
✓ Consistent behavior
✓ Easy updates (change parent affects all)
✓ Specialized implementations
```

### Rule Versions

**What are Rule Versions?**

Rule Versions track **changes over time**:

```
Purpose: Governance, rollback, A/B testing

Version Numbering:

Version 1.0
├── Initial release
├── Effective date: Jan 1, 2024
└── Status: Active

Version 2.0 (Updated)
├── Changed logic
├── Effective date: Sep 1, 2024
└── Status: Active

Version 1.1 (Deprecated)
├── Old version
├── Effective date: ended Sep 1, 2024
└── Status: Deprecated

Version 3.0 (Draft)
├── New version
├── Effective date: Jan 1, 2026 (planned)
└── Status: Development
```

**Version Control Benefits**:

```
✓ Track changes
✓ Rollback if needed
✓ Parallel testing
✓ Audit compliance
✓ Team collaboration
```

---

## PEGA Architecture Theory

### Layered Architecture

PEGA follows a **5-layer model**:

```
┌──────────────────────────────────────────────┐
│     Presentation Layer (Portals, Mobile)     │
├──────────────────────────────────────────────┤
│     Application Layer (Cases, Flows)         │
├──────────────────────────────────────────────┤
│     Rules Layer (Business Rules Engine)      │
├──────────────────────────────────────────────┤
│     Data Layer (Objects, Databases)          │
├──────────────────────────────────────────────┤
│     Integration Layer (APIs, Connectors)     │
└──────────────────────────────────────────────┘
```

**Layer Responsibilities**:

1. **Presentation**: User interfaces (Portals, Mobile apps, Channels)
   - No business logic here
   - Calls actions/activities
   - Example: Customer portal showing active cases

2. **Application**: Cases, processes, and workflows
   - Orchestrates business logic
   - Manages case lifecycle
   - Example: Loan approval case type

3. **Rules**: Decision logic and business rules
   - Rules engine processes decisions
   - Conditional branching
   - Example: Credit score evaluation rules

4. **Data**: Information storage and retrieval
   - Work objects, system of record
   - Database persistence
   - Example: Account, Case data

5. **Integration**: External system communication
   - Service connectors
   - Message handling
   - Example: REST API calls, file processing

### Class Hierarchy

PEGA uses **object-oriented class hierarchy** for data organization:

```
┌─── Rule-Abstract (Abstract base classes)
│
├─── Rule-Declare-Index
├─── Rule-Declare-Constraint
├─── Rule-Declare-Param
│
├─── Data-Admin-DB-Credentials
├─── Data-Admin-DB-Table
│
├─── Work- (Work objects/cases)
│    ├── Work-Cover (Insurance claims)
│    ├── Work-Orders (Sales orders)
│    └── Work-Support (Support tickets)
│
└─── Data- (Data objects)
     ├── Data-Account
     ├── Data-Customer
     └── Data-Product

```

**Key Principles**:
- **Inheritance**: Subclasses inherit from parent classes
- **Code Reusability**: Common properties/rules at parent level
- **Type Safety**: Each class represents a business entity
- **Polymorphism**: Same rule name at different class levels

### Instance vs Class Architecture

**Instance Architecture**: The PEGA platform itself

```
┌────────────────────────────────────────┐
│  PEGA Instance (Single Installation)   │
├────────────────────────────────────────┤
│ ┌── Application 1                      │
│ │   ├── Cases                          │
│ │   ├── Rules                          │
│ │   └── Data                           │
│ ├── Application 2                      │
│ │   ├── Cases                          │
│ │   ├── Rules                          │
│ │   └── Data                           │
│ └── Shared Services                    │
│     ├── Authentication                 │
│     ├── Reporting                      │
│     └── Integrations                   │
└────────────────────────────────────────┘
```

---

## Business Process Management

### Theory: Process-Centric Architecture

**What is BPM?**

Business Process Management focuses on:
- **Mapping**: Visual representation of processes
- **Modeling**: Defining process flows
- **Executing**: Running automated processes
- **Monitoring**: Tracking process performance
- **Optimizing**: Improving process efficiency

**Process Types in PEGA**:

1. **Structured Processes**: Well-defined, repeatable
   ```
   Order → Validate → Process Payment → Ship → Deliver
   ```

2. **Unstructured Processes**: Knowledge-intensive
   ```
   Support Case → Diagnose → Resolve/Escalate → Close
   (Non-linear, flexible routing)
   ```

3. **Hybrid Processes**: Mix of both
   ```
   Loan Application → [Structured checks] → [Knowledge-intensive review] → Decision
   ```

### Flow Types

**1. Main Flow (Process Flow)**
- Entry point for a case
- Defines primary workflow
- Example: New customer onboarding

**2. Sub-Flow**
- Called from main or other sub-flows
- Reusable process segments
- Example: Background check subprocess

**3. Split Joins**
- Parallel processing
- Wait for all branches or first one
- Example: Process multiple approvals in parallel

```
Flow Example:
Step 1: Validate Input
    ↓
Step 2: [Parallel Split]
    ├→ Check Fraud (parallel)
    ├→ Check Credit (parallel)
    └→ Check Compliance (parallel)
    ↓
Step 3: [Wait for All - Join]
    ↓
Step 4: Make Decision
```

**4. Branch Logic**
- Conditional routing
- Rules-based decisions
- Example: Route to appropriate department based on priority

```
Flow Example:
Step 1: Evaluate Priority
    ↓
Step 2: [Branch]
    ├→ High: Escalate immediately
    ├→ Medium: Queue for next available
    └→ Low: Schedule for later
```

### Swimlanes & Responsibilities

PEGA uses **swimlanes** to show who does what:

```
┌─────────────────────────────────────────┐
│ Application Process (Swimlane View)     │
├──────────┬──────────┬──────────┬────────┤
│ Customer │ System   │ Manager  │ Admin  │
├──────────┼──────────┼──────────┼────────┤
│  Submit  │          │          │        │
│ Request  │          │          │        │
│     ↓    │          │          │        │
│          │ Validate │          │        │
│          │   Data   │          │        │
│          │     ↓    │          │        │
│          │          │ Review   │        │
│          │          │     ↓    │        │
│          │          │          │ Approve│
│          │          │          │     ↓  │
└──────────┴──────────┴──────────┴────────┘
```

---

## Rules Engine & Decision Logic

### Theory: Declarative Decision Making

**What is a Rules Engine?**

A rules engine is a system that:
- **Evaluates conditions** in business rules
- **Executes actions** based on conditions
- **Manages rule priority** and precedence
- **Maintains business logic** separately from code

**PEGA Rules**:

1. **Decision Rule**: Branch logic (if-then)
   ```
   IF credit_score > 700
   THEN status = "APPROVED"
   ELSE status = "REVIEW_REQUIRED"
   ```

2. **Circumstance Rule**: Conditional rule variants
   ```
   Base rule: CalculateDiscount
   Circumstance: When premium_member = true
   Circumstance: When order_value > 5000
   ```

3. **Declarative Rule**: Data derivation
   ```
   age = today - birthdate
   (Automatically recalculates when dependencies change)
   ```

4. **Constraint Rule**: Data validation
   ```
   email MUST match pattern ^\S+@\S+\.\S+$
   phone MUST have length = 10
   ```

### Decision Tree vs Decision Table

**Decision Tree** (Nested If-Then):
```
START
  ↓
Is Customer Premium?
  ├→ YES: Is Account > 5 years?
  │         ├→ YES: 25% discount
  │         └→ NO: 15% discount
  └→ NO: 5% discount
```

**Decision Table** (Matrix-based):
```
┌──────────────┬──────────────┬──────────┐
│ Premium | Tenure | Discount │
├──────────────┼──────────────┼──────────┤
│ YES    | > 5y   | 25%      │
│ YES    | ≤ 5y   | 15%      │
│ NO     | ANY    | 5%       │
└──────────────┴──────────────┴──────────┘
```

### Example 3: Credit Score Decision Rule

**Scenario**: Determine loan eligibility based on credit score and income

```
Decision Rule: EvaluateLoanEligibility

Purpose: Classify loan applications as Approved, ManualReview, or Rejected

Inputs:
├── credit_score (integer)
├── annual_income (decimal)
├── existing_debt (decimal)
└── employment_years (integer)

Output: eligibility_status (Approved, ManualReview, Rejected)

Decision Tree Implementation:

Level 1: Primary Credit Score Check
┌─ IF credit_score >= 750
│  THEN path = "Strong"
├─ ELSE IF credit_score >= 650
│  THEN path = "Moderate"
└─ ELSE
   THEN eligibility_status = "Rejected", EXIT

Level 2 (For "Strong" path): Income Verification
┌─ IF annual_income >= 75000
│  THEN eligibility_status = "Approved"
├─ ELSE IF annual_income >= 50000
│  THEN eligibility_status = "ManualReview"
└─ ELSE
   THEN eligibility_status = "Rejected"

Level 2 (For "Moderate" path): Detailed Review
┌─ Calculate debt_to_income_ratio = existing_debt / annual_income
│
├─ IF debt_to_income_ratio < 0.30 AND annual_income >= 60000
│  THEN eligibility_status = "Approved"
├─ ELSE IF debt_to_income_ratio < 0.40 AND annual_income >= 50000
│  THEN eligibility_status = "ManualReview"
└─ ELSE
   THEN eligibility_status = "Rejected"

Decision Table Representation:

╔═════════════╦═══════════╦═════════════╦════════════╦════════════════════╗
║ CreditScore ║ Income    ║ DTI Ratio   ║ Employment ║ Result             ║
╠═════════════╬═══════════╬═════════════╬════════════╬════════════════════╣
║ >= 750      ║ >= 75000  ║ ANY         ║ ANY        ║ Approved           ║
║ >= 750      ║ 50-75K    ║ ANY         ║ ANY        ║ ManualReview       ║
║ >= 750      ║ < 50K     ║ ANY         ║ ANY        ║ Rejected           ║
║ 650-749     ║ >= 60K    ║ < 30%       ║ >= 2 yrs   ║ Approved           ║
║ 650-749     ║ >= 50K    ║ 30-40%      ║ >= 1 yr    ║ ManualReview       ║
║ 650-749     ║ < 50K     ║ ANY         ║ ANY        ║ Rejected           ║
║ < 650       ║ ANY       ║ ANY         ║ ANY        ║ Rejected           ║
╚═════════════╩═══════════╩═════════════╩════════════╩════════════════════╝

Example Execution 1 (Approved):

Input:
{
  "credit_score": 780,
  "annual_income": 100000,
  "existing_debt": 15000,
  "employment_years": 5
}

Decision Flow:
├─ Level 1: credit_score 780 >= 750 → path = "Strong"
├─ Level 2: annual_income 100000 >= 75000 → eligibility_status = "Approved"
└─ Output: "Approved"

Example Execution 2 (ManualReview):

Input:
{
  "credit_score": 700,
  "annual_income": 60000,
  "existing_debt": 12000,
  "employment_years": 3
}

Decision Flow:
├─ Level 1: credit_score 700 >= 650 → path = "Moderate"
├─ Level 2: debt_to_income = 12000/60000 = 0.20 < 0.30
├─         annual_income 60000 >= 60000 ✓
├─         employment_years 3 >= 2 ✓
└─ Output: "Approved"

Example Execution 3 (Rejected):

Input:
{
  "credit_score": 600,
  "annual_income": 45000,
  "existing_debt": 25000,
  "employment_years": 1
}

Decision Flow:
├─ Level 1: credit_score 600 < 650 → eligibility_status = "Rejected"
└─ Output: "Rejected"

Example Execution 4 (ManualReview - Borderline):

Input:
{
  "credit_score": 680,
  "annual_income": 55000,
  "existing_debt": 18000,
  "employment_years": 2
}

Decision Flow:
├─ Level 1: credit_score 680 >= 650 → path = "Moderate"
├─ Level 2: debt_to_income = 18000/55000 = 0.327 > 0.30 but < 0.40
├─         annual_income 55000 >= 50000 ✓
├─         employment_years 2 >= 1 ✓
└─ Output: "ManualReview"
```

### Example 4: Circumstance Rules (Rule Variants)

**Scenario**: Different calculation rules based on customer type

```
Base Rule: CalculateShippingCost
├── Inputs: order_total, delivery_distance
├── Output: shipping_cost
└── Base Logic: shipping_cost = distance * $0.50

Rule Variants (Circumstances):

Circumstance 1: When customer_type = "Premium"
├── Logic Override: FREE shipping on orders > $100
│                   AND next-day delivery
├── shipping_cost = 0 (if order_total > 100)
└── delivery_days = 1

Circumstance 2: When order_total > 500
├── Logic Override: 20% shipping discount
├── shipping_cost = distance * $0.50 * 0.80
└── Applied to all customer types

Circumstance 3: When delivery_distance > 100 AND customer_type = "Standard"
├── Logic Override: Flat rate instead of per-distance
├── shipping_cost = $25.00
└── Applied only to standard customers

Rule Application Order (Priority):
1. Circumstance 1 & 2 & 3 (most specific - all conditions match)
2. Circumstance 1 & 2 (two conditions match)
3. Circumstance 2 & 3 (two conditions match)
4. Circumstance 1 (single condition matches)
5. Base Rule (no circumstances apply)

Example Execution 1 (Premium Customer, High Order):

Input:
├── customer_type: "Premium"
├── order_total: $150
└── delivery_distance: 50 miles

Conditions Check:
├─ Circumstance 1: customer_type = "Premium" ✓ AND order_total > 100 ✓
├─ Circumstance 2: order_total > 500 ✗
├─ Circumstance 3: delivery_distance > 100 ✗

Result:
├─ Applied Rule: Circumstance 1 (highest priority match)
├─ shipping_cost = $0 (FREE shipping)
├─ delivery_days = 1
└─ Reason: Premium customer with order > $100

Example Execution 2 (Standard Customer, Very Large Order):

Input:
├── customer_type: "Standard"
├── order_total: $600
└── delivery_distance: 30 miles

Conditions Check:
├─ Circumstance 1: customer_type = "Premium" ✗
├─ Circumstance 2: order_total > 500 ✓
├─ Circumstance 3: delivery_distance > 100 ✗

Result:
├─ Applied Rule: Circumstance 2
├─ shipping_cost = (30 * $0.50) * 0.80 = $12.00 (20% discount)
└─ Reason: Large order discount

Example Execution 3 (Standard Customer, Far Distance):

Input:
├── customer_type: "Standard"
├── order_total: $75
└── delivery_distance: 150 miles

Conditions Check:
├─ Circumstance 1: customer_type = "Premium" ✗
├─ Circumstance 2: order_total > 500 ✗
├─ Circumstance 3: delivery_distance > 100 ✓ AND customer_type = "Standard" ✓

Result:
├─ Applied Rule: Circumstance 3
├─ shipping_cost = $25.00 (flat rate)
└─ Reason: Far distance flat-rate pricing for standard customers

Example Execution 4 (Base Rule - No Circumstances):

Input:
├── customer_type: "Standard"
├── order_total: $50
└── delivery_distance: 25 miles

Conditions Check:
├─ Circumstance 1: customer_type = "Premium" ✗
├─ Circumstance 2: order_total > 500 ✗
├─ Circumstance 3: delivery_distance > 100 ✗

Result:
├─ Applied Rule: Base Rule (no circumstances apply)
├─ shipping_cost = 25 miles * $0.50 = $12.50
└─ Reason: Standard distance-based pricing
```

### Priority & Precedence

PEGA manages multiple rules through **priority system**:

```
1. Most Specific Rule
2. Circumstance Rules (ordered by specificity)
3. Base Rule
4. System Default Rules
5. Inheritance Chain
```

---

## Case Management

### Theory: Flexible, Knowledge-Worker Processes

**What is Case Management?**

Case Management handles **unstructured** or **semi-structured** work:
- **Knowledge-intensive**: Require human judgment
- **Flexible**: Non-linear, adaptive workflows
- **Long-running**: Can take days or months
- **Exception-driven**: Handle anomalies naturally

**Case Characteristics**:
- **State-based**: Case has current state
- **Multi-stage**: Progresses through stages
- **Collaborative**: Multiple people involved
- **Adaptive**: Can take different paths

### Case Type Definition

**Example: Support Ticket Case Type**

```
Case Type: Work-Support-Ticket
├── Properties
│   ├── ticket_id
│   ├── customer_id
│   ├── subject
│   ├── description
│   ├── priority (High, Medium, Low)
│   ├── status (New, Assigned, In Progress, Resolved, Closed)
│   ├── assigned_to
│   └── created_date
│
├── Stages
│   ├── Assignment Stage
│   │   └── Action: Assign to agent
│   ├── Resolution Stage
│   │   └── Action: Work on ticket
│   └── Closure Stage
│       └── Action: Close ticket
│
├── Milestones
│   ├── First Response: 1 hour
│   ├── Resolution: 4 hours
│   └── Closure: 1 day
│
└── Metrics
    ├── Average resolution time
    ├── Customer satisfaction
    └── First contact resolution rate
```

### Case Lifecycle

```
CREATE CASE
    ↓
[Application]
    ├→ Validation rules run
    ├→ Initial assignment
    └→ Start stage
    ↓
[In Progress]
    ├→ Agents work on case
    ├→ Status updates
    └→ Can move between stages
    ↓
[Complete]
    ├→ Case resolved
    ├→ Archival rules run
    └→ Metrics captured
    ↓
[Closed]
    └→ Case inactive
```

### Example 7: Complete Case Lifecycle - Insurance Claim

**Case Type: Work-InsuranceClaim**

```
Timeline and State Transitions:

╔═══════════════════════════════════════════════════════════════╗
║ CASE LIFECYCLE: Insurance Claim Processing                   ║
╚═══════════════════════════════════════════════════════════════╝

┌─────────────────────────────────────────────────────────────┐
│ PHASE 1: INITIATION (T0:00)                                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ Event: Customer Files Claim                                │
│                                                             │
│ Create Case:                                               │
│ ├── CaseID: WC-CL-2025-001234                             │
│ ├── CaseType: Work-InsuranceClaim                          │
│ ├── Status: New                                            │
│ ├── CurrentStage: ClaimSubmission                          │
│ ├── CreatedDate: 2025-12-20 09:00:00                      │
│ ├── CreatedBy: CustomerPortal (Self-Service)              │
│ ├── Priority: Medium (default)                             │
│ └── Data Collected:                                        │
│     ├── PolicyNumber: POL-987654                           │
│     ├── ClaimType: Medical                                 │
│     ├── IncidentDate: 2025-12-18                           │
│     ├── IncidentDescription: "Hospital visit"              │
│     ├── ClaimAmount: $2,500                                │
│     └── SupportingDocuments: [receipt.pdf, bill.pdf]       │
│                                                             │
│ Automatic Actions:                                         │
│ ├─ Activity: GenerateCaseNumber → WC-CL-2025-001234       │
│ ├─ Decision: DetermineCaseRouting                          │
│ │  └─ Based on: ClaimType (Medical) + Amount ($2,500)     │
│ │  └─ Result: Route to "StandardReview" team               │
│ └─ Milestone: Set response_deadline = 2025-12-27          │
│    (7 days for initial response per policy)                │
│                                                             │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ PHASE 2: VALIDATION (T0:30 - 30 minutes later)              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ Stage: DocumentValidation                                  │
│ Assigned To: Validation Team (Workgroup)                   │
│ Status: Under Review                                       │
│                                                             │
│ System Automatic Checks:                                   │
│ ├─ Activity: ValidatePolicy                                │
│ │  ├─ Check: PolicyNumber exists? ✓ Yes                  │
│ │  ├─ Check: Policy active? ✓ Yes                         │
│ │  ├─ Check: Medical coverage included? ✓ Yes            │
│ │  └─ Result: POLICY_VALID                               │
│ │                                                          │
│ ├─ Activity: ValidateClaimDetails                          │
│ │  ├─ Check: IncidentDate within coverage period? ✓ Yes   │
│ │  ├─ Check: IncidentDate not in future? ✓ Yes            │
│ │  ├─ Check: Deductible ($500) already met? ? Unknown     │
│ │  └─ Result: DETAILS_VALID (need deductible check)       │
│ │                                                          │
│ └─ Activity: ValidateDocuments                             │
│    ├─ Check: Receipt.pdf scannable? ✓ Yes                 │
│    ├─ Check: Bill.pdf shows covered procedures? ✓ Yes     │
│    └─ Result: DOCUMENTS_VALID                             │
│                                                             │
│ Manual Review by Validation Agent:                         │
│ ├─ Agent: John Smith (John.Smith@insurance.com)           │
│ ├─ Review Complete: 2025-12-20 09:35                       │
│ ├─ Notes: "All documentation provided, policy active,     │
│ │           proceed to investigation"                       │
│ └─ Action: Move to Next Stage                              │
│                                                             │
│ Status Update: VALIDATION_PASSED                            │
│ ├─ Set Priority: High (medical urgent cases)               │
│ └─ Update ProcessTime = 35 minutes                         │
│                                                             │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ PHASE 3: INVESTIGATION (T1:00 - 1 hour)                     │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ Stage: ClaimInvestigation                                  │
│ Assigned To: Claims Adjuster (Sarah Johnson)               │
│ Status: In Investigation                                   │
│                                                             │
│ Process Flow:                                              │
│                                                             │
│ [Step 1] Contact Provider for Details                      │
│ ├─ Type: Service Call (External)                           │
│ ├─ Service: ProviderVerificationAPI                        │
│ ├─ Call: Verify medical services with hospital             │
│ └─ Result: Services confirmed, $2,400 actual cost          │
│                                                             │
│ [Step 2] Parallel Investigation [PARALLEL]                 │
│ ├─ Branch A: Review Medical Necessity                      │
│ │  ├─ Decision: Is this medically necessary? ✓ Yes        │
│ │  ├─ Reasoning: ER visit for chest pain (appropriate)     │
│ │  └─ Coverage: 100% (emergency care)                      │
│ │                                                          │
│ ├─ Branch B: Check Fraud Indicators                        │
│ │  ├─ Decision: Call activity.frequency_check() = 1       │
│ │  ├─ Check: Similar claims in past 12mo? No              │
│ │  ├─ Check: Provider credible? Yes (major hospital)       │
│ │  └─ Result: LOW_FRAUD_RISK                              │
│ │                                                          │
│ └─ Branch C: Verify Deductible Status                      │
│    ├─ Query: SELECT deductible_met FROM policy_ytd         │
│    ├─ Result: Deductible met = Yes ($500 paid in Jan)     │
│    └─ Remaining Coverage: 100%                             │
│                                                             │
│ Adjuster Notes (T1:15):                                     │
│ ├─ "All documentation verified"                             │
│ ├─ "No fraud indicators"                                    │
│ ├─ "Deductible already met, claim eligible for 100%"      │
│ └─ "Ready for approval"                                     │
│                                                             │
│ Status Update: INVESTIGATION_COMPLETE                       │
│ ├─ Investigation findings: APPROVED                        │
│ └─ Recommended settlement: $2,400 (actual billed amount)   │
│                                                             │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ PHASE 4: APPROVAL (T1:20 - 1 hour 20 minutes)              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ Stage: ClaimApproval                                       │
│ Assigned To: Claim Manager (Approval Queue)                │
│ Status: Pending Approval                                   │
│                                                             │
│ Decision Rule Applied: ApprovalLimits                       │
│                                                             │
│ Decision Tree:                                             │
│ ├─ IF claim_amount < $1,000                                │
│ │  THEN auto_approve (no manual review needed)             │
│ ├─ ELSE IF claim_amount < $5,000 AND fraud_risk = LOW      │
│ │  THEN manager_approve (single approval)                  │
│ └─ ELSE IF claim_amount >= $5,000                          │
│    THEN director_approve (requires director sign-off)      │
│                                                             │
│ Decision Path for This Claim:                              │
│ ├─ Claim amount: $2,400                                    │
│ ├─ Fraud risk: LOW                                         │
│ ├─ Route: Manager Approval                                 │
│ └─ Approver: Claims Manager (Automatic Assignment)         │
│                                                             │
│ Manager: Mike Davis                                        │
│ ├─ Review Time: 2025-12-20 10:15                           │
│ ├─ Decision: APPROVED                                      │
│ ├─ Signature: M.Davis                                      │
│ ├─ Comments: "All documentation verified, within limits,   │
│ │             proceed to settlement"                        │
│ └─ Approval Date: 2025-12-20 10:20                         │
│                                                             │
│ Status Update: APPROVED                                    │
│ ├─ Approval Amount: $2,400                                 │
│ ├─ Coverage %: 100%                                        │
│ ├─ Deductible Applied: $0 (already met)                   │
│ └─ Settlement Amount: $2,400                               │
│                                                             │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ PHASE 5: SETTLEMENT (T1:30 - 1 hour 30 minutes)            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ Stage: PaymentProcessing                                   │
│ Assigned To: Payments Department                           │
│ Status: Processing Payment                                 │
│                                                             │
│ Settlement Actions:                                        │
│                                                             │
│ [Step 1] Create Payment Order                              │
│ ├─ Payee: Hospital (Provider)                              │
│ ├─ Amount: $2,400                                          │
│ ├─ Method: Direct Bank Transfer                            │
│ ├─ Priority: Standard (2-3 business days)                  │
│ └─ Reference: Claim WC-CL-2025-001234                      │
│                                                             │
│ [Step 2] Process Payment [PARALLEL]                        │
│ ├─ Branch A: Generate Invoice                              │
│ │  └─ InvoiceID: INV-2025-56789                            │
│ │                                                          │
│ ├─ Branch B: Update Accounting System                      │
│ │  ├─ Debit: Claims Expense Account                        │
│ │  ├─ Credit: Bank Account                                 │
│ │  └─ Amount: $2,400                                       │
│ │                                                          │
│ └─ Branch C: Notify Provider                               │
│    ├─ Send: Payment notification email                     │
│    ├─ Include: Payment amount, reference #                 │
│    └─ ETA: 2-3 business days                               │
│                                                             │
│ [Step 3] Update Policy Records                             │
│ ├─ Record: $2,400 paid out                                 │
│ ├─ YTD Claims: Now $2,400                                  │
│ ├─ Remaining Deductible: $0 (met for year)                │
│ └─ Next Cycle: Reset on 2026-01-01                         │
│                                                             │
│ Status Update: PAYMENT_SUBMITTED                            │
│ ├─ Payment Status: PENDING                                 │
│ ├─ Expected Delivery: 2025-12-23                           │
│ └─ Confirmation: Sent to provider                          │
│                                                             │
│ [Step 4] Notify Customer [Async]                           │
│ ├─ Send Email: Settlement confirmation                     │
│ ├─ Content:                                                │
│ │  ├─ "Your claim has been approved"                      │
│ │  ├─ "Settlement Amount: $2,400"                          │
│ │  ├─ "Payment Status: Processing"                         │
│ │  ├─ "Expected Receipt: Dec 23"                           │
│ │  └─ "Case Ref: WC-CL-2025-001234"                       │
│ └─ Portal: Update customer dashboard                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ PHASE 6: CLOSURE (T5:00 - 5 days later, Dec 25)            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ Event: Payment Confirmed Received                          │
│ ├─ Date: 2025-12-23                                        │
│ ├─ Confirmation from: Provider system                      │
│ └─ Amount received: $2,400                                 │
│                                                             │
│ Automatic Closure Actions:                                 │
│                                                             │
│ [Step 1] Mark Payment Complete                             │
│ ├─ Status: PAYMENT_RECEIVED                                │
│ ├─ Actual Payment Date: 2025-12-23                         │
│ └─ Days to Payment: 3 days (within SLA of 5)               │
│                                                             │
│ [Step 2] Generate Claim Summary                            │
│ ├─ Total Claim Amount: $2,500                              │
│ ├─ Approved Amount: $2,400                                 │
│ ├─ Deductible Applied: $0                                  │
│ ├─ Final Settlement: $2,400                                │
│ ├─ Adjustment: -$100 (actual cost vs billed)               │
│ └─ Processing Time: 3 days, 15 hours                       │
│                                                             │
│ [Step 3] Archive Case                                      │
│ ├─ Status: CLOSED                                          │
│ ├─ Closure Reason: SETTLED                                 │
│ ├─ Closed Date: 2025-12-25                                 │
│ ├─ Closed By: System (Auto-closure)                        │
│ └─ Archive Location: Claim Repository                      │
│                                                             │
│ [Step 4] Capture Metrics                                   │
│ ├─ Cycle Time: 3.6 days (fast, within SLA)                │
│ ├─ Cost: $2,400 (as predicted)                             │
│ ├─ Customer Satisfaction: Pending (survey will be sent)    │
│ ├─ Touchpoints: 4 (validation, investigation, approval,    │
│ │              payment)                                     │
│ └─ First Contact Resolution: Yes                           │
│                                                             │
│ [Step 5] Send Final Notification                           │
│ ├─ To: Customer (john@email.com)                           │
│ ├─ Subject: "Your Claim is Closed"                         │
│ ├─ Content:                                                │
│ │  ├─ "Claim approved and settled"                        │
│ │  ├─ "Amount paid: $2,400"                                │
│ │  ├─ "Payment received: Dec 23"                           │
│ │  ├─ "Questions? Contact us..."                           │
│ │  └─ "Please rate your experience"                        │
│ └─ Include: Case summary PDF                               │
│                                                             │
│ Final Status: CLOSED                                       │
│ ├─ Case ID: WC-CL-2025-001234                             │
│ ├─ Closure Type: Successful Settlement                     │
│ ├─ Archive: December 25, 2025                              │
│ └─ Archived Duration: Indefinite (for audit trail)         │
│                                                             │
└─────────────────────────────────────────────────────────────┘

CASE METRICS SUMMARY:

Start Date: 2025-12-20 09:00
End Date: 2025-12-25 14:00 (Closure)

Timeline Breakdown:
├─ Phase 1 (Initiation): 0 minutes (immediate)
├─ Phase 2 (Validation): 30 minutes
├─ Phase 3 (Investigation): 20 minutes
├─ Phase 4 (Approval): 10 minutes
├─ Phase 5 (Settlement): 3 days
└─ Phase 6 (Closure): 2 days

Total Cycle Time: 5 days, 5 hours

Performance vs SLA:
├─ Response Deadline: 7 days ✓ EXCEEDED (closed in 5 days)
├─ Investigation Time: 2 hours ✓ WITHIN (target: 4 hours)
├─ Approval Time: 10 minutes ✓ WITHIN (target: 24 hours)
├─ Payment Processing: 3 days ✓ WITHIN (target: 5 days)
└─ Overall: ABOVE TARGET PERFORMANCE

Cost Analysis:
├─ Claim Amount: $2,500
├─ Settlement: $2,400
├─ Savings: $100 (4% reduction)
└─ Processing Cost: Approx $75 (labor, systems)

Customer Journey Touchpoints:
├─ T0: Online submission (self-service) ← Customer
├─ T1: Validation complete (automated email) → Customer
├─ T2: Under investigation (status check portal) ← Customer
├─ T3: Approved! (notification) → Customer
├─ T4: Payment processed (confirmation) → Customer
├─ T5: Claim closed (final summary + survey) → Customer
└─ Satisfaction Rating: 5/5 (fast, transparent, resolved)
```

---

## Workflow & Process Design

### Activity Definition

**What is an Activity?**

An Activity is a **reusable unit of work** that:
- Executes logic (validation, calculation)
- Calls services
- Updates data
- Performs transformations

**Activity Structure**:

```
Activity: CalculateOrderTotal
├── Input Parameters
│   ├── order_id
│   └── items[]
├── Output Parameters
│   ├── subtotal
│   ├── tax
│   └── total
├── Steps
│   ├── 1. Validate order exists
│   ├── 2. Calculate subtotal
│   ├── 3. Calculate tax
│   ├── 4. Calculate total
│   └── 5. Return results
└── Error Handling
    ├── If order not found: Throw error
    └── If calculation fails: Return default
```

### Example 1: Email Validation Activity

**Scenario**: Validate customer email before saving to database

```
Activity: ValidateCustomerEmail

Purpose: Check if email is valid and not already registered

Input Parameters:
├── email (string, required)
└── customer_id (string, optional - for update scenarios)

Output Parameters:
├── is_valid (boolean)
├── error_message (string)
└── status (Valid, Invalid, AlreadyUsed)

Step Configuration:

Step 1: Check Email Format
┌─ Type: Decision
├─ Condition: email MATCHES pattern "^[\w\.-]+@[\w\.-]+\.\w+$"
├─ If True: Go to Step 2
└─ If False: Set status = "Invalid", error_message = "Invalid email format"

Step 2: Check for Duplicates in Database
┌─ Type: Database Query
├─ Query: SELECT COUNT(*) FROM CUSTOMERS WHERE email = ?
├─ Parameter: email
└─ Result → duplicate_count

Step 3: Check Results
┌─ Type: Decision
├─ Condition: duplicate_count > 0 AND customer_id NOT PROVIDED
├─ If True: Set status = "AlreadyUsed", error_message = "Email already registered"
├─ If False: Set status = "Valid", is_valid = true
└─ Go to Step 4

Step 4: Return Results
┌─ Type: Return
├─ Return status and error_message
└─ Exit Activity

Example Execution:

Input:
{
  "email": "john.smith@example.com",
  "customer_id": null
}

Execution Flow:
Step 1: Format validation → ✓ PASS (matches pattern)
Step 2: Database query → Count = 0 (no duplicates found)
Step 3: Check results → duplicate_count is 0, status = "Valid"
Step 4: Return output

Output:
{
  "is_valid": true,
  "status": "Valid",
  "error_message": null
}

Example Execution 2 (Failure):

Input:
{
  "email": "invalid-email",
  "customer_id": null
}

Execution Flow:
Step 1: Format validation → ✗ FAIL (missing @)
Step 3: Set status = "Invalid", error_message = "Invalid email format"
Step 4: Return output

Output:
{
  "is_valid": false,
  "status": "Invalid",
  "error_message": "Invalid email format"
}
```

### Example 2: Calculate Discount Activity

**Scenario**: Calculate customer discount based on loyalty and order value

```
Activity: CalculateOrderDiscount

Purpose: Determine discount percentage and amount

Input Parameters:
├── order_total (decimal, required)
├── customer_loyalty_tier (string: Bronze, Silver, Gold, Platinum)
├── promo_code (string, optional)
└── is_seasonal_sale (boolean, optional)

Output Parameters:
├── discount_percentage (decimal)
├── discount_amount (decimal)
├── final_total (decimal)
└── discount_reason (string)

Step Configuration:

Step 1: Get Base Discount from Loyalty Tier
┌─ Type: Decision Table
├─ Input: customer_loyalty_tier
├─ Table: LoyaltyDiscountTable
│
│ ┌────────────┬──────────────────┐
│ │ Tier       │ Base Discount %  │
│ ├────────────┼──────────────────┤
│ │ Bronze     │ 5%               │
│ │ Silver     │ 10%              │
│ │ Gold       │ 15%              │
│ │ Platinum   │ 20%              │
│ └────────────┴──────────────────┘
│
└─ Result → base_discount_percent

Step 2: Check Seasonal Sale
┌─ Type: Conditional
├─ IF is_seasonal_sale = true
│  THEN seasonal_bonus = 5%
│  ELSE seasonal_bonus = 0%
└─ Result → seasonal_bonus

Step 3: Validate and Apply Promo Code
┌─ Type: Service Call
├─ Service: ValidatePromoCode
├─ Input: promo_code
├─ Output: promo_discount_percent, is_valid
│
└─ IF is_valid = true
   THEN promo_discount = promo_discount_percent
   ELSE promo_discount = 0%

Step 4: Calculate Total Discount (Stack them)
┌─ Type: Java Script
├─ total_discount = base_discount_percent 
│                  + seasonal_bonus 
│                  + promo_discount
│
├─ IF total_discount > 30%  // Cap at 30%
│  THEN discount_percentage = 30%
│  ELSE discount_percentage = total_discount
│
└─ Result → discount_percentage

Step 5: Calculate Amounts
┌─ Type: Arithmetic
├─ discount_amount = order_total * (discount_percentage / 100)
├─ final_total = order_total - discount_amount
└─ Result → discount_amount, final_total

Step 6: Set Discount Reason (for audit)
┌─ Type: Text Construction
├─ reason = "Loyalty: " + base_discount_percent + "% + "
│           "Seasonal: " + seasonal_bonus + "% + "
│           "Promo: " + promo_discount + "%"
└─ Result → discount_reason

Step 7: Return Results
┌─ Type: Return
└─ Return all output parameters

Example Execution 1:

Input:
{
  "order_total": 100.00,
  "customer_loyalty_tier": "Gold",
  "promo_code": "SAVE10",
  "is_seasonal_sale": true
}

Execution:
Step 1: Gold loyalty → base_discount = 15%
Step 2: Seasonal sale active → seasonal_bonus = 5%
Step 3: Promo code valid → promo_discount = 10%
Step 4: Total = 15% + 5% + 10% = 30% (no cap needed)
Step 5: discount_amount = 100 * 0.30 = $30
        final_total = 100 - 30 = $70
Step 6: reason = "Loyalty: 15% + Seasonal: 5% + Promo: 10%"
Step 7: Return results

Output:
{
  "discount_percentage": 30,
  "discount_amount": 30.00,
  "final_total": 70.00,
  "discount_reason": "Loyalty: 15% + Seasonal: 5% + Promo: 10%"
}

Example Execution 2:

Input:
{
  "order_total": 50.00,
  "customer_loyalty_tier": "Bronze",
  "promo_code": "INVALID",
  "is_seasonal_sale": false
}

Execution:
Step 1: Bronze loyalty → base_discount = 5%
Step 2: No seasonal sale → seasonal_bonus = 0%
Step 3: Invalid promo code → promo_discount = 0%
Step 4: Total = 5% + 0% + 0% = 5%
Step 5: discount_amount = 50 * 0.05 = $2.50
        final_total = 50 - 2.50 = $47.50
Step 6: reason = "Loyalty: 5% + Seasonal: 0% + Promo: 0%"
Step 7: Return results

Output:
{
  "discount_percentage": 5,
  "discount_amount": 2.50,
  "final_total": 47.50,
  "discount_reason": "Loyalty: 5% + Seasonal: 0% + Promo: 0%"
}
```

### Step Types

**1. Service Call Step**
```
Call: GetCustomerCreditLimit
Input: customer_id → 12345
Output: credit_limit → local variable
```

**2. Decision Step**
```
Decision: CheckCreditApproval
IF available_credit > order_total
  THEN path = "Approved"
  ELSE path = "Review"
```

**3. Java Step**
```
Execute Java Code:
java.util.Date today = new java.util.Date();
pyWorkPage.put("current_time", today);
```

**4. Data Mapper Step**
```
Map data from source to target:
source.account_number → target.account_id
source.customer_name → target.full_name
```

### Control Flow

```
SEQUENCE (Steps run one after another)
└─ Step1 → Step2 → Step3

PARALLEL (Steps run simultaneously)
├─ Step1
├─ Step2
└─ Step3

CONDITIONAL
IF condition THEN Step1 ELSE Step2

LOOP
WHILE condition
  └─ Step

EXCEPTION HANDLING
TRY
  └─ Steps
CATCH Error
  └─ Error handling steps
```

### Example 5: Order Processing Flow

**Scenario**: Complete order processing with parallel checks and conditional routing

```
Main Flow: ProcessCustomerOrder

Purpose: Handle order from submission to fulfillment

Input:
├── order_id: string
├── customer_id: string
├── items: Item[] (product_id, quantity, price)
└── delivery_address: Address

Flow Diagram:

START (Order Received)
  ↓
[Step 1] Validate Order Data
  ├─ Type: Activity Call
  ├─ Activity: ValidateOrderData
  ├─ Check: All fields present and valid
  └─ On Error: Stop and notify customer
  ↓
[Step 2] Check Inventory Availability [PARALLEL BLOCK]
  ├─ Type: Parallel Split
  ├─ Branches:
  │  ├─ Branch A: Check Stock for Each Item
  │  │  └─ Activity: CheckInventory(item_id, quantity)
  │  ├─ Branch B: Get Current Pricing
  │  │  └─ Service: GetPricingService(item_ids)
  │  └─ Branch C: Check Warehouse Location
  │     └─ Service: FindNearestWarehouse(delivery_zip)
  └─ Wait for: ALL branches to complete
  ↓
[Step 3] Decision: All Items In Stock?
  ├─ Type: Decision
  ├─ IF all_items_in_stock = true
  │  THEN continue to Step 4
  │  ELSE continue to Step 6 (Backorder handling)
  └─ Join: All parallel branches rejoin
  ↓
[Step 4] Calculate Order Total (In-Stock Path)
  ├─ Type: Activity Call
  ├─ Activity: CalculateOrderTotal
  │  ├─ Calculate subtotal from items
  │  ├─ Apply discounts via CalculateOrderDiscount
  │  ├─ Calculate tax
  │  └─ Calculate final total
  ├─ Inputs: items[], customer_loyalty_tier, promo_code
  └─ Output: final_total, tax_amount, discount_details
  ↓
[Step 5] Process Payment [CONDITIONAL]
  ├─ Type: Conditional Sub-Flow
  ├─ Decision: payment_method
  │
  ├─ IF payment_method = "CreditCard"
  │  THEN Call: ProcessCreditCardPayment
  │       └─ Service: PaymentGateway/ChargeCard
  │
  ├─ ELSE IF payment_method = "BankTransfer"
  │  THEN Call: CreateBankTransfer
  │       └─ Service: BankingSystem/InitiateTransfer
  │
  └─ ELSE IF payment_method = "PayLater"
     THEN Call: SetupPaymentPlan
          └─ Activity: CreatePaymentPlan
  ↓
[Step 5a] Decision: Payment Successful?
  ├─ Type: Decision
  ├─ IF payment_status = "Approved"
  │  THEN continue to Step 7
  │  ELSE continue to Step 8 (Payment Failed)
  └─ Exit Condition: Stop if payment fails
  ↓
[Step 7] Create Fulfillment Order
  ├─ Type: Activity Call
  ├─ Activity: CreateFulfillmentOrder
  │  ├─ Generate fulfillment_id
  │  ├─ Add picking instructions
  │  ├─ Route to warehouse
  │  └─ Set delivery address
  └─ Create new child case: Work-Fulfillment
  ↓
[Step 8] Update Inventory
  ├─ Type: Activity Call
  ├─ Activity: UpdateInventorySystem
  │  ├─ Decrement quantities
  │  ├─ Mark reserved items
  │  └─ Update warehouse stock
  └─ Service: InventorySystem/UpdateStock
  ↓
[Step 9] Send Confirmation Email [PARALLEL]
  ├─ Type: Parallel Block
  ├─ Branches:
  │  ├─ Branch A: SendOrderConfirmation
  │  │  ├─ To: customer_email
  │  │  ├─ Template: OrderConfirmation
  │  │  └─ Data: order_id, items, total, tracking_info
  │  ├─ Branch B: SendWarehouseNotification
  │  │  ├─ To: warehouse_email
  │  │  ├─ Template: PickAndShip
  │  │  └─ Data: items, fulfillment_id, destination
  │  └─ Branch C: UpdateCRM
  │     ├─ Record: Customer interaction
  │     └─ Field: last_order_date, ltv_update
  └─ Wait for: At least 2 to succeed (resilience)
  ↓
COMPLETE - Order Successfully Processed
  ├─ Set status = "Processing"
  ├─ Milestone: Set delivery_by_date
  └─ EXIT

ERROR PATHS:

[Step 6] Backorder Path (Items Not in Stock)
├─ Decision: Accept Backorder?
├─ IF customer_accepts_backorder = true
│  THEN:
│  ├─ Create backorder reservation
│  ├─ Notify customer of delay
│  ├─ Go to Step 5 (Process payment)
│  └─ Set delivery_date = warehouse_restock_date
│
└─ ELSE:
   ├─ Cancel order
   ├─ Notify customer
   └─ EXIT (Cancelled)

[Step 8] Payment Failed Path
├─ Decision: Retry or Cancel?
├─ IF retry_count < 3
│  THEN:
│  ├─ Attempt payment again
│  ├─ Wait 5 seconds
│  └─ Go back to Step 5
│
└─ ELSE:
   ├─ Send payment failure notification
   ├─ Release reservation
   ├─ Cancel order
   ├─ Set status = "Payment Failed"
   └─ EXIT

Performance Characteristics:

Sequential Steps: 1-9 must run in order
├─ Step 1: 0.5 seconds (validation)
├─ Step 2: 2-3 seconds (parallel, takes longest branch)
├─ Step 4: 1 second (calculation)
├─ Step 5: 3-5 seconds (payment processing)
├─ Step 7-8: 1 second (order creation)
├─ Step 9: 2 seconds (parallel, asynchronous)
└─ Total: ~10-12 seconds end-to-end

Parallel Optimization:
├─ Without parallelization: Step 2 would take 8 seconds
│  (3 sequential service calls)
├─ With parallelization: Step 2 takes 3 seconds
│  (longest branch runs concurrently)
└─ Savings: 5 seconds per order (42% reduction)

Example Execution (Happy Path):

Timeline:
T0:00  → Order Received (WC-123456)
T0:01  → [Step 1] Validation: PASS
T0:02  → [Step 2] Parallel checks started
T0:03  → [Step 2] All checks completed
         ├─ Inventory: ✓ All items in stock
         ├─ Pricing: ✓ Updated
         └─ Warehouse: ✓ Found at location 5
T0:04  → [Step 3] Decision: All in stock? YES
T0:05  → [Step 4] Total calculated: $125.99 (after $10 discount)
T0:06  → [Step 5] Payment processing: CreditCard charge
T0:09  → [Step 5a] Payment successful
T0:10  → [Step 7] Fulfillment order created: FO-78901
T0:11  → [Step 8] Inventory updated: -1 laptop, -2 mice
T0:12  → [Step 9] Parallel notifications sent
T0:13  → ORDER COMPLETE
         ├─ Status: Processing
         ├─ Fulfillment ID: FO-78901
         ├─ Delivery by: Dec 23, 2025
         └─ Customer notified

Data Flow Through Steps:

clipboard.order_total
├─ Set by Step 4: CalculateOrderTotal
├─ Used by Step 5: ProcessPayment
├─ Amount charged: $125.99
└─ Confirmed in Step 5a

clipboard.fulfillment_id
├─ Generated by Step 7: CreateFulfillmentOrder
├─ Used by Step 8: UpdateInventorySystem
├─ Communicated in Step 9: Notifications
└─ Stored in case for tracking
```

---

## Data & Objects

### Theory: Data-Driven Design

PEGA organizes data through **Classes** (similar to OOP):

**Class Hierarchy Example**:

```
┌─ Rule-Abstract (Root)
│
├─ Data-Organization (Abstract)
│  ├─ Data-Organization-Bank
│  │  ├─ Data-Organization-Bank-BranchInfo
│  │  └─ Data-Organization-Bank-Accounts
│  └─ Data-Organization-Retail
│
└─ Work- (Concrete case types)
   ├─ Work-Mortgage (Mortgage applications)
   │  ├─ Work-Mortgage-Purchase
   │  └─ Work-Mortgage-Refinance
   └─ Work-Banking (Banking cases)
      └─ Work-Banking-AccountOpen
```

### Properties & Attributes

**Property Definition**:

```
Property: customer_email
├── Type: Text
├── Length: 255
├── Usage: External (accessible via API)
├── Rules: Index=Yes, Required=Yes
└── Description: Customer's email address

Property: order_total
├── Type: Decimal
├── Decimal Places: 2
├── Usage: Internal
├── Calculate Using: Declarative rule
└── Description: Total order amount
```

### Data Sources

**1. Relational Database**
- Traditional SQL tables
- Primary storage for persistent data
- Example: Customer records

**2. Clipboard (Memory)**
- Temporary storage during case execution
- Lost when case ends
- Fast access, used for processing

**3. External Systems**
- Data sourced via API calls
- Real-time integration
- Example: Credit score lookup

**4. Work Objects**
- PEGA's native storage
- Built-in versioning and audit trail
- Example: Case history

---

## User Interface & Channels

### Theory: Multi-Channel Customer Engagement

PEGA supports multiple channels:

```
┌─────────────────────────────────────────┐
│     Business Rules & Logic              │
└─────┬───────┬────────┬────────┬────────┘
      │       │        │        │
    ┌─▼─┐  ┌─▼─┐   ┌──▼──┐  ┌─▼──┐
    │Web│  │IVR│   │Mobile│ │Chat│
    │UI │  │   │   │ App  │ │Bot │
    └───┘  └───┘   └──────┘  └────┘
```

### Portal Architecture

**Portal** = Collection of sections and components

```
Portal: CustomerPortal
├── Header
│   ├── Logo
│   └── Navigation bar
├── Section: Dashboard
│   ├── Active Cases widget
│   ├── Recent Transactions widget
│   └── Alerts widget
├── Section: My Cases
│   ├── Mortgage Applications
│   ├── Loan Requests
│   └── Support Tickets
└── Footer
    ├── Help links
    └── Contact info
```

### Harness (Form) Design

**Harness** = Collection of sections, layouts, and controls

```
Harness: MortgageApplication
├── Layout: Header
│   └── Control: Title "New Mortgage Application"
│
├── Layout: Application Details
│   ├── Section: PersonalInfo
│   │   ├── TextInput: First Name
│   │   ├── TextInput: Last Name
│   │   └── DatePicker: Date of Birth
│   └── Section: ContactInfo
│       ├── TextInput: Email
│       └── TextInput: Phone
│
├── Layout: Buttons
│   ├── Button: Submit (action = "SubmitApplication")
│   └── Button: Cancel (action = "CancelApplication")
│
└── Rules Applied:
    ├── Validation on submit
    ├── Auto-save every 30 seconds
    └── Display errors inline
```

---

## Integration & Connectors

### Theory: System of Systems

PEGA acts as a **central hub** integrating with external systems:

```
                    PEGA
                      │
        ┌─────────────┼─────────────┐
        │             │             │
      CRM         ERP           Bank
    Salesforce  SAP           Core
    ↕ REST      ↕ SOAP        ↕ SFTP
```

### Connector Types

**1. REST Connector**
```
Target: /api/customers/{customerId}
Method: GET
Response: JSON
{
  "id": "12345",
  "name": "John Smith",
  "email": "john@example.com"
}
```

**2. SOAP Connector**
```
Service: CreditScoreService
Operation: GetCreditScore
Input: customer_id
Output: credit_score, risk_level
```

**3. Database Connector**
```
Database: Oracle
Table: CUSTOMERS
Query: SELECT * FROM CUSTOMERS WHERE ID = ?
```

**4. File Connector**
```
Type: SFTP
Server: sftp.bank.com
Path: /outgoing/transactions/
Action: Read .csv files
```

### Integration Patterns

**Synchronous Pattern**:
```
PEGA → Call Service → Wait for Response → Continue
└─ Used for: Real-time decisions, data lookup
```

**Asynchronous Pattern**:
```
PEGA → Queue Message → Continue
External System → Process → Callback → Update PEGA
└─ Used for: Long-running processes, notifications
```

### Example 6: REST API Integration - Credit Score Lookup

**Scenario**: Call external credit bureau API to get credit score

```
Service: GetCustomerCreditScore

Configuration:

Connector Type: REST
├── Endpoint: https://creditbureau-api.com/v1/customers/{customerId}/score
├── Method: GET
├── Authentication: OAuth2 Bearer Token
├── Timeout: 5 seconds
├── Retry: 3 attempts with 1 second backoff
└── Cache: 24 hours

Request Mapping:

Input Parameters:
├── customer_id (required) → URL Path: /customers/{customerId}/score
├── request_type (optional) → Query: ?type=full
└── include_history (optional) → Query: ?history=true

Request Headers:
├── Authorization: Bearer {{oauth_token}}
├── Content-Type: application/json
├── X-Request-ID: {{guid()}}  (for tracing)
└── X-Timestamp: {{now()}}

Response Mapping:

Success Response (HTTP 200):
├── Parse JSON response
├── Map fields:
│  ├── response.score → credit_score
│  ├── response.risk_level → risk_category
│  ├── response.last_update → score_date
│  ├── response.history[] → credit_history
│  └── response.factors[] → contributing_factors
└── Store in clipboard for next steps

Error Handling:

HTTP 400 (Bad Request):
├── Reason: Invalid customer_id format
├── Action: Set credit_score = 0, error = "Invalid customer"
└── Path: Route to manual review

HTTP 404 (Not Found):
├── Reason: Customer doesn't exist in credit bureau
├── Action: Set credit_score = null, new_customer = true
└── Path: Apply default rules for new customers

HTTP 429 (Rate Limited):
├── Reason: API rate limit exceeded
├── Action: Wait {{rate_limit_reset}} seconds
└── Retry: Automatic retry after wait

HTTP 500 (Server Error):
├── Reason: Credit bureau system error
├── Action: Fallback to cached score if available
├── Fallback: Use score from 24 hours ago
└── Escalate: Create alert for operations team

Connection Timeout:
├── Reason: API not responding within 5 seconds
├── Action: Retry up to 3 times
├── Final failure: Use customer's last known score
└── Log: Create incident for investigation

Step-by-Step Execution:

Step 1: Prepare Request
├── Extract customer_id from case data
├── Get fresh OAuth token
├── Generate unique request ID
└── Set timeout = 5000 ms

Step 2: Send HTTP Request
├── POST to REST endpoint
├── Include headers and authentication
├── Body: (none for GET request)
└── Example:
    GET /v1/customers/CUST-12345/score?type=full&history=true
    Headers: Authorization: Bearer eyJhbGciOi...

Step 3: Wait for Response
├── Timeout: 5 seconds max
├── On timeout: Retry logic activates
└── Monitor: Log response time

Step 4: Process Success (HTTP 200)
├── Parse response JSON
├── Validate response schema
├── Extract data fields
└── Store in clipboard:
    {
      "credit_score": 720,
      "risk_level": "LOW",
      "score_date": "2025-12-20",
      "factors": ["Payment History: Excellent", "Utilization: 25%"],
      "last_updated": "2025-12-20T10:30:00Z"
    }

Step 5: Store Results
├── Create property: customer_credit_score = 720
├── Create property: credit_risk = "LOW"
├── Create property: credit_bureau_response_time = 450ms
└── Mark: score_retrieved_at = now()

Step 6: Next Step Decision
├── IF credit_score >= 700
│  THEN continue to "Automated Approval" flow
├── ELSE IF credit_score >= 600
│  THEN continue to "Manual Review" flow
└── ELSE
   THEN continue to "Escalation" flow

Example Execution - Success:

Timeline:
T0:00 → GET request sent
        URL: /v1/customers/CUST-12345/score?type=full
        Headers: Auth + X-Request-ID: 550e8400-e29b-41d4-a716-446655440000

T0:00.450 → Response received (450ms)
HTTP 200 OK

Response Body:
{
  "customerId": "CUST-12345",
  "score": 750,
  "riskLevel": "LOW",
  "scoreDate": "2025-12-20",
  "contributingFactors": [
    "Payment History: Excellent (95% on-time)",
    "Credit Utilization: 25%",
    "Account Age: 8 years",
    "Inquiry Count: 1 (last 12 months)"
  ],
  "lastUpdated": "2025-12-20T14:30:00Z"
}

Processing:
T0:00.455 → Response parsed successfully
T0:00.460 → Data mapped to clipboard
            credit_score = 750
            risk_category = "LOW"
            score_updated = "2025-12-20"

T0:00.465 → Decision logic applied
            credit_score (750) >= 700 → Approved path
            Continue to SubmitApplicationForProcessing

Result: SUCCESS
├── Response Time: 450ms
├── Status: DATA_RETRIEVED
├── Score: 750 (Excellent)
└── Next Step: Automated Approval

Example Execution - Timeout & Retry:

Timeline:
T0:00 → GET request sent (Attempt 1)
T0:05 → TIMEOUT (5 seconds exceeded)
        Action: Retry with backoff

T0:06 → GET request sent (Attempt 2)
T0:07.200 → Response received
HTTP 200 OK (same data as above)

Processing:
├── Retry attempt: 2/3
├── Response time: 1200ms (including retry delay)
├── Data retrieved: Successfully
└── Continue normally

Result: SUCCESS (with retry)
├── Total Response Time: 1200ms
├── Attempts: 2
├── Final Score: 750
└── Note: Slower than ideal, monitor API performance

Example Execution - API Error (HTTP 404):

Timeline:
T0:00 → GET request sent
T0:00.350 → Response received
HTTP 404 Not Found

Response Body:
{
  "error": "Customer not found",
  "message": "No customer record found for CUST-99999",
  "timestamp": "2025-12-20T14:35:00Z"
}

Processing:
T0:00.355 → Error detected: HTTP 404
T0:00.360 → Error handler: Not found
            Action: Set credit_score = null
            Flag: new_customer = true
            Reason: "Customer not in credit bureau"

T0:00.365 → Decision: New customer flow
            Apply default rules:
            ├── credit_score_assumeb = 650 (neutral)
            ├── require_additional_verification = true
            └── Path: ManualReviewForNewCustomer

Result: HANDLED_GRACEFULLY
├── Response: 404 (Customer not found)
├── Fallback: Apply new customer rules
├── Score: 650 (default)
└── Next Step: Manual Review with verification
```

---

## Analytics & Reporting

### Theory: Data-Driven Insights

PEGA captures **operational intelligence** automatically:

```
┌─────────────────────────────────┐
│ Operational Intelligence        │
├─────────────────────────────────┤
│ Process Metrics                 │
│ ├── Cycle time per stage        │
│ ├── Throughput by user          │
│ └── Queue depth by workgroup    │
│                                 │
│ Case Metrics                    │
│ ├── Cases by status             │
│ ├── SLA breaches                │
│ └── Escalations                 │
│                                 │
│ System Metrics                  │
│ ├── Server response time        │
│ ├── Database query duration     │
│ └── API call failures           │
└─────────────────────────────────┘
```

### Analytics Schema (pxInsightsData)

PEGA stores data in **Analytics Database**:

```
Table: pxInsightsData
├── Columns
│   ├── CaseID
│   ├── CaseType
│   ├── Status
│   ├── CurrentStage
│   ├── AssignedTo
│   ├── CreatedTime
│   ├── ResolvedTime
│   ├── CycleDays
│   ├── Priority
│   └── Outcome
│
└── Sample Data
    ├── WC-12345 | Mortgage | Approved | ... | 3 days
    ├── WC-12346 | Mortgage | Review   | ... | 1 day
    └── WC-12347 | Mortgage | Rejected | ... | 2 days
```

---

## Best Practices & Design Patterns

### Theory: Building Maintainable Systems

**1. Single Responsibility Principle**

Each rule/activity has ONE purpose:

```
✗ Bad Activity: ProcessOrder (does too much)
  ├── Validate order
  ├── Calculate discount
  ├── Update inventory
  ├── Send email
  └── Update accounting

✓ Good Activities:
  ├── ValidateOrder (validation only)
  ├── CalculateOrderDiscount (calculation only)
  ├── UpdateInventory (inventory only)
  ├── SendOrderConfirmation (notification only)
  └── UpdateAccountingSystem (accounting only)
```

**2. Don't Repeat Yourself (DRY)**

Reuse rules and activities:

```
✗ Avoid duplication
├── Activity A: Has validation logic
└── Activity B: Same validation logic copied

✓ Create reusable rule
├── Activity A: Calls ValidateCustomer
└── Activity B: Calls ValidateCustomer
```

**3. Separation of Concerns**

Keep business logic separate:

```
├── UI (Harness) - Just display, no logic
├── Business Rules - All logic here
├── Connectors - Integration only
└── Data Objects - Structure only
```

### Design Patterns

**1. Template Method Pattern**

Base case type defines process skeleton:

```
BaseCase: Work-Application
├── Main flow defined
├── Call abstract methods

DerivedCase: Work-LoanApplication
├── Inherits flow
├── Implements specific methods
```

**2. Strategy Pattern**

Different approval strategies:

```
ApprovalStrategy
├── HighValueApproval (needs director)
├── NormalApproval (needs manager)
└── LowValueApproval (automated)
```

**3. Observer Pattern**

React to case events:

```
Case Event: StatusChanged
Listeners:
├── Update UI
├── Send notification
└── Trigger next stage
```

---

## Practical Examples

### Example 1: Loan Application Process

**Case Type: Work-LoanApplication**

```
Case Properties:
├── applicant_name: string
├── loan_amount: decimal
├── credit_score: integer
├── annual_income: decimal
├── status: (New, Under Review, Approved, Rejected)
└── approval_path: (Automated, Manual Review, Escalated)

Main Flow:
├── Step 1: Validate Application
│   ├── Activity: ValidateLoanApplication
│   ├── Check: All required fields present
│   └── If invalid: Stop and notify applicant
│
├── Step 2: Get Credit Score
│   ├── Service: ExternalCreditService
│   ├── Input: applicant SSN
│   └── Output: credit_score
│
├── Step 3: Apply Decision Rules
│   ├── Decision: DetermineLoanApproval
│   └── Rules:
│       ├── IF credit_score >= 700 AND income >= 50000
│       │   THEN AutoApprove
│       ├── ELSE IF credit_score >= 600 AND income >= 40000
│       │   THEN ManualReview
│       └── ELSE THEN AutoReject
│
├── Step 4: Route Decision
│   ├── IF AutoApprove: Mark approved, Send letter
│   ├── IF ManualReview: Assign to loan officer
│   └── IF AutoReject: Mark rejected, Send denial letter
│
└── Step 5: Complete Case
    ├── Update case status
    ├── Log decision metrics
    └── Archive case
```

### Example 2: Customer Service Case Routing

**Case Type: Work-SupportTicket**

```
Case Properties:
├── ticket_id: auto-generated
├── customer_id: reference
├── issue_category: (Billing, Technical, General)
├── priority: (High, Medium, Low)
├── description: text
├── assigned_to: workgroup
└── status: (Open, In Progress, Resolved, Closed)

Assignment Logic (Routing Rule):

IF issue_category = "Billing"
THEN
  IF priority = "High"
    THEN assign_to = "BillingUrgent"
    ELSE assign_to = "BillingGeneral"

ELSE IF issue_category = "Technical"
THEN
  IF priority = "High"
    THEN assign_to = "TechSupport"
    ELSE assign_to = "TechGeneral"

ELSE
  assign_to = "GeneralSupport"

SLA Configuration:
├── High Priority: 1 hour response, 4 hours resolution
├── Medium Priority: 4 hours response, 1 day resolution
└── Low Priority: 1 day response, 3 days resolution

Escalation:
├── If SLA breached: Escalate to manager
├── If unresolved for 5 days: Escalate to director
└── If customer satisfaction low: Assign to senior agent
```

### Example 3: Multi-Stage Approval Process

**Case Type: Work-ExpenseRequest**

```
Stages:

Stage 1: Submission
├── Actions: Submit expense report
├── Data collected:
│   ├── Expense items (travel, meals, etc.)
│   ├── Receipts
│   ├── Business justification
│   └── Total amount
└── Stage exit: All required info provided

Stage 2: Manager Review
├── Owner: Direct manager
├── Actions:
│   ├── Review details
│   ├── Approve (if < $500)
│   ├── Request info (if unclear)
│   └── Reject (if not business-related)
├── Rules:
│   ├── IF amount < $100: Auto-approve
│   ├── IF amount < $500: Require manager approval
│   └── IF amount >= $500: Require finance approval
└── Stage exit: Manager decision made

Stage 3: Finance Approval (if amount >= $500)
├── Owner: Finance department
├── Actions:
│   ├── Verify policy compliance
│   ├── Approve
│   └── Reject
└── Stage exit: Finance decision made

Stage 4: Processing
├── Actions:
│   ├── Process reimbursement
│   ├── Update accounting
│   └── Send confirmation
└── Stage exit: Payment issued

Stage 5: Closure
├── Archive case
├── Capture metrics
└── Close work item
```

### Example 4: Decision Table Implementation

**Scenario: Insurance Claim Settlement**

```
Decision Table: DetermineClaimSettlement

Conditions:
├── Claim Amount
│   ├── < $1000
│   ├── $1000-$5000
│   └── > $5000
├── Medical Evidence
│   ├── Clear
│   ├── Partial
│   └── Disputed
└── Policy Coverage
    ├── Full (100%)
    ├── Partial (80%)
    └── Excluded (0%)

Decision Matrix:

╔════════════╦════════════╦═══════════╦════════════════════╗
║ Amount     ║ Evidence   ║ Coverage  ║ Decision           ║
╠════════════╬════════════╬═══════════╬════════════════════╣
║ < $1000    ║ Clear      ║ Full      ║ Auto-Approve       ║
║ < $1000    ║ Any        ║ Excluded  ║ Auto-Deny          ║
║ $1-5K      ║ Clear      ║ Full      ║ Approve (80%)      ║
║ $1-5K      ║ Partial    ║ Full      ║ Manual Review      ║
║ $1-5K      ║ Disputed   ║ Full      ║ Escalate           ║
║ > $5000    ║ Any        ║ Full      ║ Expert Review      ║
║ > $5000    ║ Any        ║ Partial   ║ Escalate           ║
║ Any        ║ Any        ║ Excluded  ║ Auto-Deny          ║
╚════════════╩════════════╩═══════════╩════════════════════╝

Settlement Amount Calculation:
claim_settlement = claim_amount * coverage_percentage

Example:
- Claim: $3000
- Evidence: Clear
- Coverage: 80%
- Decision: Approve
- Settlement: $3000 * 0.80 = $2400
```

---

## PEGA vs Other Platforms

### Comparison Matrix

```
┌──────────────┬──────────────┬──────────────┬──────────────┐
│ Aspect       │ PEGA         │ Blue Prism   │ UiPath       │
├──────────────┼──────────────┼──────────────┼──────────────┤
│ Type         │ BPM/CRM      │ RPA          │ RPA          │
│ Learning     │ Steep curve  │ Medium       │ Easy         │
│ Cost         │ High         │ Medium       │ Medium       │
│ Scalability  │ Enterprise   │ Good         │ Good         │
│ Maintenance  │ Low (rules)  │ Medium       │ Medium       │
│ Use Case     │ Core process │ Legacy apps  │ Repetitive   │
└──────────────┴──────────────┴──────────────┴──────────────┘
```

---

## Key Takeaways

**PEGA Strengths**:
✓ Built-in scalability and performance
✓ Low-code declarative approach
✓ Excellent for complex business logic
✓ Strong change management
✓ Multi-channel capability

**PEGA Challenges**:
✗ Steep learning curve
✗ Higher licensing costs
✗ Requires platform expertise
✗ Not ideal for simple apps

**When to Use PEGA**:
- Enterprise-scale applications
- Complex workflow automation
- Multi-channel customer engagement
- High transaction volumes
- Regulatory compliance requirements
- Long-term strategic applications

---

## Important Questions & Answers

### PEGA Fundamentals

**Q1: What's the difference between a Work Object and a Data Object?**

A: 
- **Work Object**: Represents business processes (cases, requests)
  - Has lifecycle (created → active → resolved → closed)
  - Tracks through stages and assignments
  - Customer-facing (visible in portal)
  - Example: Work-LoanApplication
  
- **Data Object**: Stores reference data
  - No lifecycle or workflow
  - Shared lookup information
  - Not visible in portal
  - Example: Data-Customer, Data-Product

```
Work Object: "My Loan Application #12345" (unique per case)
    ├─ Status: Approved
    ├─ Stage: Documentation
    └─ Assignee: Sarah Johnson

Data Object: "Interest Rate Tables" (shared reference)
    ├─ Rate for 5-year: 4.5%
    ├─ Rate for 10-year: 5.2%
    └─ Effective date: Jan 1, 2025
```

**Q2: When should I use an Activity vs. a Flow?**

A:
- **Activity**: Reusable procedure (like a function)
  - Small, specific task
  - Takes inputs, returns outputs
  - Called from multiple places
  - Example: ValidateEmail, CalculateDiscount
  
- **Flow**: Orchestrates the overall process (like a main program)
  - Complex sequences
  - Multiple branches
  - Handles assignments and stages
  - Example: LoanApprovalFlow, OrderProcessingFlow

```
Use Activity when: Need reusable logic piece
├─ Validation
├─ Calculation
├─ Transformation
└─ External call (API, DB)

Use Flow when: Need to orchestrate entire process
├─ Multiple stages
├─ Assignments/routing
├─ Complex branching
└─ Case lifecycle management
```

**Q3: What's a Case vs. a Stage?**

A:
- **Case**: The entire work item (e.g., loan application)
  - Unique ID
  - Full lifecycle
  - May contain multiple stages
  - Example: Case-12345
  
- **Stage**: A logical phase within a case
  - Sequential or parallel
  - Multiple tasks/assignments
  - Can loop back
  - Example: Stage-Initial-Review → Stage-Documentation → Stage-Approval

```
Case: LoanApplication-12345
├─ Stage 1: Initial Review (Days 1-2)
│  ├─ Validation activity
│  └─ Assign to processor
├─ Stage 2: Documentation (Days 3-5)
│  ├─ Request documents
│  └─ Verify submissions
└─ Stage 3: Approval (Days 6-7)
   ├─ Credit check
   └─ Manager approval
```

**Q4: How do I choose between a Decision Table vs. a Decision Tree vs. a Map?**

A:
- **Decision Table**: Structured, many conditions, simple output
  - Many if-conditions with single output
  - Matrix format
  - Example: Discount calculation based on volume + customer type
  
- **Decision Tree**: Complex branches, different paths
  - Nested if-else logic
  - Different outputs for different paths
  - Example: Loan eligibility (yes/no/pending review)
  
- **Map**: Convert input to output
  - Mapping existing data
  - Simple transformations
  - Example: Convert state abbreviations to full names

```
Use Decision Table for:
├─ Multiple conditions → single output
├─ Discount tiers
└─ Pricing matrices

Use Decision Tree for:
├─ Complex branching
├─ Different outcomes per path
└─ Eligibility decisions

Use Map for:
├─ Simple conversions
├─ Lookup tables
└─ Value transformations
```

### Process Design

**Q5: How should I structure my case hierarchy?**

A:
- Create a parent case (abstract)
- Create child cases (specific implementations)
- Each child inherits parent logic
- Override only what's different

```
Work-Case (Parent)
├─ Common properties
├─ Shared rules
└─ Standard procedures

├─ Work-Application (Intermediate)
│  ├─ Application logic
│  └─ Shared by all applications
│  
│  ├─ Work-LoanApplication (Child)
│  │  └─ Loan-specific logic
│  │
│  └─ Work-CreditCardApplication (Child)
│     └─ Card-specific logic
```

**Q6: What's the best way to handle errors and exceptions?**

A:
- Use Try-Catch steps in flows
- Log errors to database
- Notify team via correspondence
- Provide user-friendly messages
- Create escalation rules

```
Flow Error Handling:

Try Block:
├─ API call to credit agency
├─ Database update
└─ Validation step

Catch Block (if error):
├─ Log error details
├─ Increment retry counter
├─ Send alert email
└─ Escalate if retries exceeded

Finally Block:
└─ Clean up resources
```

**Q7: How do I prevent duplicate work?**

A:
- Check for existing cases before creating new
- Use unique identifiers (SSN, account number)
- Implement deduplication rules
- Set up monitoring/alerts

```
Pre-Creation Check:

Incoming Request:
├─ SSN: 123-45-6789
├─ Check database: "Existing case found?"
│  ├─ YES → Link to existing case
│  └─ NO → Create new case
└─ Prevent duplicates ✓
```

### Performance & Optimization

**Q8: How do I optimize case loading performance?**

A:
- Use pagination for lists
- Lazy-load related data
- Cache frequently accessed data
- Create indexes on search fields
- Archive old cases

```
Performance Tips:

1. Don't load all cases at once
   ├─ Load 50 per page
   └─ User clicks "Next" for more

2. Cache common lookups
   ├─ Customer data
   ├─ Product catalog
   └─ Reference tables

3. Archive old cases
   ├─ Move closed cases to archive DB
   ├─ Keep active cases fast
   └─ Historical reports from archive

Performance Impact:
├─ Load time: 2 seconds → 200ms (10x faster)
└─ Database load: Reduced 70%
```

**Q9: What's the impact of using too many connectors?**

A:

Risks of excessive connectors:

```
❌ Multiple sync calls
├─ Slow overall process
├─ Timeout risk
└─ System unavailability

❌ Complex error handling
├─ Hard to debug
├─ Multiple failure points
└─ User frustration

❌ Data consistency issues
├─ Partial updates
├─ Rollback complexity
└─ Data misalignment
```

Best practice:

```
✓ Batch connectors when possible
✓ Run long-running connectors async
✓ Use queue systems for heavy loads
✓ Cache results locally

Example:
├─ Get customer (1 connector)
├─ Get customer accounts (1 connector)
├─ Get transactions (1 connector) = 3 total
✓ GOOD - reasonable

vs

├─ Get customer (connector)
├─ Get account1 (connector)
├─ Get account2 (connector)
├─ Get account3 (connector)
├─ Get transaction1 (connector)
├─ Get transaction2 (connector)
├─ Get transaction3 (connector) = 7 total
❌ TOO MANY - refactor
```

### Data & Properties

**Q10: When should I create a new property vs. use an existing one?**

A:

Create new property when:
```
✓ Different data type needed
✓ Different validation rules
✓ Different business meaning
✓ Separate audit tracking needed

Example:
ApplicantAge (calculated from birthdate)
vs
DeclaredAge (user-provided, different)
→ Two properties, different purposes
```

Reuse existing property when:
```
✓ Same data type
✓ Same meaning
✓ Same validation
✓ Same reporting needs

Example:
Address for work
vs
Address for personal
→ Both use AddressType with different instances
```

**Q11: Should I store calculated values or recalculate each time?**

A:

Use Declarative Rules (auto-calculate):
```
✓ Age (changes yearly)
✓ Account balance (changes frequently)
✓ Eligibility status (changes with rules)
→ Always current, no stale data
```

Store calculated value when:
```
✓ Historical snapshot needed
  Example: "Approved with rate 4.5%"
  (Even if current rate is 5.2%)

✓ Expensive calculation
  Example: Credit score from agency
  (Cache for 24 hours)

✓ Regulatory requirement
  Example: "Decision made on [date]"
  (Immutable record)
```

### Rules & Logic

**Q12: How do I debug a complex rule that's not working?**

A:

Debugging techniques:

```
1. Trace logs
   ├─ Enable debug logging
   ├─ Review step-by-step execution
   └─ Find where it fails

2. Breakpoints
   ├─ Set breakpoint in rule
   ├─ Run case in debug mode
   └─ Inspect variables

3. Test data
   ├─ Create known test case
   ├─ Walk through manually
   └─ Verify at each step

4. Rule simulator
   ├─ Test decision table
   ├─ Feed sample data
   └─ Check output

5. Audit trail
   ├─ Check case history
   ├─ See what changed and when
   └─ Who made changes
```

**Q13: When should I use Circumstance Rules?**

A:

Circumstance Rules for:
```
✓ Multiple versions of same rule
✓ Different logic for different contexts
✓ Time-based variations
✓ Configuration-based logic

Examples:

Discount rules:
├─ Standard discount (Volume < 100)
├─ Bulk discount (Volume > 1000)
├─ VIP discount (Customer = Gold)
└─ Seasonal discount (Holiday season)

Shipping rules:
├─ Standard shipping (Domestic)
├─ Express shipping (Premium customer)
├─ International shipping (Overseas)
└─ Free shipping (High-value order)

Each circumstance version:
├─ Has different logic
├─ Triggered by conditions
└─ Evaluated in priority order
```

### Integration

**Q14: How do I handle API timeouts?**

A:

Timeout strategy:

```
1. Set reasonable timeout (not too short)
   ├─ REST API: 30 seconds
   ├─ Database: 10 seconds
   └─ Legacy system: 60 seconds

2. Implement retry logic
   ├─ Retry 3 times
   ├─ Exponential backoff (1s, 2s, 4s)
   └─ Stop if still failing

3. Fallback options
   ├─ Use cached data
   ├─ Use default value
   └─ Manual intervention

4. Notify users
   ├─ Show meaningful error
   ├─ Provide next steps
   └─ Don't show technical details
```

**Q15: Should I use synchronous or asynchronous connectors?**

A:

Use **Synchronous** (wait for response):
```
✓ User waiting for result
✓ Short process (seconds)
✓ Critical data needed immediately
✓ Error handling required right away

Example: Validate credit card
├─ User submitting form
├─ Need immediate yes/no
└─ Hold up process if fails
```

Use **Asynchronous** (don't wait):
```
✓ Long-running process
✓ Background work
✓ User doesn't need immediate result
✓ Timeout risk with sync

Example: Send email to customer
├─ Don't hold up case for email
├─ Process in background
├─ Continue case workflow
└─ Notify when complete
```

### Best Practices

**Q16: What's the best way to structure a large application?**

A:

Modular organization:

```
Work-Application (Base)
└─ Work-Module1 (Cohesive feature)
   ├─ Rules for feature
   ├─ Flows for feature
   └─ Data for feature
└─ Work-Module2 (Different feature)
   ├─ Rules for feature
   ├─ Flows for feature
   └─ Data for feature

Benefits:
✓ Easy to find related code
✓ Reuse across applications
✓ Team can work in parallel
✓ Easier to test and debug
```

**Q17: How do I keep data clean and consistent?**

A:

Data governance:

```
1. Validation Rules
   ├─ Email must have @
   ├─ Phone must be 10 digits
   └─ Amount must be positive

2. Master Data
   ├─ Single source of truth
   ├─ Prevent duplicates
   └─ Regular syncing

3. Data Quality Checks
   ├─ Regular audits
   ├─ Identify anomalies
   └─ Correct proactively

4. Audit Trail
   ├─ Track all changes
   ├─ Know who changed what
   └─ Compliance ready
```

**Q18: When should I use Flows with Assignments vs. Automated Flows?**

A:

**Human Workflow** (with assignments):
```
✓ Needs human judgment
✓ Complex decisions
✓ Regulatory requirement
✓ Customer interaction

Example: Loan approval
├─ Requires manager review
├─ Manual documentation check
├─ Customer conversation
└─ Final approval signature
```

**Automated Flow** (no assignments):
```
✓ Routine processing
✓ Clear rules
✓ No human judgment needed
✓ Speed critical

Example: Order processing
├─ Check inventory (auto)
├─ Calculate shipping (auto)
├─ Process payment (auto)
├─ Generate confirmation (auto)
└─ Only escalate on errors
```

### Common Mistakes

**Q19: What's the most common mistake in PEGA development?**

A:

**Mistake: Storing too much in Work Objects**

```
❌ WRONG - All data in one case
Work-LoanApplication
├─ Applicant info
├─ Co-applicant info
├─ Address history (5 entries)
├─ Employment history (10 entries)
├─ Bank account list (20 entries)
└─ Property appraisals (10 entries)
→ Massive work object, slow queries

✓ RIGHT - Separate related objects
Work-LoanApplication (main)
├─ Core application data
└─ Links to related objects

Work-Applicant (person)
├─ Personal info
└─ Linked to application

Data-Address (addresses)
├─ Address history
└─ Linked to applicant

Data-Employment (employment)
├─ Job history
└─ Linked to applicant
```

**Q20: What happens if I hardcode values instead of using properties?**

A:

```
❌ WRONG - Hardcoded values
Activity: CalculateDiscount
    taxRate = 0.08  (hardcoded)
    discount = 0.15 (hardcoded)
    
Problem:
├─ Change tax rate? Must edit code
├─ Can't override per region
├─ No audit trail of changes
└─ Breaks reusability

✓ RIGHT - Use properties/parameters
Activity: CalculateDiscount
    taxRate = .OrganizationSettings.TaxRate
    discount = .DiscountTier.Percentage
    
Benefits:
├─ Change via admin settings
├─ Can override per context
├─ Audit changes
└─ Reusable across applications
```

**Q21: How do I avoid infinite loops in flows?**

A:

```
❌ WRONG - Infinite loop
Flow: ProcessApplication
    Loop → ReviewApplication
    If (not approved)
        → Go back to ProcessApplication
        → Goes to Loop
        → Goes to ReviewApplication again
        → If (still not approved)
            → Loop forever!

✓ RIGHT - Loop with counter
Flow: ProcessApplication
    counter = 0
    Loop:
        counter = counter + 1
        If (counter > 3)
            → Send to manager
            → Break
        If (approved)
            → Break
        Else:
            → Loop

Or use Stage with iteration limit:
Stage Configuration:
├─ Max iterations: 3
├─ After 3 tries: escalate
└─ Prevents infinite loops
```

**Q22: What if my connector fails during process?**

A:

```
❌ WRONG - No error handling
Flow: ApproveApplication
    Call ExternalAPI
    Update case status = "Approved"
    
What if API fails silently?
├─ Case appears approved
├─ Payment actually failed
├─ Customer gets no service
└─ Inconsistent data

✓ RIGHT - Proper error handling
Flow: ApproveApplication
    Try:
        response = Call ExternalAPI
        If (response.success)
            Update case status = "Approved"
        Else:
            Log error
            Escalate to team
    Catch (Timeout):
        Retry up to 3 times
        Then escalate
    Catch (APIDown):
        Queue for later
        Send customer message
```

### Advanced Topics

**Q23: How do I implement a complex approval workflow?**

A:

```
Multi-level approval process:

Work-ProcurementRequest (main case)
│
├─ Stage 1: Department Manager Approval
│  ├─ Assign to manager
│  ├─ Manager reviews (>$5K: needs approval)
│  └─ Approve or Reject
│
├─ Stage 2: Finance Director Approval
│  ├─ If (amount > $50K): route to director
│  ├─ Assign to director
│  └─ Approve or Reject
│
├─ Stage 3: Executive Approval
│  ├─ If (amount > $500K): route to exec
│  ├─ Assign to C-suite
│  └─ Approve or Reject
│
└─ Stage 4: Process Order
   ├─ Create PO
   ├─ Send to vendor
   └─ Complete

Decision Points:
Amount ≤ $5K → Auto-approve (skip approval)
$5K < Amount ≤ $50K → Manager only
$50K < Amount ≤ $500K → Manager + Director
Amount > $500K → All three levels
```

**Q24: How do I handle parallel processing?**

A:

```
Parallel Case Processing:

Work-InsuranceClaim

Stage: Claim Investigation (Parallel)
├─ Task 1: Medical Review (assigned to doctor)
├─ Task 2: Police Report Check (assigned to investigator)
├─ Task 3: Damage Assessment (assigned to adjuster)
└─ All 3 run simultaneously

Converge: When all complete
    Combine results
    → Calculate settlement
    → Move to next stage

Benefits:
✓ Process faster (parallel vs sequential)
✓ Utilize multiple teams
✓ Reduce total time

Risks:
❌ Complex coordination
❌ Hard to debug
❌ Data consistency issues (manage carefully)
```

**Q25: What's the best way to migrate data between systems?**

A:

```
Data Migration Strategy:

Phase 1: Preparation
├─ Audit source data
├─ Identify required fields
├─ Map source to target
└─ Create staging area

Phase 2: Transformation
├─ Extract source data
├─ Transform format
├─ Validate accuracy
└─ Store in staging

Phase 3: Validation
├─ Sample check (100 records)
├─ Compare with source
├─ Fix discrepancies
└─ Full data validation

Phase 4: Load
├─ Disable constraints (temporarily)
├─ Load in batches (avoid timeout)
├─ Enable constraints
└─ Post-load validation

Phase 5: Verification
├─ Run data quality checks
├─ Compare counts
├─ Audit sample
└─ Go-live ready
```

### Performance & Troubleshooting

**Q26: How do I monitor application health?**

A:

```
Monitoring Dashboard:

Real-time Metrics:
├─ Cases created today: 456
├─ Cases closed today: 389
├─ Average processing time: 4.2 hours
├─ On-time completion: 94%
├─ SLA breaches: 23 (5%)
└─ System uptime: 99.8%

Performance Metrics:
├─ Page load time: 1.2 seconds
├─ API response time: 250ms
├─ Database query time: 180ms
└─ Connector success rate: 99.2%

Error Tracking:
├─ Top errors: (1) Payment API timeout (45%)
├─ (2) Invalid email format (23%)
├─ (3) Database connection loss (12%)
├─ (4) Other (20%)

Alerts (automated):
├─ If error rate > 5%: Alert team
├─ If response time > 2s: Alert team
├─ If SLA breach > 10%: Alert team
└─ If uptime < 99%: Page on-call engineer
```

**Q27: What should I do if the system is running slow?**

A:

```
Troubleshooting Steps:

1. Identify bottleneck
   ├─ Check database CPU: High?
   ├─ Check network latency: High?
   ├─ Check application logs: Errors?
   └─ Check cache hit ratio: Low?

2. Database issues
   ├─ Missing indexes? → Add indexes
   ├─ Slow queries? → Optimize
   ├─ Too many queries? → Cache
   ├─ Large result sets? → Paginate
   └─ Lock contention? → Partition data

3. Application issues
   ├─ Inefficient loops? → Optimize
   ├─ Multiple connectors? → Batch/async
   ├─ Memory leak? → Find and fix
   └─ Cache not working? → Enable/check

4. Infrastructure
   ├─ Low memory? → Add RAM
   ├─ High CPU? → Scale horizontally
   ├─ Disk I/O? → Faster storage
   └─ Network saturated? → Optimize traffic

5. Verify fix
   ├─ Response time improved?
   ├─ User complaints gone?
   └─ Metrics show improvement?
```

**Q28: How do I handle high-volume loads?**

A:

```
Scalability Strategy:

For 10x volume increase:

1. Database
   ├─ Horizontal partitioning (by customer)
   ├─ Read replicas for queries
   ├─ Write to primary
   ├─ Archive old data
   └─ Expected improvement: 5-10x

2. Application
   ├─ Horizontal scaling (multiple instances)
   ├─ Load balancing across instances
   ├─ Cache common queries
   ├─ Async processing for heavy tasks
   └─ Expected improvement: 3-5x

3. Connectors
   ├─ Batch external calls
   ├─ Queue long-running tasks
   ├─ Rate limiting for APIs
   └─ Expected improvement: 2-3x

4. Users
   ├─ Distribute sessions
   ├─ Limit concurrent users per instance
   ├─ Queue if overloaded
   └─ Better UX

Overall system can handle:
└─ 10-50x volume with proper scaling
```

---

## Resources

- [Pegasystems Official Documentation](https://www.pega.com/docs)
- [PEGA Learning Academy](https://academy.pega.com)
- [PEGA Community Forums](https://community.pega.com)
- [PEGA Best Practices](https://www.pega.com/resources)
- [PEGA Certification Paths](https://www.pega.com/training-certifications)

---

**Last Updated**: December 2025
**Version**: 1.0
**Scope**: Enterprise BPM Platform Overview
**Contents**: 11 chapters, comprehensive theory, practical examples
