package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class InventoryManagementApplication {

	public static void main(String[] args) {
		SpringApplication.run(InventoryManagementApplication.class, args);
	}

}
package com.example.demo.config;

import com.example.demo.jwt.JwtAuthenticationFilter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Autowired
    private JwtAuthenticationFilter jwtAuthenticationFilter;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            // Disable CSRF for REST API
            .csrf(csrf -> csrf.disable())
            
            // ✅ ENABLE CORS with proper configuration
            .cors(cors -> cors.configurationSource(corsConfigurationSource()))
            
            // Configure authorization
            .authorizeHttpRequests(auth -> auth
                // Public endpoints (no authentication required)
                .requestMatchers("/api/auth/login", "/api/auth/register").permitAll()
                .requestMatchers("/error").permitAll()  // ✅ Allow error endpoint
                
                // ✅ OPTION 1: Admin-only endpoints (more secure)
                // Uncomment these if you want only ADMINs to manage users
                // .requestMatchers("/api/auth/users/**").hasRole("ADMIN")
                
                // ✅ OPTION 2: Allow all authenticated users (easier for development)
                // Any logged-in user can view/manage users
                .requestMatchers("/api/auth/users/**").authenticated()
                .requestMatchers("/api/auth/profile/**").authenticated()
                .requestMatchers("/api/products/**").authenticated()
                .requestMatchers("/api/sales/**").authenticated()
                
                // All other requests need authentication
                .anyRequest().authenticated()
            )
            
            // Stateless session
            .sessionManagement(session -> 
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            
            // Add JWT filter
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        
        // Allow requests from React frontend
        configuration.setAllowedOrigins(Arrays.asList("http://localhost:3000"));
        
        // Allow all HTTP methods
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"));
        
        // Allow all headers including Authorization
        configuration.setAllowedHeaders(Arrays.asList("*"));
        
        // Allow credentials (cookies, authorization headers)
        configuration.setAllowCredentials(true);
        
        // Cache preflight response for 1 hour
        configuration.setMaxAge(3600L);
        
        // Expose Authorization header to frontend
        configuration.setExposedHeaders(Arrays.asList("Authorization"));
        
        // Apply CORS configuration to all paths
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        
        return source;
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}



package com.example.demo.controller;

import com.example.demo.user.User;
import com.example.demo.user.Role;
import com.example.demo.repo.Rolerepository;
import com.example.demo.repo.UserRepository;

import com.example.demo.jwt.JwtUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

import java.util.*;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/auth")
@CrossOrigin(origins = "http://localhost:3000")
public class AuthController {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private Rolerepository roleRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Autowired
    private JwtUtil jwtUtil;

    // ============================================
    // LOGIN
    // ============================================
    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody LoginRequest loginRequest) {
        try {
            Optional<User> userOpt = userRepository.findByEmail(loginRequest.getEmail());
            
            if (userOpt.isEmpty()) {
                return ResponseEntity.status(401)
                    .body(Collections.singletonMap("message", "Invalid credentials"));
            }

            User user = userOpt.get();
            
            if (!passwordEncoder.matches(loginRequest.getPassword(), user.getPassword())) {
                return ResponseEntity.status(401)
                    .body(Collections.singletonMap("message", "Invalid credentials"));
            }

            String token = jwtUtil.generateToken(user.getEmail());
            
            Map<String, Object> response = new HashMap<>();
            response.put("token", token);
            response.put("email", user.getEmail());
            response.put("firstName", user.getFirstName());
            response.put("lastName", user.getLastName());

            System.out.println("Login successful for user: " + user.getEmail());
            
            return ResponseEntity.ok(response);

        } catch (Exception e) {
            e.printStackTrace();
            return ResponseEntity.status(500)
                .body(Collections.singletonMap("message", "Login error: " + e.getMessage()));
        }
    }

    // ============================================
    // REGISTER
    // ============================================
    @PostMapping("/register")
    public ResponseEntity<?> register(@RequestBody User user) {
        try {
            if (userRepository.findByEmail(user.getEmail()).isPresent()) {
                return ResponseEntity.badRequest()
                    .body(Collections.singletonMap("message", "Email already exists"));
            }

            user.setPassword(passwordEncoder.encode(user.getPassword()));

            // Find or create ROLE_USER
            Role userRole = roleRepository.findByName("ROLE_USER")
                .orElseGet(() -> {
                    Role newRole = new Role();
                    newRole.setName("ROLE_USER");
                    return roleRepository.save(newRole);
                });

            Set<Role> roles = new HashSet<>();
            roles.add(userRole);
            user.setRoles(roles);

            User savedUser = userRepository.save(user);

            return ResponseEntity.ok(Collections.singletonMap("message", "User registered successfully"));

        } catch (Exception e) {
            e.printStackTrace();
            return ResponseEntity.status(500)
                .body(Collections.singletonMap("message", "Error registering user: " + e.getMessage()));
        }
    }

    // ============================================
    // GET ALL USERS (without passwords)
    // ============================================
    @GetMapping("/users")
    public ResponseEntity<?> getAllUsers() {
        try {
            System.out.println("=== GET ALL USERS ===");
            Authentication auth = SecurityContextHolder.getContext().getAuthentication();
            System.out.println("Authenticated user: " + (auth != null ? auth.getName() : "null"));
            
            List<User> users = userRepository.findAll();
            System.out.println("Found " + users.size() + " users in database");
            
            // Create user DTOs without passwords
            List<Map<String, Object>> userDTOs = users.stream().map(user -> {
                Map<String, Object> dto = new HashMap<>();
                dto.put("id", user.getId());
                dto.put("email", user.getEmail());
                dto.put("firstName", user.getFirstName());
                dto.put("lastName", user.getLastName());
                // Get role names
                if (user.getRoles() != null && !user.getRoles().isEmpty()) {
                    String role = user.getRoles().iterator().next().getName();
                    dto.put("role", role.replace("ROLE_", ""));
                } else {
                    dto.put("role", "USER");
                }
                return dto;
            }).collect(Collectors.toList());

            System.out.println("Returning " + userDTOs.size() + " users");
            return ResponseEntity.ok(userDTOs);

        } catch (Exception e) {
            System.err.println("ERROR in getAllUsers: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(500)
                .body(Collections.singletonMap("message", "Error fetching users: " + e.getMessage()));
        }
    }

    // ============================================
    // CREATE USER
    // ============================================
    @PostMapping("/users")
    public ResponseEntity<?> createUser(@RequestBody User user) {
        try {
            System.out.println("Creating user: " + user.getEmail());
            
            if (userRepository.findByEmail(user.getEmail()).isPresent()) {
                return ResponseEntity.badRequest()
                    .body(Collections.singletonMap("message", "Email already exists"));
            }

            user.setPassword(passwordEncoder.encode(user.getPassword()));

            // Find or create ROLE_USER
            Role userRole = roleRepository.findByName("ROLE_USER")
                .orElseGet(() -> {
                    Role newRole = new Role();
                    newRole.setName("ROLE_USER");
                    return roleRepository.save(newRole);
                });

            Set<Role> roles = new HashSet<>();
            roles.add(userRole);
            user.setRoles(roles);

            User savedUser = userRepository.save(user);
            System.out.println("User created successfully: " + savedUser.getEmail());

            // Return DTO without password
            Map<String, Object> dto = new HashMap<>();
            dto.put("id", savedUser.getId());
            dto.put("email", savedUser.getEmail());
            dto.put("firstName", savedUser.getFirstName());
            dto.put("lastName", savedUser.getLastName());
            dto.put("role", "USER");

            return ResponseEntity.ok(dto);

        } catch (Exception e) {
            System.err.println("ERROR in createUser: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(500)
                .body(Collections.singletonMap("message", "Error creating user: " + e.getMessage()));
        }
    }

    // ============================================
    // UPDATE USER
    // ============================================
    @PutMapping("/users/{id}")
    public ResponseEntity<?> updateUser(@PathVariable Long id, @RequestBody User userData) {
        try {
            Optional<User> userOpt = userRepository.findById(id);
            
            if (userOpt.isEmpty()) {
                return ResponseEntity.status(404)
                    .body(Collections.singletonMap("message", "User not found"));
            }

            User user = userOpt.get();
            user.setFirstName(userData.getFirstName());
            user.setLastName(userData.getLastName());
            user.setEmail(userData.getEmail());

            if (userData.getPassword() != null && !userData.getPassword().isEmpty()) {
                user.setPassword(passwordEncoder.encode(userData.getPassword()));
            }

            userRepository.save(user);
            
            return ResponseEntity.ok(Collections.singletonMap("message", "User updated successfully"));

        } catch (Exception e) {
            e.printStackTrace();
            return ResponseEntity.status(500)
                .body(Collections.singletonMap("message", "Error updating user: " + e.getMessage()));
        }
    }

    // ============================================
    // DELETE USER
    // ============================================
    @DeleteMapping("/users/{id}")
    public ResponseEntity<?> deleteUser(@PathVariable Long id) {
        try {
            if (!userRepository.existsById(id)) {
                return ResponseEntity.status(404)
                    .body(Collections.singletonMap("message", "User not found"));
            }

            userRepository.deleteById(id);
            return ResponseEntity.ok(Collections.singletonMap("message", "User deleted successfully"));

        } catch (Exception e) {
            e.printStackTrace();
            return ResponseEntity.status(500)
                .body(Collections.singletonMap("message", "Error deleting user: " + e.getMessage()));
        }
    }

    // ============================================
    // GET PROFILE
    // ============================================
    @GetMapping("/profile")
    public ResponseEntity<?> getProfile() {
        try {
            Authentication auth = SecurityContextHolder.getContext().getAuthentication();
            String email = auth.getName();

            Optional<User> userOpt = userRepository.findByEmail(email);
            
            if (userOpt.isEmpty()) {
                return ResponseEntity.status(404)
                    .body(Collections.singletonMap("message", "User not found"));
            }

            User user = userOpt.get();
            
            Map<String, Object> profile = new HashMap<>();
            profile.put("email", user.getEmail());
            profile.put("firstName", user.getFirstName());
            profile.put("lastName", user.getLastName());

            return ResponseEntity.ok(profile);

        } catch (Exception e) {
            e.printStackTrace();
            return ResponseEntity.status(500)
                .body(Collections.singletonMap("message", "Error fetching profile: " + e.getMessage()));
        }
    }

    // ============================================
    // UPDATE PROFILE
    // ============================================
    @PutMapping("/profile")
    public ResponseEntity<?> updateProfile(@RequestBody Map<String, String> updates) {
        try {
            Authentication auth = SecurityContextHolder.getContext().getAuthentication();
            String email = auth.getName();

            Optional<User> userOpt = userRepository.findByEmail(email);
            
            if (userOpt.isEmpty()) {
                return ResponseEntity.status(404)
                    .body(Collections.singletonMap("message", "User not found"));
            }

            User user = userOpt.get();
            user.setFirstName(updates.get("firstName"));
            user.setLastName(updates.get("lastName"));

            userRepository.save(user);
            
            return ResponseEntity.ok(Collections.singletonMap("message", "Profile updated successfully"));

        } catch (Exception e) {
            e.printStackTrace();
            return ResponseEntity.status(500)
                .body(Collections.singletonMap("message", "Error updating profile: " + e.getMessage()));
        }
    }
}

// ============================================
// DTO CLASSES
// ============================================

class LoginRequest {
    private String email;
    private String password;
    
    public LoginRequest() {}
    
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
}



package com.example.demo.controller;


import com.example.demo.service.ProductService;
import com.example.demo.user.Product;

import org.springframework.http.*;
import org.springframework.web.bind.annotation.*;
import org.springframework.beans.factory.annotation.Autowired;
 
import java.util.List;
 
@RestController
@RequestMapping("/api/products")
@CrossOrigin(origins = "http://localhost:3000") // Add CORS support
public class ProductController {
    @Autowired
    private ProductService productService;
 
    @GetMapping
    public ResponseEntity<List<Product>> all() {
        return ResponseEntity.ok(productService.findAll());
    }
 
    @GetMapping("/{id}")
    public ResponseEntity<Product> get(@PathVariable Long id) {
        Product p = productService.findById(id);
        return p == null ? ResponseEntity.notFound().build() : ResponseEntity.ok(p);
    }
 
    @PostMapping
    public ResponseEntity<Product> create(@RequestBody Product product) {
        Product saved = productService.save(product);
        return ResponseEntity.status(HttpStatus.CREATED).body(saved);
    }
 
    @PutMapping("/{id}")
    public ResponseEntity<Product> update(@PathVariable Long id, @RequestBody Product product) {
        Product existing = productService.findById(id);
        if (existing == null) return ResponseEntity.notFound().build();
 
        existing.setName(product.getName());
        existing.setDescription(product.getDescription());
        existing.setManufacturer(product.getManufacturer());
        existing.setPrice(product.getPrice());
        existing.setQuantity(product.getQuantity());
 
        productService.save(existing);
        return ResponseEntity.ok(existing);
    }
 
    @DeleteMapping("/{id}")
    public ResponseEntity<?> delete(@PathVariable Long id) {
        Product existing = productService.findById(id);
        if (existing == null) return ResponseEntity.notFound().build();
        productService.deleteById(id);
        return ResponseEntity.noContent().build();
    }
}


package com.example.demo.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import com.example.demo.repo.SalesRepository;
import com.example.demo.user.Sales;

import java.util.Collections;
import java.util.List;

@RestController
@RequestMapping("/api/sales")
@CrossOrigin(origins = "http://localhost:3000")
public class SalesController {

    @Autowired
    private SalesRepository salesRepo;

    // Get all sales data
    @GetMapping
    public ResponseEntity<List<Sales>> getAllSales() {
        List<Sales> sales = salesRepo.findAll();
        return ResponseEntity.ok(sales);
    }

    // Create new sales entry
    @PostMapping
    public ResponseEntity<?> createSales(@RequestBody Sales sales) {
        try {
            Sales saved = salesRepo.save(sales);
            return ResponseEntity.ok(saved);
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                    .body(Collections.singletonMap("message", "Failed to create sales data"));
        }
    }

    
 // Update sales entry with revenue
    @PutMapping("/{id}")
    public ResponseEntity<?> updateSales(@PathVariable Long id, @RequestBody Sales salesData) {
        try {
            Sales sales = salesRepo.findById(id)
                    .orElseThrow(() -> new RuntimeException("Sales data not found"));
            
            sales.setName(salesData.getName());
            sales.setSales(salesData.getSales());
            if (salesData.getRevenue() != null) {
                sales.setRevenue(salesData.getRevenue());
            }
            
            salesRepo.save(sales);
            return ResponseEntity.ok(Collections.singletonMap("message", "Sales data updated successfully"));
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                    .body(Collections.singletonMap("message", "Failed to update sales data"));
        }
    }
    // Delete sales entry
    @DeleteMapping("/{id}")
    public ResponseEntity<?> deleteSales(@PathVariable Long id) {
        try {
            if (!salesRepo.existsById(id)) {
                return ResponseEntity.status(404)
                        .body(Collections.singletonMap("message", "Sales data not found"));
            }
            salesRepo.deleteById(id);
            return ResponseEntity.ok(Collections.singletonMap("message", "Sales data deleted successfully"));
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                    .body(Collections.singletonMap("message", "Failed to delete sales data"));
        }
    }
}



package com.example.demo.DTO;
 
public class JwtResponse {
    private String token;
    private String type = "Bearer";
    private String email;
 
    // Default constructor
    public JwtResponse() {}
 
    // Constructor with all fields
    public JwtResponse(String token, String type, String email) {
        this.token = token;
        this.type = type;
        this.email = email;
    }
 
    // Constructor without type (uses default "Bearer")
    public JwtResponse(String token, String email) {
        this.token = token;
        this.type = "Bearer";
        this.email = email;
    }
 
    // Getters and setters
    public String getToken() { return token; }
    public void setToken(String token) { this.token = token; }
    
    public String getType() { return type; }
    public void setType(String type) { this.type = type; }
    
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
}


package com.example.demo.DTO;
 
public class LoginRequest {
    private String email;
    private String password;
 
    public LoginRequest() {}
    
    public LoginRequest(String email, String password) {
        this.email = email;
        this.password = password;
    }
 
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    
    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
} 




package com.example.demo.DTO;

public class ProfileDTO {
    private String firstName;
    private String lastName;
    private String email;

    // Constructors
    public ProfileDTO() {}

    public ProfileDTO(String firstName, String lastName, String email) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.email = email;
    }

    // Getters and Setters
    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }
}



package com.example.demo.DTO;
 
public class RegisterRequest {
    private String email;
    private String password;
    private String firstName;
    private String lastName;
 
    public RegisterRequest() {}
    
    public RegisterRequest(String email, String password, String firstName, String lastName) {
        this.email = email;
        this.password = password;
        this.firstName = firstName;
        this.lastName = lastName;
    }
 
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    
    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
    
    public String getFirstName() { return firstName; }
    public void setFirstName(String firstName) { this.firstName = firstName; }
    
    public String getLastName() { return lastName; }
    public void setLastName(String lastName) { this.lastName = lastName; }
}



package com.example.demo.jwt;

import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

import com.example.demo.repo.Rolerepository;
import com.example.demo.user.Role;

@Component
public class DataInitializer implements CommandLineRunner {
 
    private final Rolerepository roleRepository;
 
    public DataInitializer(Rolerepository roleRepository) {
        this.roleRepository = roleRepository;
    }
 
    @Override
    public void run(String... args) throws Exception {
        if (roleRepository.findByName("ROLE_USER").isEmpty()) {
            Role userRole = new Role();
            userRole.setName("ROLE_USER");
            roleRepository.save(userRole);
        }
        if (roleRepository.findByName("ROLE_ADMIN").isEmpty()) {
            Role adminRole = new Role();
            adminRole.setName("ROLE_ADMIN");
            roleRepository.save(adminRole);
        }
    }
}


package com.example.demo.jwt;
 
import com.example.demo.service.CustomUserDetailsService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;
 
import java.io.IOException;
 
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
 
    @Autowired
    private JwtUtil jwtUtil;
 
    @Autowired
    private CustomUserDetailsService userDetailsService;
 
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
            throws ServletException, IOException {
 
        // Skip JWT validation for public endpoints
        String path = request.getRequestURI();
        if (path.equals("/api/auth/login") || path.equals("/api/auth/register")) {
            filterChain.doFilter(request, response);
            return;
        }
        
        String header = request.getHeader("Authorization");
        String username = null;
        String token = null;
 
        if (header != null && header.startsWith("Bearer ")) {
            token = header.substring(7);
            try {
                username = jwtUtil.extractUsername(token);
            } catch (Exception e) {
                System.err.println("JWT extraction error: " + e.getMessage());
            }
        }
 
        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            try {
                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
 
                if (jwtUtil.validateToken(token)) {
                    UsernamePasswordAuthenticationToken auth =
                            new UsernamePasswordAuthenticationToken(
                                    userDetails, null, userDetails.getAuthorities()
                            );
 
                    auth.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                    SecurityContextHolder.getContext().setAuthentication(auth);
                    System.out.println("JWT validated successfully for user: " + username);
                }
            } catch (Exception e) {
                System.err.println("Authentication error: " + e.getMessage());
            }
        }
 
        filterChain.doFilter(request, response);
    }
}




package com.example.demo.jwt;
 
import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
 
import jakarta.annotation.PostConstruct;
import java.security.Key;
import java.util.Date;
 
@Component
public class JwtUtil {
 
    private static final Logger logger = LoggerFactory.getLogger(JwtUtil.class);
 
    // Prefer injecting from application.properties; fallback to default if not set.
    @Value("${app.jwtSecret:MySuperSecretKeyForJWTTokenGenerationInSpringBootApplication12345}")
    private String secret;
 
    @Value("${app.jwtExpirationMs:86400000}")
    private long jwtExpirationMs;
 
    private Key key;
 
    @PostConstruct
    public void init() {
        // create HMAC key from secret bytes
        this.key = Keys.hmacShaKeyFor(secret.getBytes());
    }
 
    public String generateToken(String username) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtExpirationMs);
 
        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(key, SignatureAlgorithm.HS512)
                .compact();
    }
 
    public String extractUsername(String token) {
        try {
            Claims claims = Jwts.parserBuilder()
                    .setSigningKey(key)
                    .build()
                    .parseClaimsJws(token)
                    .getBody();
            return claims.getSubject();
        } catch (JwtException e) {
            logger.error("Error extracting username from token: {}", e.getMessage());
            return null;
        }
    }
 
    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(token);
            logger.debug("Token is valid");
            return true;
        } catch (ExpiredJwtException e) {
            logger.error("JWT token is expired: {}", e.getMessage());
        } catch (UnsupportedJwtException e) {
            logger.error("JWT token is unsupported: {}", e.getMessage());
        } catch (MalformedJwtException e) {
            logger.error("JWT token is malformed: {}", e.getMessage());
        } catch (SecurityException | SignatureException e) {
            logger.error("JWT signature does not match: {}", e.getMessage());
        } catch (IllegalArgumentException e) {
            logger.error("JWT token compact illegal argument: {}", e.getMessage());
        }
        return false;
    }
}


package com.example.demo.repo;

import org.springframework.data.jpa.repository.JpaRepository;

import com.example.demo.user.Product;

import java.util.List;
 
public interface ProductRepository extends JpaRepository<Product, Long> {
    List<Product> findByNameContainingIgnoreCase(String name);
}

package com.example.demo.repo;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.example.demo.user.Role;

import java.util.Optional;

@Repository
public interface Rolerepository extends JpaRepository<Role, Long> {
    Optional<Role> findByName(String name);
}
package com.example.demo.repo;

import org.springframework.data.jpa.repository.JpaRepository;

import com.example.demo.user.Sales;


public interface SalesRepository extends JpaRepository<Sales, Long> {
}



package com.example.demo.repo;
 

import org.springframework.data.jpa.repository.JpaRepository;

import com.example.demo.user.User;

import java.util.Optional;
 
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
    boolean existsByEmail(String email);
}


package com.example.demo.service;
 
import com.example.demo.repo.UserRepository;
import com.example.demo.user.User;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
 
import java.util.stream.Collectors;
 
@Service
public class CustomUserDetailsService implements UserDetailsService {
 
    @Autowired
    private UserRepository userRepo;
 
    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        User user = userRepo.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with email: " + email));
 
        return new org.springframework.security.core.userdetails.User(
                user.getEmail(),
                user.getPassword(),
                user.getRoles().stream()
                        .map(role -> new SimpleGrantedAuthority(role.getName()))
                        .collect(Collectors.toList())
        );
    }
}



 package com.example.demo.service;


import org.springframework.stereotype.Service;

import com.example.demo.repo.ProductRepository;
import com.example.demo.user.Product;

import org.springframework.beans.factory.annotation.Autowired;
 
import java.util.List;
 
@Service
public class ProductService {
    @Autowired
    private ProductRepository productRepo;
 
    public List<Product> findAll() { return productRepo.findAll(); }
    public Product findById(Long id) { return productRepo.findById(id).orElse(null); }
    public Product save(Product p) { return productRepo.save(p); }
    public void deleteById(Long id) { productRepo.deleteById(id); }
}


 package com.example.demo.user;
 
import jakarta.persistence.*;
 
@Entity
@Table(name = "products")
public class Product {
 
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
 
    @Column(nullable = false)
    private String name;
 
    @Column(length = 1000)
    private String description;
 
    private String manufacturer;
    private Double price;
    private Integer quantity;
 
    // Constructors
    public Product() {}
 
    public Product(String name, String description, String manufacturer, Double price, Integer quantity) {
        this.name = name;
        this.description = description;
        this.manufacturer = manufacturer;
        this.price = price;
        this.quantity = quantity;
    }
 
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
 
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
 
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
 
    public String getManufacturer() { return manufacturer; }
    public void setManufacturer(String manufacturer) { this.manufacturer = manufacturer; }
 
    public Double getPrice() { return price; }
    public void setPrice(Double price) { this.price = price; }
 
    public Integer getQuantity() { return quantity; }
    public void setQuantity(Integer quantity) { this.quantity = quantity; }
}


package com.example.demo.user;

import jakarta.persistence.*;

@Entity
@Table(name = "roles")
public class Role {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false, length = 50)
    private String name;

    // Constructors
    public Role() {}

    public Role(String name) {
        this.name = name;
    }

    // Getters and Setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Role{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }
}



package com.example.demo.user;

import jakarta.persistence.*;

@Entity
@Table(name = "sales")
public class Sales {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name; // Month name (Jan, Feb, etc.)
    
    @Column(nullable = false)
    private Integer sales; // Sales amount
    
    @Column
    private Double revenue; // Revenue for this month
    
    // Constructors
    public Sales() {}
    
    public Sales(String name, Integer sales) {
        this.name = name;
        this.sales = sales;
    }
    
    public Sales(String name, Integer sales, Double revenue) {
        this.name = name;
        this.sales = sales;
        this.revenue = revenue;
    }
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public Integer getSales() { return sales; }
    public void setSales(Integer sales) { this.sales = sales; }
    
    public Double getRevenue() { return revenue; }
    public void setRevenue(Double revenue) { this.revenue = revenue; }
}

package com.example.demo.user;
 
import jakarta.persistence.*;
import java.util.HashSet;
import java.util.Set;
 
@Entity
@Table(name = "users")
public class User {
 
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
 
    @Column(unique = true, nullable = false)
    private String email;
 
    @Column(nullable = false)
    private String password;
 
    private String firstName;
    private String lastName;
 
    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(
        name = "user_roles",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    private Set<Role> roles = new HashSet<>();
 
    // Constructors
    public User() {}
 
    public User(String email, String password, String firstName, String lastName) {
        this.email = email;
        this.password = password;
        this.firstName = firstName;
        this.lastName = lastName;
    }
 
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
 
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
 
    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
 
    public String getFirstName() { return firstName; }
    public void setFirstName(String firstName) { this.firstName = firstName; }
 
    public String getLastName() { return lastName; }
    public void setLastName(String lastName) { this.lastName = lastName; }
 
    public Set<Role> getRoles() { return roles; }
    public void setRoles(Set<Role> roles) { this.roles = roles; }
}


spring.datasource.url=jdbc:mysql://localhost:3306/inventory_db?useSSL=false&serverTimezone=UTC&allowPublicKeyRetrieval=true
spring.datasource.username=root
spring.datasource.password=yuvan
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
 
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.jdbc.time_zone=UTC
 
server.port=8088
server.servlet.context-path=/
 
logging.level.com.example=DEBUG
logging.level.org.springframework.security=DEBUG
logging.level.org.springframework.web.cors=DEBUG
logging.level.org.springframework.web.filter=DEBUG
 
spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration

app.jwtSecret=MySuperSecretKeyForJWTTokenGenerationInSpringBootApplication12345
app.jwtExpirationMs=86400000

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
 
    <groupId>com.example</groupId>
    <artifactId>inventory-backend</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>Product Inventory Backend</name>
    <description>Spring Boot + JWT + MySQL + Lombok</description>
    <packaging>jar</packaging>
 
    <properties>
        <java.version>17</java.version>
        <spring-boot.version>3.3.0</spring-boot.version>
        <lombok.version>1.18.34</lombok.version>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>
 
    <!-- ==== PARENT POM (FIXED) ==== -->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.3.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
 
    <!-- ==== DEPENDENCIES ==== -->
    <dependencies>
 
        <!-- Spring Boot -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
 
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
 
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
 
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
 
        <!-- MySQL -->
        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <scope>runtime</scope>
        </dependency>
 
        <!-- JWT -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.11.5</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>
 
        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>${lombok.version}</version>
            <optional>true</optional>
        </dependency>
 
        <!-- DevTools -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
 
        <!-- Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
 <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId>
    <version>0.11.5</version>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-impl</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-jackson</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>
    </dependencies>
 
    <!-- ==== BUILD ==== -->
    <build>
        <finalName>inventory-backend</finalName>
        <plugins>
 
            <!-- Spring Boot Plugin -->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>${lombok.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
 
            <!-- Compiler Plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>17</source>
                    <target>17</target>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>${lombok.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
 
        </plugins>
    </build>
 
</project>
