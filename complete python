# Python Complete Guide

## Table of Contents
1. [Basics](#basics)
2. [Data Types](#data-types)
3. [Control Flow](#control-flow)
4. [Functions](#functions)
5. [Object-Oriented Programming](#object-oriented-programming)
6. [Decorators](#decorators)
7. [Generators and Iterators](#generators-and-iterators)
8. [Exception Handling](#exception-handling)
9. [File Handling](#file-handling)
10. [Collections and Data Structures](#collections-and-data-structures)
11. [Functional Programming](#functional-programming)
12. [Modules and Packages](#modules-and-packages)
13. [Interview Questions and Answers](#interview-questions-and-answers)

---

## Basics

### Print and Variables

```python
# Basic print
print("Hello, World!")

# Variables (no type declaration needed)
name = "Alice"
age = 30
height = 5.9
is_student = False

# Dynamic typing
x = 10
print(type(x))  # <class 'int'>
x = "hello"
print(type(x))  # <class 'str'>
```

### String Operations

```python
# String concatenation
full_name = "John" + " " + "Doe"

# String formatting
age = 25
print(f"My name is John and I am {age} years old")  # f-string (Python 3.6+)
print("My age is {}".format(age))  # .format()
print("My age is %d" % age)  # % formatting

# String methods
text = "Python Programming"
print(text.lower())  # python programming
print(text.upper())  # PYTHON PROGRAMMING
print(text.replace("Python", "Java"))  # Java Programming
print(text.split())  # ['Python', 'Programming']
print(text.startswith("Python"))  # True
```

### Comments and Conventions

```python
# This is a single-line comment

"""
This is a multi-line comment
Also called a docstring
"""

# Python naming conventions (PEP 8)
my_variable = 10  # snake_case for variables
MY_CONSTANT = 100  # UPPER_CASE for constants
MyClass = object()  # PascalCase for classes
```

---

## Data Types

### Numbers

```python
# Integers
a = 10
b = -5
c = 0

# Floats
x = 3.14
y = -2.5
z = 1e-3  # 0.001

# Complex numbers
c = 3 + 4j
print(c.real)  # 3.0
print(c.imag)  # 4.0

# Arithmetic operations
print(10 + 5)   # 15
print(10 - 5)   # 5
print(10 * 5)   # 50
print(10 / 5)   # 2.0 (float division)
print(10 // 3)  # 3 (floor division)
print(10 % 3)   # 1 (modulo)
print(2 ** 3)   # 8 (exponentiation)
```

### Strings

```python
# String creation
s1 = "Hello"
s2 = 'World'
s3 = """Multi
line
string"""

# String indexing and slicing
text = "Python"
print(text[0])      # 'P'
print(text[-1])     # 'n'
print(text[1:4])    # 'yth'
print(text[:3])     # 'Pyt'
print(text[3:])     # 'hon'
print(text[::2])    # 'Pto' (step of 2)
print(text[::-1])   # 'nohtyP' (reverse)

# String immutability
text = "hello"
# text[0] = 'H'  # TypeError: 'str' object does not support item assignment

# String escape sequences
print("Line 1\nLine 2")  # newline
print("Tab\there")       # tab
print("Quote: \"Hello\"")  # escaped quote
```

### Booleans

```python
# Boolean values
is_valid = True
is_empty = False

# Boolean operations
print(True and False)   # False
print(True or False)    # True
print(not True)         # False

# Truthy and Falsy values
print(bool(0))          # False
print(bool(1))          # True
print(bool(""))         # False
print(bool("hello"))    # True
print(bool([]))         # False
print(bool([1, 2]))     # True
```

### Type Conversion

```python
# Converting between types
print(int("10"))        # 10
print(float("3.14"))    # 3.14
print(str(100))         # "100"
print(bool(1))          # True

# int() with base
print(int("1010", 2))   # 10 (binary to decimal)
print(int("FF", 16))    # 255 (hex to decimal)
```

---

## Control Flow

### if-elif-else

```python
age = 15

if age < 13:
    print("Child")
elif age < 18:
    print("Teenager")
elif age < 65:
    print("Adult")
else:
    print("Senior")

# Ternary operator
status = "Adult" if age >= 18 else "Minor"
```

### Comparison and Logical Operators

```python
# Comparison operators
print(5 > 3)        # True
print(5 < 3)        # False
print(5 >= 5)       # True
print(5 <= 4)       # False
print(5 == 5)       # True
print(5 != 3)       # True

# Logical operators
x = 10
print(x > 5 and x < 15)    # True
print(x > 15 or x < 5)     # False
print(not (x == 10))       # False

# Membership operators
print(3 in [1, 2, 3, 4])   # True
print(5 not in [1, 2, 3])  # True

# Identity operators
a = [1, 2, 3]
b = [1, 2, 3]
c = a
print(a == b)       # True (equal values)
print(a is b)       # False (different objects)
print(a is c)       # True (same object)
```

### for Loop

```python
# Iterating over a list
for num in [1, 2, 3, 4, 5]:
    print(num)

# Using range()
for i in range(5):          # 0, 1, 2, 3, 4
    print(i)

for i in range(2, 5):       # 2, 3, 4
    print(i)

for i in range(0, 10, 2):   # 0, 2, 4, 6, 8
    print(i)

# Enumerate for index and value
for idx, value in enumerate(['a', 'b', 'c']):
    print(f"{idx}: {value}")

# Nested loops
for i in range(3):
    for j in range(3):
        print(f"({i}, {j})", end=" ")
    print()
```

### while Loop

```python
count = 0
while count < 5:
    print(count)
    count += 1

# break and continue
for i in range(10):
    if i == 3:
        continue  # Skip to next iteration
    if i == 7:
        break     # Exit loop
    print(i)

# else with loop
for i in range(5):
    if i == 10:
        break
else:
    print("Loop completed")  # Executes if loop wasn't broken
```

---

## Functions

### Basic Functions

```python
# Simple function
def greet():
    print("Hello!")

greet()

# Function with parameters
def greet_person(name, age):
    print(f"Hello {name}, you are {age} years old")

greet_person("Alice", 30)

# Function with return value
def add(a, b):
    return a + b

result = add(5, 3)
print(result)  # 8

# Multiple return values
def get_user():
    return "Alice", 30, "alice@email.com"

name, age, email = get_user()
```

### Default Arguments and Keyword Arguments

```python
# Default arguments
def greet_person(name, greeting="Hello"):
    print(f"{greeting}, {name}!")

greet_person("Bob")           # Hello, Bob!
greet_person("Bob", "Hi")     # Hi, Bob!

# Keyword arguments
def create_user(name, age, email):
    return {"name": name, "age": age, "email": email}

user = create_user(age=25, name="Charlie", email="charlie@email.com")

# *args (arbitrary positional arguments)
def sum_numbers(*args):
    total = 0
    for num in args:
        total += num
    return total

print(sum_numbers(1, 2, 3, 4, 5))  # 15

# **kwargs (arbitrary keyword arguments)
def print_info(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_info(name="Diana", age=28, city="NYC")
```

### Variable Scope

```python
global_var = "I'm global"

def function1():
    local_var = "I'm local"
    print(global_var)   # Can access global
    print(local_var)    # Can access local

def function2():
    global global_var
    global_var = "Modified global"
    # print(local_var)  # NameError - can't access local_var from function1

def function3():
    x = 10
    def inner():
        nonlocal x  # Reference x from outer scope
        x = 20
    inner()
    print(x)  # 20
```

### Lambda Functions

```python
# Lambda - anonymous function
square = lambda x: x ** 2
print(square(5))  # 25

# With multiple arguments
add = lambda x, y: x + y
print(add(3, 4))  # 7

# Using with map, filter, sorted
numbers = [1, 2, 3, 4, 5]
squared = map(lambda x: x ** 2, numbers)
print(list(squared))  # [1, 4, 9, 16, 25]

evens = filter(lambda x: x % 2 == 0, numbers)
print(list(evens))  # [2, 4]
```

---

## Object-Oriented Programming

### Classes and Objects

```python
class Dog:
    # Class variable
    species = "Canis familiaris"
    
    def __init__(self, name, age):
        # Instance variables
        self.name = name
        self.age = age
    
    def __str__(self):
        return f"{self.name} is {self.age} years old"
    
    def __repr__(self):
        return f"Dog('{self.name}', {self.age})"
    
    def bark(self):
        return f"{self.name} says Woof!"
    
    def birthday(self):
        self.age += 1

# Create objects
dog1 = Dog("Buddy", 3)
dog2 = Dog("Max", 5)

print(dog1)  # Buddy is 3 years old
print(dog1.bark())  # Buddy says Woof!
dog1.birthday()
print(dog1.age)  # 4
```

### Inheritance

```python
class Animal:
    def __init__(self, name):
        self.name = name
    
    def speak(self):
        return f"{self.name} makes a sound"

class Dog(Animal):
    def speak(self):
        return f"{self.name} barks"

class Cat(Animal):
    def speak(self):
        return f"{self.name} meows"

# Create instances
dog = Dog("Buddy")
cat = Cat("Whiskers")

print(dog.speak())  # Buddy barks
print(cat.speak())  # Whiskers meows
```

### Polymorphism

```python
class Bird:
    def fly(self):
        return "Flying high"

class Penguin(Bird):
    def fly(self):
        return "Penguin can't fly, but can swim"

class Parrot(Bird):
    def fly(self):
        return "Parrot is flying around"

# Polymorphism
birds = [Bird(), Penguin(), Parrot()]
for bird in birds:
    print(bird.fly())
```

### Encapsulation

```python
class BankAccount:
    def __init__(self, balance):
        self.__balance = balance  # Private attribute
    
    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            return True
        return False
    
    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            return True
        return False
    
    def get_balance(self):
        return self.__balance

account = BankAccount(1000)
account.deposit(500)
print(account.get_balance())  # 1500
# print(account.__balance)  # AttributeError - can't access private attribute
```

### Properties

```python
class Circle:
    def __init__(self, radius):
        self._radius = radius
    
    @property
    def radius(self):
        return self._radius
    
    @radius.setter
    def radius(self, value):
        if value > 0:
            self._radius = value
    
    @property
    def area(self):
        return 3.14159 * self._radius ** 2

circle = Circle(5)
print(circle.radius)  # 5
print(circle.area)    # 78.53975
circle.radius = 10
print(circle.area)    # 314.159
```

### Static and Class Methods

```python
class Math:
    PI = 3.14159
    
    @staticmethod
    def add(a, b):
        """Static method - doesn't need self or cls"""
        return a + b
    
    @classmethod
    def from_string(cls, value):
        """Class method - receives class as first argument"""
        return cls()

# Calling static method
print(Math.add(5, 3))  # 8

# Calling class method
obj = Math.from_string("10")
```

---

## Decorators

### Basic Decorators

```python
def simple_decorator(func):
    def wrapper():
        print("Something before function call")
        func()
        print("Something after function call")
    return wrapper

@simple_decorator
def say_hello():
    print("Hello!")

say_hello()
# Output:
# Something before function call
# Hello!
# Something after function call
```

### Decorators with Arguments

```python
def decorator_with_args(func):
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__} with args {args} and kwargs {kwargs}")
        result = func(*args, **kwargs)
        print(f"Function returned {result}")
        return result
    return wrapper

@decorator_with_args
def multiply(a, b):
    return a * b

multiply(5, 3)
# Output:
# Calling multiply with args (5, 3) and kwargs {}
# Function returned 15
```

### Parameterized Decorators

```python
def repeat(times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            results = []
            for _ in range(times):
                result = func(*args, **kwargs)
                results.append(result)
            return results
        return wrapper
    return decorator

@repeat(times=3)
def greet(name):
    return f"Hello, {name}!"

print(greet("Alice"))
# Output: ['Hello, Alice!', 'Hello, Alice!', 'Hello, Alice!']
```

### Built-in Decorators

```python
class Calculator:
    def __init__(self, value):
        self.value = value
    
    # Property decorator (already covered)
    @property
    def squared(self):
        return self.value ** 2
    
    # Static method decorator (already covered)
    @staticmethod
    def add(a, b):
        return a + b
    
    # Class method decorator (already covered)
    @classmethod
    def create_from_string(cls, value_str):
        return cls(int(value_str))
```

---

## Generators and Iterators

### Iterators

```python
class CountUp:
    def __init__(self, max):
        self.max = max
        self.current = 0
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.current < self.max:
            self.current += 1
            return self.current
        else:
            raise StopIteration

counter = CountUp(3)
for num in counter:
    print(num)  # 1, 2, 3
```

### Generators

```python
# Generator function
def count_up(max):
    current = 0
    while current < max:
        current += 1
        yield current

for num in count_up(5):
    print(num)  # 1, 2, 3, 4, 5

# Generator expression
squared_generator = (x ** 2 for x in range(5))
print(next(squared_generator))  # 0
print(next(squared_generator))  # 1
print(next(squared_generator))  # 4
```

### Generator Example: Fibonacci

```python
def fibonacci(n):
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

fib_sequence = list(fibonacci(10))
print(fib_sequence)  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

# Using generator with sum
print(sum(fibonacci(10)))
```

---

## Exception Handling

### try-except Blocks

```python
# Basic exception handling
try:
    x = 10 / 0
except ZeroDivisionError:
    print("Cannot divide by zero!")

# Multiple except blocks
try:
    num = int("abc")
except ValueError:
    print("Invalid integer")
except ZeroDivisionError:
    print("Cannot divide by zero")

# Catching multiple exceptions in one block
try:
    result = int("abc") / 0
except (ValueError, ZeroDivisionError):
    print("An error occurred")

# Accessing exception details
try:
    x = 1 / 0
except Exception as e:
    print(f"Error type: {type(e).__name__}")
    print(f"Error message: {str(e)}")
```

### try-except-else-finally

```python
try:
    x = 10 / 2
except ZeroDivisionError:
    print("Cannot divide by zero")
else:
    print(f"Result: {x}")  # Executes if no exception
finally:
    print("This always executes")

# Output:
# Result: 5.0
# This always executes
```

### Custom Exceptions

```python
class InsufficientFundsError(Exception):
    pass

class NegativeAmountError(Exception):
    pass

class BankAccount:
    def __init__(self, balance):
        self.balance = balance
    
    def withdraw(self, amount):
        if amount < 0:
            raise NegativeAmountError("Amount cannot be negative")
        if amount > self.balance:
            raise InsufficientFundsError("Not enough funds")
        self.balance -= amount

account = BankAccount(100)
try:
    account.withdraw(150)
except InsufficientFundsError as e:
    print(f"Error: {e}")

try:
    account.withdraw(-50)
except NegativeAmountError as e:
    print(f"Error: {e}")
```

---

## File Handling

### Reading Files

```python
# Reading entire file
with open("file.txt", "r") as file:
    content = file.read()
    print(content)

# Reading line by line
with open("file.txt", "r") as file:
    for line in file:
        print(line.strip())

# Reading all lines as list
with open("file.txt", "r") as file:
    lines = file.readlines()
    print(lines)
```

### Writing Files

```python
# Writing to file (overwrites if exists)
with open("output.txt", "w") as file:
    file.write("Hello, World!\n")
    file.write("Second line\n")

# Appending to file
with open("output.txt", "a") as file:
    file.write("Third line\n")

# Writing multiple lines
lines = ["Line 1", "Line 2", "Line 3"]
with open("output.txt", "w") as file:
    file.writelines([f"{line}\n" for line in lines])
```

### Working with JSON

```python
import json

# Reading JSON
with open("data.json", "r") as file:
    data = json.load(file)

# Writing JSON
data = {"name": "Alice", "age": 30, "city": "NYC"}
with open("data.json", "w") as file:
    json.dump(data, file, indent=2)

# JSON strings
json_string = '{"name": "Bob", "age": 25}'
parsed = json.loads(json_string)
print(parsed["name"])  # Bob

to_json = json.dumps({"city": "LA", "zip": 90001})
print(to_json)  # {"city": "LA", "zip": 90001}
```

### Working with CSV

```python
import csv

# Reading CSV
with open("data.csv", "r") as file:
    reader = csv.reader(file)
    for row in reader:
        print(row)

# Reading as dictionaries
with open("data.csv", "r") as file:
    reader = csv.DictReader(file)
    for row in reader:
        print(row)  # row is a dictionary

# Writing CSV
data = [
    {"name": "Alice", "age": 30},
    {"name": "Bob", "age": 25}
]
with open("output.csv", "w", newline="") as file:
    writer = csv.DictWriter(file, fieldnames=["name", "age"])
    writer.writeheader()
    writer.writerows(data)
```

---

## Collections and Data Structures

### Lists

```python
# Creating lists
empty_list = []
numbers = [1, 2, 3, 4, 5]
mixed = [1, "hello", 3.14, True]

# List methods
numbers = [1, 2, 3]
numbers.append(4)           # [1, 2, 3, 4]
numbers.extend([5, 6])      # [1, 2, 3, 4, 5, 6]
numbers.insert(0, 0)        # [0, 1, 2, 3, 4, 5, 6]
numbers.remove(2)           # [0, 1, 3, 4, 5, 6]
popped = numbers.pop()      # Returns 6, list is [0, 1, 3, 4, 5]
numbers.reverse()           # Reverses in place
numbers.sort()              # Sorts in place
index = numbers.index(3)    # Returns index of 3
count = numbers.count(1)    # Returns count of 1

# List comprehension
squares = [x ** 2 for x in range(5)]  # [0, 1, 4, 9, 16]
evens = [x for x in range(10) if x % 2 == 0]  # [0, 2, 4, 6, 8]
```

### Tuples

```python
# Creating tuples (immutable)
empty_tuple = ()
single = (1,)  # Note the comma
numbers = (1, 2, 3)
mixed = (1, "hello", 3.14)

# Tuple unpacking
a, b, c = (1, 2, 3)
x, *rest = (1, 2, 3, 4)  # x = 1, rest = [2, 3, 4]

# Tuple methods
numbers = (1, 2, 3, 2)
index = numbers.index(2)   # 1
count = numbers.count(2)   # 2

# Named tuples
from collections import namedtuple
Point = namedtuple("Point", ["x", "y"])
p = Point(3, 4)
print(p.x, p.y)  # 3 4
```

### Dictionaries

```python
# Creating dictionaries
empty_dict = {}
person = {"name": "Alice", "age": 30, "city": "NYC"}
dict_constructor = dict(name="Bob", age=25)

# Accessing and modifying
person["name"]           # "Alice"
person.get("age")        # 30
person.get("country", "USA")  # "USA" (default value)
person["country"] = "USA"     # Add new key-value

# Dictionary methods
keys = person.keys()     # dict_keys(['name', 'age', 'city', 'country'])
values = person.values() # dict_values(['Alice', 30, 'NYC', 'USA'])
items = person.items()   # dict_items([('name', 'Alice'), ('age', 30), ...])

person.pop("city")       # Remove and return value
person.update({"age": 31, "job": "Engineer"})  # Update/add multiple

# Dictionary comprehension
squares = {x: x**2 for x in range(5)}  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
```

### Sets

```python
# Creating sets
empty_set = set()
numbers = {1, 2, 3, 4, 5}
from_list = set([1, 2, 2, 3, 3])  # {1, 2, 3} - duplicates removed

# Set operations
set1 = {1, 2, 3}
set2 = {2, 3, 4}

union = set1 | set2  # {1, 2, 3, 4}
intersection = set1 & set2  # {2, 3}
difference = set1 - set2  # {1}
symmetric_diff = set1 ^ set2  # {1, 4}

# Set methods
set1.add(4)              # {1, 2, 3, 4}
set1.remove(1)           # {2, 3, 4} - raises KeyError if not found
set1.discard(5)          # No error if not found
set1.pop()               # Remove and return arbitrary element
set1.clear()             # Empty the set

# Set comprehension
even_set = {x for x in range(10) if x % 2 == 0}  # {0, 2, 4, 6, 8}
```

---

## Functional Programming

### map, filter, reduce

```python
# map - apply function to each element
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x ** 2, numbers))  # [1, 4, 9, 16, 25]

# filter - keep elements that satisfy condition
evens = list(filter(lambda x: x % 2 == 0, numbers))  # [2, 4]

# reduce - cumulative operation
from functools import reduce
product = reduce(lambda x, y: x * y, numbers)  # 120
```

### sorted and sorted with key

```python
numbers = [5, 2, 8, 1, 9]
sorted_asc = sorted(numbers)        # [1, 2, 5, 8, 9]
sorted_desc = sorted(numbers, reverse=True)  # [9, 8, 5, 2, 1]

words = ["apple", "pie", "zoo", "a"]
sorted_words = sorted(words, key=len)  # ['a', 'pie', 'zoo', 'apple']
sorted_words = sorted(words, key=lambda x: x[0])  # alphabetical

people = [
    {"name": "Alice", "age": 30},
    {"name": "Bob", "age": 25},
    {"name": "Charlie", "age": 28}
]
sorted_people = sorted(people, key=lambda p: p["age"])
```

### zip and enumerate

```python
names = ["Alice", "Bob", "Charlie"]
ages = [30, 25, 28]

# zip combines iterables
combined = list(zip(names, ages))
# [('Alice', 30), ('Bob', 25), ('Charlie', 28)]

# Unpacking in loop
for name, age in zip(names, ages):
    print(f"{name} is {age} years old")

# enumerate
for idx, name in enumerate(names):
    print(f"{idx}: {name}")
```

---

## Modules and Packages

### Importing Modules

```python
# Import entire module
import math
print(math.pi)      # 3.141592653589793
print(math.sqrt(16))  # 4.0

# Import specific items
from math import pi, sqrt
print(pi)
print(sqrt(16))

# Import with alias
import numpy as np
from pandas import DataFrame as DF

# Import all (not recommended)
# from math import *
```

### Creating Modules

```python
# utils.py
def add(a, b):
    return a + b

def multiply(a, b):
    return a * b

class Calculator:
    def __init__(self):
        self.result = 0

# main.py
from utils import add, multiply, Calculator

print(add(5, 3))  # 8
calc = Calculator()
```

### Common Modules

```python
# datetime
from datetime import datetime, timedelta
now = datetime.now()
print(now)
tomorrow = now + timedelta(days=1)

# os
import os
print(os.getcwd())
print(os.listdir('.'))

# sys
import sys
print(sys.version)
print(sys.path)

# random
import random
random.seed(42)
print(random.random())      # Random float [0, 1)
print(random.randint(1, 10))  # Random int 1-10
print(random.choice([1, 2, 3, 4, 5]))

# collections
from collections import Counter, defaultdict, OrderedDict
counter = Counter("aabbcc")  # Counter({'a': 2, 'b': 2, 'c': 2})
```

---

## Interview Questions and Answers

### Question 1: What is the difference between `==` and `is`?

**Answer:**
- `==` compares values - checks if two variables have the same value
- `is` compares identity - checks if two variables reference the same object in memory

```python
a = [1, 2, 3]
b = [1, 2, 3]
c = a

print(a == b)   # True (same values)
print(a is b)   # False (different objects)
print(a is c)   # True (same object reference)

x = 5
y = 5
print(x == y)   # True
print(x is y)   # True (Python caches small integers)

# With larger numbers
x = 257
y = 257
print(x == y)   # True
print(x is y)   # False (no caching for larger integers)
```

---

### Question 2: Explain list vs tuple vs set

**Answer:**

| Feature | List | Tuple | Set |
|---------|------|-------|-----|
| Mutable | Yes | No | Yes |
| Ordered | Yes | Yes | No |
| Duplicates | Allowed | Allowed | Not allowed |
| Indexing | Yes | Yes | No |
| Syntax | [] | () | {} |
| Use Case | Flexible collections | Immutable collections | Unique items, fast lookup |

```python
# List - mutable, ordered, allows duplicates
my_list = [1, 2, 2, 3]
my_list[0] = 10
my_list.append(4)

# Tuple - immutable, ordered, allows duplicates
my_tuple = (1, 2, 2, 3)
# my_tuple[0] = 10  # TypeError
# my_tuple.append(4)  # AttributeError

# Set - mutable, unordered, no duplicates
my_set = {1, 2, 2, 3}  # {1, 2, 3}
my_set.add(4)
print(my_set[0])  # TypeError - no indexing
```

---

### Question 3: What are decorators and how do they work?

**Answer:**
Decorators are functions that modify the behavior of another function or class without changing its source code. They work by taking a function as input, adding functionality, and returning the modified function.

```python
# Without decorator
def greet():
    print("Hello!")

def add_logging(func):
    def wrapper():
        print("Function called")
        func()
        print("Function finished")
    return wrapper

greet = add_logging(greet)
greet()
# Output:
# Function called
# Hello!
# Function finished

# Same thing with @ syntax
@add_logging
def say_bye():
    print("Goodbye!")

say_bye()
```

---

### Question 4: What is the difference between generator and iterator?

**Answer:**
- **Iterator**: An object that implements `__iter__()` and `__next__()` methods. It can be iterated over using a loop.
- **Generator**: A special type of iterator created using a function with `yield` statements. More memory-efficient than lists.

```python
# Iterator
class CountUp:
    def __init__(self, max):
        self.current = 0
        self.max = max
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.current < self.max:
            self.current += 1
            return self.current
        raise StopIteration

# Generator (simpler)
def count_up(max):
    current = 0
    while current < max:
        current += 1
        yield current

# Both can be used the same way
for num in CountUp(3):
    print(num)

for num in count_up(3):
    print(num)
```

---

### Question 5: Explain list comprehension with examples

**Answer:**
List comprehension is a concise way to create lists. It's faster and more readable than using loops.

```python
# Basic list comprehension
squares = [x**2 for x in range(5)]  # [0, 1, 4, 9, 16]

# With condition
evens = [x for x in range(10) if x % 2 == 0]  # [0, 2, 4, 6, 8]

# Nested comprehension
matrix = [[i+j for j in range(3)] for i in range(3)]
# [[0, 1, 2], [1, 2, 3], [2, 3, 4]]

# Multiple conditions
numbers = [x for x in range(20) if x % 2 == 0 if x % 3 == 0]  # [0, 6, 12, 18]

# String manipulation
words = ["hello", "world"]
chars = [c for word in words for c in word]  # ['h','e','l','l','o','w','o','r','l','d']
```

---

### Question 6: What is `*args` and `**kwargs`?

**Answer:**
- `*args`: Allows a function to accept any number of positional arguments as a tuple
- `**kwargs`: Allows a function to accept any number of keyword arguments as a dictionary

```python
def print_all(*args, **kwargs):
    print("Positional arguments:")
    for arg in args:
        print(arg)
    print("Keyword arguments:")
    for key, value in kwargs.items():
        print(f"{key} = {value}")

print_all(1, 2, 3, name="Alice", age=30, city="NYC")
# Output:
# Positional arguments:
# 1
# 2
# 3
# Keyword arguments:
# name = Alice
# age = 30
# city = NYC

# Unpacking
def add(a, b, c):
    return a + b + c

numbers = [1, 2, 3]
print(add(*numbers))  # 6

params = {"a": 1, "b": 2, "c": 3}
print(add(**params))  # 6
```

---

### Question 7: What's the difference between shallow copy and deep copy?

**Answer:**
- **Shallow copy**: Creates a new object but references to nested objects are still shared
- **Deep copy**: Creates a new object with entirely new copies of nested objects

```python
import copy

original = [[1, 2], [3, 4]]

# Shallow copy
shallow = copy.copy(original)
shallow[0][0] = 99
print(original[0][0])  # 99 (affected!)

# Deep copy
original = [[1, 2], [3, 4]]
deep = copy.deepcopy(original)
deep[0][0] = 99
print(original[0][0])  # 1 (not affected)

# Using slicing (shallow copy for lists)
list1 = [1, 2, 3]
list2 = list1[:]  # Shallow copy
list2[0] = 99
print(list1[0])  # 1 (not affected for flat lists)
```

---

### Question 8: How do you handle exceptions in Python?

**Answer:**
Python provides try-except-else-finally blocks to handle exceptions gracefully.

```python
try:
    # Code that might raise an exception
    result = 10 / int(input("Enter a number: "))
except ZeroDivisionError:
    print("Cannot divide by zero")
except ValueError:
    print("Invalid input")
except Exception as e:
    print(f"An error occurred: {e}")
else:
    # Executes if no exception occurred
    print(f"Result: {result}")
finally:
    # Always executes
    print("Cleanup code")

# Raising custom exceptions
class InvalidAgeError(Exception):
    pass

def set_age(age):
    if age < 0:
        raise InvalidAgeError("Age cannot be negative")
    return age
```

---

### Question 9: What is the GIL (Global Interpreter Lock)?

**Answer:**
The GIL is a mutex in CPython that prevents multiple native threads from executing Python bytecode simultaneously. This means only one thread can execute Python code at a time, even on multi-core systems.

**Implications:**
- Multi-threading doesn't improve performance for CPU-bound tasks
- Multi-threading is useful for I/O-bound tasks (network, file operations)
- Use `multiprocessing` for true parallelism with CPU-bound tasks

```python
import threading
import time

# GIL limits threading for CPU-bound work
def cpu_bound():
    for i in range(100_000_000):
        pass

# Single-threaded
start = time.time()
cpu_bound()
cpu_bound()
print(f"Single-threaded: {time.time() - start}")

# Multi-threaded (similar time due to GIL)
start = time.time()
t1 = threading.Thread(target=cpu_bound)
t2 = threading.Thread(target=cpu_bound)
t1.start()
t2.start()
t1.join()
t2.join()
print(f"Multi-threaded: {time.time() - start}")
```

---

### Question 10: Explain the difference between `range()` and `xrange()`

**Answer:**
- In Python 2: `range()` returns a list, `xrange()` returns an iterator (memory efficient)
- In Python 3: `range()` is an iterator (like `xrange()` in Python 2), `xrange()` doesn't exist

```python
# Python 3
r = range(5)
print(type(r))  # <class 'range'>
print(list(r))  # [0, 1, 2, 3, 4]

# range is memory efficient
for i in range(1_000_000):
    pass  # Doesn't create a list of 1 million items

# Get specific values
print(range(5)[2])  # 2 (indexing supported)
```

---

### Question 11: What is monkey patching?

**Answer:**
Monkey patching is the practice of modifying a module, class, or function at runtime. It's useful for testing but should be used carefully as it can make code unpredictable.

```python
import math

# Save original
original_sqrt = math.sqrt

# Monkey patch
math.sqrt = lambda x: x

print(math.sqrt(16))  # 16 (wrong!)

# Restore
math.sqrt = original_sqrt
print(math.sqrt(16))  # 4.0

# Patching classes
class Dog:
    def bark(self):
        return "Woof!"

dog = Dog()
print(dog.bark())  # Woof!

# Monkey patch the method
def new_bark(self):
    return "Meow!"

Dog.bark = new_bark
print(dog.bark())  # Meow!
```

---

### Question 12: What are metaclasses?

**Answer:**
Metaclasses are classes whose instances are classes. They define how a class behaves, similar to how classes define behavior of instances.

```python
# Basic metaclass
class Meta(type):
    def __new__(mcs, name, bases, dct):
        print(f"Creating class {name}")
        return super().__new__(mcs, name, bases, dct)

class MyClass(metaclass=Meta):
    pass

# Output: Creating class MyClass

# Practical example: enforce methods
class SingletonMeta(type):
    _instances = {}
    
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class Database(metaclass=SingletonMeta):
    def __init__(self):
        self.connection = "Connected"

db1 = Database()
db2 = Database()
print(db1 is db2)  # True (same instance)
```

---

### Question 13: How do you write a Python script that's runnable as a module?

**Answer:**
Use the `if __name__ == "__main__":` idiom to run code only when the script is executed directly, not when imported.

```python
# utils.py
def add(a, b):
    return a + b

def multiply(a, b):
    return a * b

if __name__ == "__main__":
    # This runs only when utils.py is executed directly
    print("Testing utils module")
    print(add(5, 3))
    print(multiply(5, 3))

# In another file, you can import without running the test code
# from utils import add, multiply
```

---

### Question 14: What is the difference between `append()` and `extend()`?

**Answer:**
- `append()`: Adds a single element to the end of list
- `extend()`: Adds all elements from an iterable to the end of list

```python
numbers = [1, 2, 3]

# append - adds entire object as single element
numbers.append([4, 5])
print(numbers)  # [1, 2, 3, [4, 5]]

numbers = [1, 2, 3]
# extend - adds each element individually
numbers.extend([4, 5])
print(numbers)  # [1, 2, 3, 4, 5]

# extend works with any iterable
numbers.extend((6, 7))
print(numbers)  # [1, 2, 3, 4, 5, 6, 7]

numbers.extend("89")
print(numbers)  # [1, 2, 3, 4, 5, 6, 7, '8', '9']
```

---

### Question 15: Explain `*` and `**` operators

**Answer:**
- `*`: Unpacking operator for iterables (lists, tuples)
- `**`: Unpacking operator for dictionaries

```python
# * unpacking
numbers = [1, 2, 3]
print(*numbers)  # 1 2 3

def add_three(a, b, c):
    return a + b + c

print(add_three(*numbers))  # 6

# Multiple assignment
first, *middle, last = [1, 2, 3, 4, 5]
print(first, middle, last)  # 1 [2, 3, 4] 5

# ** unpacking
def print_person(name, age, city):
    print(f"{name} is {age} and lives in {city}")

person = {"name": "Alice", "age": 30, "city": "NYC"}
print_person(**person)

# Merging dictionaries
dict1 = {"a": 1, "b": 2}
dict2 = {"c": 3, "d": 4}
merged = {**dict1, **dict2}  # {"a": 1, "b": 2, "c": 3, "d": 4}
```

---

### Question 16: What is the purpose of `__init__` and `__new__`?

**Answer:**
- `__new__()`: Creates a new instance of the class (constructor)
- `__init__()`: Initializes the instance after it's created (initializer)

```python
class Person:
    def __new__(cls, name):
        print(f"Creating instance for {name}")
        instance = super().__new__(cls)
        return instance
    
    def __init__(self, name):
        print(f"Initializing instance for {name}")
        self.name = name

person = Person("Alice")
# Output:
# Creating instance for Alice
# Initializing instance for Alice

# Practical use of __new__
class PositiveInt:
    def __new__(cls, value):
        if value < 0:
            raise ValueError("Must be positive")
        return super().__new__(cls)
    
    def __init__(self, value):
        self.value = value

# pi = PositiveInt(-5)  # ValueError
```

---

### Question 17: What are context managers?

**Answer:**
Context managers are objects that define what happens when entering and exiting a `with` block. They implement `__enter__()` and `__exit__()` methods.

```python
# Using context manager
with open("file.txt", "r") as file:
    content = file.read()
# File automatically closed here

# Creating a context manager
class FileManager:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
        self.file = None
    
    def __enter__(self):
        print(f"Opening {self.filename}")
        self.file = open(self.filename, self.mode)
        return self.file
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        print(f"Closing {self.filename}")
        if self.file:
            self.file.close()
        return False  # Don't suppress exceptions

with FileManager("output.txt", "w") as f:
    f.write("Hello!")

# Using contextlib decorator
from contextlib import contextmanager

@contextmanager
def timer():
    import time
    start = time.time()
    try:
        yield
    finally:
        print(f"Elapsed: {time.time() - start:.2f}s")

with timer():
    time.sleep(1)
```

---

### Question 18: What is the difference between mutable and immutable objects?

**Answer:**
- **Immutable**: Cannot be changed after creation (int, float, str, tuple). Changes create new objects.
- **Mutable**: Can be changed after creation (list, dict, set).

```python
# Immutable
x = 10
y = x
x = 20
print(y)  # 10 (y not affected)

# Mutable
list1 = [1, 2, 3]
list2 = list1
list1.append(4)
print(list2)  # [1, 2, 3, 4] (list2 affected!)

# Assignment creates reference for mutable
# To avoid this, make a copy
list3 = list1.copy()
list1.append(5)
print(list3)  # [1, 2, 3, 4] (list3 not affected)

# String immutability
text = "hello"
new_text = text + " world"
print(text)  # hello (original unchanged)
```

---

### Question 19: Explain `classmethod` vs `staticmethod`

**Answer:**
- `@classmethod`: Receives the class as first argument, can access/modify class state
- `@staticmethod`: Doesn't receive class or instance, behaves like a regular function

```python
class MyClass:
    class_var = "I'm a class variable"
    
    @staticmethod
    def static_method():
        # Can't access class or instance
        return "I'm a static method"
    
    @classmethod
    def class_method(cls):
        # Receives class as argument
        return f"Class method accessing {cls.class_var}"
    
    def instance_method(self):
        # Receives instance as argument
        return "I'm an instance method"

# Calling static method
print(MyClass.static_method())  # I'm a static method

# Calling class method
print(MyClass.class_method())  # Class method accessing I'm a class variable

# Practical example
class Dog:
    def __init__(self, name, breed):
        self.name = name
        self.breed = breed
    
    @classmethod
    def from_string(cls, dog_string):
        # Factory method
        name, breed = dog_string.split(",")
        return cls(name, breed)
    
    @staticmethod
    def species():
        return "Canis familiaris"

dog = Dog.from_string("Buddy,Labrador")
print(dog.name, dog.breed)  # Buddy Labrador
print(Dog.species())  # Canis familiaris
```

---

### Question 20: What is the purpose of `pass` statement?

**Answer:**
`pass` is a null operation - when executed, nothing happens. It's used as a placeholder when a statement is required syntactically but no code needs to be executed.

```python
# Empty function (syntax error without pass)
def placeholder():
    pass

# Empty class
class EmptyClass:
    pass

# Empty conditional
if True:
    pass
else:
    print("This doesn't run")

# Empty exception handler
try:
    x = 1 / 0
except ZeroDivisionError:
    pass  # Silently ignore

# Useful for TODO
def process_data():
    pass  # TODO: implement this function
```

---

### Question 21: How do you create a private variable in Python?

**Answer:**
Python doesn't have true private variables, but uses naming conventions. Variables prefixed with `_` are considered internal, `__` activates name mangling.

```python
class Account:
    def __init__(self, balance):
        self._balance = balance  # Internal (convention)
        self.__secret = "hidden"  # Name mangled
    
    def get_balance(self):
        return self._balance

account = Account(1000)
print(account.get_balance())  # 1000
print(account._balance)       # 1000 (accessible but discouraged)
# print(account.__secret)     # AttributeError

# Name mangling creates _ClassName__attribute
print(account._Account__secret)  # "hidden" (accessible but strongly discouraged)

# Best practice: use @property
class SecureAccount:
    def __init__(self, balance):
        self._balance = balance
    
    @property
    def balance(self):
        return self._balance
    
    @balance.setter
    def balance(self, value):
        if value >= 0:
            self._balance = value

acc = SecureAccount(1000)
print(acc.balance)  # 1000
acc.balance = 2000
```

---

### Question 22: What is `__slots__`?

**Answer:**
`__slots__` restricts the attributes that an instance can have, saving memory and improving performance.

```python
# Without __slots__
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

# With __slots__
class OptimizedPerson:
    __slots__ = ['name', 'age']
    
    def __init__(self, name, age):
        self.name = name
        self.age = age

person = OptimizedPerson("Alice", 30)
# person.city = "NYC"  # AttributeError - not in __slots__

# Comparison
import sys
p1 = Person("Alice", 30)
p2 = OptimizedPerson("Bob", 25)

print(sys.getsizeof(p1.__dict__))  # Size of __dict__
# __slots__ uses less memory
```

---

### Question 23: Explain List Slicing

**Answer:**
List slicing creates a new list containing a subset of elements using `list[start:end:step]`.

```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# Basic slicing
print(numbers[2:5])      # [2, 3, 4]
print(numbers[:4])       # [0, 1, 2, 3]
print(numbers[4:])       # [4, 5, 6, 7, 8, 9]
print(numbers[:])        # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# Negative indices
print(numbers[-3:])      # [7, 8, 9]
print(numbers[:-2])      # [0, 1, 2, 3, 4, 5, 6, 7]
print(numbers[-5:-2])    # [5, 6, 7]

# Step
print(numbers[::2])      # [0, 2, 4, 6, 8]
print(numbers[1::2])     # [1, 3, 5, 7, 9]
print(numbers[::-1])     # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]

# Slicing strings
text = "Python"
print(text[1:4])         # yth
print(text[::-1])        # nohtyP
```

---

### Question 24: What is `enumerate()` and how is it useful?

**Answer:**
`enumerate()` returns both the index and value when iterating, more efficient than manually tracking indices.

```python
# Without enumerate
items = ['apple', 'banana', 'cherry']
for i in range(len(items)):
    print(f"{i}: {items[i]}")

# With enumerate (better)
for i, item in enumerate(items):
    print(f"{i}: {item}")

# Starting from different index
for i, item in enumerate(items, start=1):
    print(f"{i}: {item}")
    # 1: apple
    # 2: banana
    # 3: cherry
```

---

### Question 25: What is the difference between `is` None and `== None`?

**Answer:**
- `is None`: Checks identity (recommended for None)
- `== None`: Checks equality

```python
# Correct way to check for None
x = None
if x is None:
    print("x is None")

# Avoid this
if x == None:
    print("x equals None")

# Why? None is a singleton
a = None
b = None
print(a is b)  # True (always the same object)

# With values, == and is can differ
x = [1, 2, 3]
y = [1, 2, 3]
print(x == y)  # True
print(x is y)  # False
```

---

## Summary

This guide covers:
- **Fundamentals**: Variables, data types, operations
- **Control Flow**: Conditionals and loops
- **Functions**: Definition, parameters, scope, lambdas
- **OOP**: Classes, inheritance, polymorphism, encapsulation
- **Advanced**: Decorators, generators, exceptions
- **File Handling**: Reading/writing files, JSON, CSV
- **Collections**: Lists, tuples, dicts, sets
- **Functional Programming**: map, filter, reduce, comprehensions
- **25 Common Interview Questions** with detailed answers and code examples

Use this guide as a reference for Python interviews and practical development!
