# Comprehensive FAANG Interview Preparation Guide

## Table of Contents
1. [Coding Patterns & LeetCode Problems](#coding-patterns--leetcode-problems)
2. [System Design (HLD & LLD)](#system-design-hld--lld)
3. [Interview Strategy](#interview-strategy)
4. [Timeline & Study Plan](#timeline--study-plan)

---

## Coding Patterns & LeetCode Problems

### 1. **Array & String Patterns**

#### Pattern 1: Two Pointers
**When to use:** Sorted arrays, palindromes, finding pairs
**Key insight:** Move pointers from opposite ends to solve in O(n) time

**Example:**
```
Problem: Two Sum II (Sorted Array)
Input: [2,7,11,15], target=9
- Left pointer: 2 (index 0)
- Right pointer: 15 (index 3)
- 2+15=17 > 9, move right pointer
- Continue until 2+7=9
Output: [1,2]
```

**LeetCode Problems:**
- #167: Two Sum II (Input array is sorted)
- #11: Container With Most Water
- #15: 3Sum
- #16: 3Sum Closest
- #125: Valid Palindrome
- #392: Is Subsequence

---

#### Pattern 2: Sliding Window
**When to use:** Subarray/substring problems, finding max/min in window
**Key insight:** Expand window to include elements, contract when condition fails

**Example:**
```
Problem: Longest Substring Without Repeating Characters (#3)
Input: "abcabcbb"
- Window [a,b,c] - valid
- Add 'a', remove first 'a'
- Window [b,c,a] - valid
- Result: 3
```

**LeetCode Problems:**
- #3: Longest Substring Without Repeating Characters
- #30: Substring with Concatenation of All Words
- #76: Minimum Window Substring
- #209: Minimum Size Subarray Sum
- #424: Longest Repeating Character Replacement
- #567: Permutation in String
- #1004: Max Consecutive Ones III

---

#### Pattern 3: Prefix Sum
**When to use:** Range sum queries, counting subarrays with specific sum
**Key insight:** Build cumulative sum array to answer range queries in O(1)

**Example:**
```
Problem: Subarray Sum Equals K (#560)
Input: [1,1,1,1,1], k=3
- Prefix sum: [0,1,2,3,4,5]
- Find pairs of prefix sums with difference = k
- Count: 3 subarrays [1,1,1]
```

**LeetCode Problems:**
- #560: Subarray Sum Equals K
- #238: Product of Array Except Self
- #303: Range Sum Query - Immutable
- #325: Maximum Size Subarray Sum Equals k
- #370: Range Addition
- #1480: Running Sum of 1d Array

---

#### Pattern 4: Hashing/HashMap
**When to use:** Counting frequencies, finding duplicates, mapping relationships
**Key insight:** Use hash map for O(1) lookups

**Example:**
```
Problem: Valid Anagram (#242)
Input: s="anagram", t="nagaram"
- Count chars in both strings
- Compare frequencies
- Result: true
```

**LeetCode Problems:**
- #1: Two Sum
- #242: Valid Anagram
- #49: Group Anagrams
- #202: Happy Number
- #290: Word Pattern
- #387: First Unique Character in a String
- #389: Find the Difference

---

### 2. **Linked List Patterns**

#### Pattern 1: Slow & Fast Pointers (Floyd's Cycle Detection)
**When to use:** Finding cycle, middle element, nth node from end
**Key insight:** Fast pointer moves 2 steps, slow moves 1 step

**Example:**
```
Problem: Detect Cycle in Linked List (#141)
Input: 1->2->3->4->5->2 (cycle)
- Slow: 1->2->3->4
- Fast: 1->3->5->2
- They meet at node 2
- Result: Cycle detected
```

**LeetCode Problems:**
- #141: Linked List Cycle
- #142: Linked List Cycle II
- #143: Reorder List
- #202: Happy Number
- #876: Middle of the Linked List
- #234: Palindrome Linked List

---

#### Pattern 2: Reverse Linked List
**When to use:** Palindromes, reversing operations
**Key insight:** Iterate and reverse pointers

**Example:**
```
Problem: Reverse Linked List (#206)
Input: 1->2->3->4->NULL
Output: 4->3->2->1->NULL
- Use three pointers: prev, curr, next
- Reverse direction
```

**LeetCode Problems:**
- #206: Reverse Linked List
- #92: Reverse Linked List II
- #25: Reverse Nodes in k-Group
- #328: Odd Even Linked List
- #445: Add Two Numbers II

---

#### Pattern 3: Merge Linked Lists
**When to use:** Merging sorted lists, combining lists
**Key insight:** Compare nodes and build new list

**LeetCode Problems:**
- #21: Merge Two Sorted Lists
- #23: Merge k Sorted Lists
- #88: Merge Sorted Array

---

### 3. **Tree Patterns**

#### Pattern 1: DFS (Pre-order, In-order, Post-order)
**When to use:** Tree traversal, path finding, validation

**Pre-order:** Node -> Left -> Right (Use for copying, serializing)
**In-order:** Left -> Node -> Right (Use for BST, sorted output)
**Post-order:** Left -> Right -> Node (Use for deletion)

**Example:**
```
Problem: Binary Tree Inorder Traversal (#94)
       1
      /
     2
      \
       3
In-order: 2, 1, 3
```

**LeetCode Problems:**
- #94: Binary Tree Inorder Traversal
- #144: Binary Tree Preorder Traversal
- #145: Binary Tree Postorder Traversal
- #100: Same Tree
- #101: Symmetric Tree
- #104: Maximum Depth of Binary Tree
- #111: Minimum Depth of Binary Tree
- #226: Invert Binary Tree

---

#### Pattern 2: BFS (Level Order Traversal)
**When to use:** Level-by-level processing, shortest path in tree
**Key insight:** Use queue to process level by level

**Example:**
```
Problem: Binary Tree Level Order Traversal (#102)
       3
      / \
     9  20
       /  \
      15   7
Output: [[3], [9,20], [15,7]]
```

**LeetCode Problems:**
- #102: Binary Tree Level Order Traversal
- #103: Binary Tree Zigzag Level Order Traversal
- #107: Binary Tree Level Order Traversal II
- #199: Binary Tree Right Side View
- #637: Average of Levels in Binary Tree

---

#### Pattern 3: BST Operations
**When to use:** Search, insert, validation
**Key insight:** Left < Node < Right

**LeetCode Problems:**
- #98: Validate Binary Search Tree
- #701: Insert into a Binary Search Tree
- #700: Search in a Binary Search Tree
- #450: Delete Node in a BST
- #235: Lowest Common Ancestor of a BST
- #236: Lowest Common Ancestor of a Binary Tree

---

#### Pattern 4: Path Sum Problems
**When to use:** Finding paths with specific properties
**Key insight:** Use DFS with accumulated sum

**LeetCode Problems:**
- #112: Path Sum
- #113: Path Sum II
- #437: Path Sum III
- #666: Path Sum IV

---

### 4. **Dynamic Programming Patterns**

#### Pattern 1: 0/1 Knapsack
**When to use:** Selection problems with constraints
**Key insight:** dp[i][w] = max value using i items with capacity w

**Example:**
```
Problem: 0/1 Knapsack
Items: [(weight=2, value=3), (weight=3, value=4)]
Capacity: 5
dp[1][5] = 3 (take first item)
dp[2][5] = 7 (take both items)
```

**LeetCode Problems:**
- #416: Partition Equal Subset Sum
- #494: Target Sum
- #1049: Last Stone Weight II
- #1155: Number of Dice Rolls With Target Sum

---

#### Pattern 2: Unbounded Knapsack
**When to use:** Unlimited items, coin change
**Key insight:** Item can be used multiple times

**LeetCode Problems:**
- #322: Coin Change
- #518: Coin Change II
- #279: Perfect Squares
- #139: Word Break

---

#### Pattern 3: 1D & 2D DP
**When to use:** String matching, grid problems
**Key insight:** Build solution from base cases

**Example:**
```
Problem: Longest Common Subsequence
s1 = "abc", s2 = "ac"
dp[0] = 0, dp[1] = 1 (c)
dp[2] = 2 (a,c)
```

**LeetCode Problems:**
- #1143: Longest Common Subsequence
- #72: Edit Distance
- #97: Interleaving String
- #115: Distinct Subsequences

---

#### Pattern 4: House Robber/Max Product
**When to use:** Selection with adjacency constraints
**Key insight:** Can't use adjacent elements

**LeetCode Problems:**
- #198: House Robber
- #213: House Robber II
- #337: House Robber III
- #188: Best Time to Buy and Sell Stock IV
- #309: Best Time to Buy and Sell Stock with Cooldown

---

### 5. **Graph Patterns**

#### Pattern 1: DFS/BFS Graph Traversal
**When to use:** Finding connected components, reachability
**Key insight:** Mark visited nodes

**LeetCode Problems:**
- #200: Number of Islands
- #547: Number of Provinces
- #417: Pacific Atlantic Water Flow
- #133: Clone Graph

---

#### Pattern 2: Topological Sort
**When to use:** Dependency resolution, course scheduling
**Key insight:** Use BFS (Kahn's algorithm) or DFS

**LeetCode Problems:**
- #207: Course Schedule
- #210: Course Schedule II
- #269: Alien Dictionary
- #444: Sequence Reconstruction

---

#### Pattern 3: Shortest Path (Dijkstra, Bellman-Ford)
**When to use:** Finding shortest path with weights
**Key insight:** Use priority queue (Dijkstra)

**LeetCode Problems:**
- #743: Network Delay Time
- #787: Cheapest Flights Within K Stops
- #1334: Find the City With the Smallest Number of Neighbors

---

#### Pattern 4: Union-Find (Disjoint Set Union)
**When to use:** Detecting cycles, connected components
**Key insight:** Union by rank + path compression

**LeetCode Problems:**
- #261: Graph Valid Tree
- #323: Number of Connected Components in an Undirected Graph
- #684: Redundant Connection
- #685: Redundant Connection II

---

### 6. **Backtracking Patterns**

#### Pattern 1: Permutations & Combinations
**When to use:** Generate all possible arrangements
**Key insight:** Use recursion with backtracking

**Example:**
```
Problem: Permutations (#46)
Input: [1,2,3]
Output: [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]
```

**LeetCode Problems:**
- #46: Permutations
- #47: Permutations II
- #77: Combinations
- #78: Subsets
- #90: Subsets II

---

#### Pattern 2: Sudoku & N-Queens
**When to use:** Constraint satisfaction
**Key insight:** Check validity before recursing

**LeetCode Problems:**
- #36: Valid Sudoku
- #37: Sudoku Solver
- #51: N-Queens
- #52: N-Queens II

---

#### Pattern 3: Word Search & Trie
**When to use:** Word finding, prefix matching
**Key insight:** Use Trie for efficient lookups

**LeetCode Problems:**
- #79: Word Search
- #212: Word Search II
- #208: Implement Trie (Prefix Tree)
- #211: Design Add and Search Words Data Structure

---

### 7. **Heap/Priority Queue Patterns**

#### Pattern 1: Top K Elements
**When to use:** Finding K largest/smallest, frequent elements
**Key insight:** Use min heap of size K

**Example:**
```
Problem: Top K Frequent Elements (#347)
Input: [1,1,1,2,2,3], k=2
- Frequencies: {1:3, 2:2, 3:1}
- Output: [1,2]
```

**LeetCode Problems:**
- #347: Top K Frequent Elements
- #215: Kth Largest Element in an Array
- #451: Sort Characters By Frequency
- #692: Top K Frequent Words

---

#### Pattern 2: Merge K Lists
**When to use:** Merging multiple sorted sequences
**Key insight:** Use min heap with pointers

**LeetCode Problems:**
- #23: Merge k Sorted Lists
- #264: Ugly Number II
- #313: Super Ugly Number

---

### 8. **Bit Manipulation Patterns**

**LeetCode Problems:**
- #136: Single Number
- #137: Single Number II
- #260: Single Number III
- #191: Number of 1 Bits
- #338: Counting Bits
- #371: Sum of Two Integers

---

## System Design (HLD & LLD)

### High-Level Design (HLD)

#### 1. **Design Patterns**

**Pattern 1: MVC (Model-View-Controller)**
```
User Request
    â†“
Route Handler
    â†“
Controller (Business Logic)
    â†“
Model (Data Layer)
    â†“
Database
```

**Pattern 2: Observer Pattern**
```
Subject (Observable)
    â†“
Notifies all observers
    â†“
Observers take action
```
Use case: Event listeners, pub/sub systems

**Pattern 3: Singleton Pattern**
```
Single instance throughout application
Use case: Database connection, logger
```

**Pattern 4: Factory Pattern**
```
CreateObject() factory
    â†“
Specific implementation returned
Use case: Different database types, payment methods
```

---

#### 2. **HLD Example: URL Shortener (like bit.ly)**

```
Requirements:
1. Generate short URLs from long URLs
2. Redirect short URL to long URL
3. Handle millions of requests
4. URL expiration support

High-Level Architecture:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   User      â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
    â”Œâ”€â”€â”´â”€â”€â”
    â”‚ LB  â”‚ (Load Balancer)
    â””â”€â”€â”¬â”€â”€â”˜
       â”‚
   â”Œâ”€â”€â”€â”´â”€â”€â”€â”
   â”‚ API   â”‚ (Microservices)
   â”‚Server â”‚
   â””â”€â”€â”€â”¬â”€â”€â”€â”˜
       â”‚
   â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚                    â”‚
â”Œâ”€â”€â–¼â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”
â”‚Cacheâ”‚          â”‚Database â”‚
â””â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
(Redis)          (PostgreSQL)

Key Components:
1. Load Balancer: Distribute traffic
2. API Server: Handle encode/decode
3. Cache: Store frequently accessed mappings
4. Database: Persist data
5. Message Queue: Async jobs
```

**Components Details:**

| Component | Purpose | Technology |
|-----------|---------|------------|
| Load Balancer | Distribute requests | Nginx, HAProxy |
| API Layer | Business logic | Spring Boot, Node.js |
| Cache | Fast retrieval | Redis |
| Database | Persistence | PostgreSQL, MongoDB |
| Message Queue | Async processing | Kafka, RabbitMQ |

**Flow:**
```
Encode (Long URL â†’ Short URL):
1. Generate unique ID
2. Store mapping in database
3. Cache the mapping
4. Return short URL

Decode (Short URL â†’ Long URL):
1. Check cache (Redis)
2. If miss, query database
3. Return and cache
4. Redirect to long URL
```

---

#### 3. **HLD Example: Video Streaming Platform (like Netflix)**

```
Architecture:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Content    â”‚
â”‚   Creator    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
    â”Œâ”€â”€â–¼â”€â”€â”€â”
    â”‚Upload â”‚
    â””â”€â”€â”¬â”€â”€â”€â”˜
       â”‚
    â”Œâ”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Processing â”‚ (Video encoding to multiple bitrates)
    â””â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
    â”Œâ”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
    â”‚   CDN   â”‚ (Distribute globally)
    â””â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
    â”Œâ”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                   â”‚
â”Œâ”€â”€â”€â–¼â”€â”€â”           â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”
â”‚User  â”‚           â”‚Metadataâ”‚
â”‚Watch â”‚           â”‚Databaseâ”‚
â””â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Key Technologies:
- Transcoding: FFmpeg
- Storage: S3, GCS
- CDN: CloudFlare, Akamai
- Streaming: RTMP, HLS
```

---

### Low-Level Design (LLD)

#### 1. **LLD Patterns**

**Pattern 1: Strategy Pattern**
```
Interface PaymentStrategy {
    pay(amount: double)
}

Classes:
- CreditCardPayment implements PaymentStrategy
- UPIPayment implements PaymentStrategy
- WalletPayment implements PaymentStrategy
```

**Pattern 2: Command Pattern**
```
Interface Command {
    execute()
    undo()
}

Classes:
- TurnOnCommand implements Command
- TurnOffCommand implements Command
```

**Pattern 3: Decorator Pattern**
```
Add functionality dynamically
Example:
- Coffee (base)
- Coffee + Milk (decorator)
- Coffee + Milk + Sugar (decorator)
```

---

#### 2. **LLD Example: Parking Lot System**

```
Classes:
1. ParkingLot
   - levels: List<Level>
   - totalSlots: int
   - availableSlots: int
   - addLevel(level: Level)
   - getAvailableSlot(): ParkingSlot

2. Level
   - levelNumber: int
   - slots: List<ParkingSlot>
   - availableSlots: int
   - getAvailableSlot(): ParkingSlot

3. ParkingSlot
   - slotNumber: int
   - size: VehicleSize
   - isAvailable: boolean
   - parkVehicle(vehicle: Vehicle)
   - unparkVehicle()

4. Vehicle
   - licensePlate: String
   - size: VehicleSize

5. ParkingTicket
   - ticketNumber: String
   - vehicle: Vehicle
   - entryTime: LocalDateTime
   - exitTime: LocalDateTime
   - getPrice(): double

6. ParkingRate
   - getRate(vehicleSize: VehicleSize): double

Code Example:
class ParkingLot {
    private static ParkingLot instance = null;
    private List<Level> levels;
    
    public static ParkingLot getInstance() {
        if (instance == null) {
            instance = new ParkingLot();
        }
        return instance;
    }
    
    public ParkingTicket parkVehicle(Vehicle vehicle) {
        for (Level level : levels) {
            ParkingSlot slot = level.getAvailableSlot(vehicle.getSize());
            if (slot != null) {
                slot.parkVehicle(vehicle);
                return new ParkingTicket(vehicle);
            }
        }
        return null; // No space available
    }
}
```

---

#### 3. **LLD Example: Library Management System**

```
Classes:
1. Library
   - books: Map<String, List<Book>>
   - members: Map<String, Member>
   - addBook(book: Book)
   - removeBook(bookId: String)

2. Book
   - bookId: String
   - title: String
   - author: String
   - isbn: String
   - isAvailable: boolean

3. Member
   - memberId: String
   - name: String
   - email: String
   - borrowedBooks: List<BorrowRecord>
   - borrowBook(book: Book): BorrowRecord
   - returnBook(book: Book)

4. BorrowRecord
   - borrowDate: LocalDate
   - dueDate: LocalDate
   - returnDate: LocalDate
   - getLateFees(): double

5. Librarian
   - processReturn(record: BorrowRecord)
   - calculateFines()

Class Diagram:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Library   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â”œâ”€ List<Book>
      â”œâ”€ List<Member>
      â””â”€ List<Librarian>

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Book    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ bookId     â”‚
â”‚ title      â”‚
â”‚ author     â”‚
â”‚ isAvailableâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Member   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ memberId   â”‚
â”‚ name       â”‚
â”‚ borrowedBooks
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â””â”€ BorrowRecord

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ BorrowRecord   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ borrowDate     â”‚
â”‚ dueDate        â”‚
â”‚ returnDate     â”‚
â”‚ getLateFees()  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Interview Strategy

### 1. **Before Interview**
- [ ] Practice 150+ LeetCode problems
- [ ] Master 5-6 system design patterns
- [ ] Review coding best practices
- [ ] Mock interview practice
- [ ] Learn APIs for your language

### 2. **During Coding Interview**
```
Step 1: Understand Problem (2 min)
- Read carefully
- Ask clarifying questions
- Identify constraints

Step 2: Approach (3 min)
- State your approach
- Discuss time/space complexity
- Consider edge cases

Step 3: Code (10 min)
- Write clean, readable code
- Use meaningful variable names
- Add comments

Step 4: Test (3 min)
- Test with provided examples
- Test edge cases
- Trace through logic

Step 5: Optimize (2 min)
- Discuss time/space tradeoffs
- Suggest improvements
```

### 3. **During System Design Interview**
```
Step 1: Requirements (5 min)
- Functional requirements
- Non-functional requirements
- Scale estimates

Step 2: High-Level Design (10 min)
- Draw architecture
- Identify major components
- Discuss trade-offs

Step 3: Deep Dive (10 min)
- Database design
- Caching strategy
- Load balancing

Step 4: Bottlenecks & Scaling (5 min)
- Identify potential issues
- Discuss solutions
- Database sharding
```

### 4. **Communication Tips**
- Think out loud
- Explain your reasoning
- Ask questions if stuck
- Acknowledge trade-offs
- Show flexibility in approach

---

## Timeline & Study Plan

### **8-Week Intensive Plan**

#### Week 1-2: Foundation
- **Arrays & Strings** (15 problems)
  - Two pointers: #167, #11, #15
  - Sliding window: #3, #76, #209
  - Hashing: #1, #242, #49
- **Time:** 8 hours

#### Week 3-4: Advanced Data Structures
- **Linked Lists** (8 problems)
  - #141, #206, #92, #25
- **Trees** (12 problems)
  - #94, #102, #100, #101, #104
  - #98, #235, #236
- **Graphs** (8 problems)
  - #200, #547, #207, #210
- **Time:** 12 hours

#### Week 5-6: Dynamic Programming & Recursion
- **DP Patterns** (12 problems)
  - Knapsack: #416, #494
  - DP 1D/2D: #198, #72, #1143
- **Backtracking** (6 problems)
  - #46, #47, #77, #79
- **Time:** 10 hours

#### Week 7: System Design
- **HLD (High-Level Design)** (3 designs)
  - URL Shortener
  - Video Streaming
  - Social Media Feed
- **LLD (Low-Level Design)** (3 designs)
  - Parking Lot
  - Library System
  - ATM Machine
- **Time:** 12 hours

#### Week 8: Practice & Mock
- **Review weak areas**
- **Mock interviews** (3-4)
- **Practice communication**
- **Time:** 10 hours

### **Total Time:** ~52 hours of focused study

---

## Quick Reference: Must-Know Problems

### **Top 50 LeetCode Problems for FAANG**

#### Arrays & Strings (10)
1. #1 - Two Sum
2. #15 - 3Sum
3. #3 - Longest Substring Without Repeating Characters
4. #11 - Container With Most Water
5. #125 - Valid Palindrome
6. #238 - Product of Array Except Self
7. #560 - Subarray Sum Equals K
8. #76 - Minimum Window Substring
9. #49 - Group Anagrams
10. #387 - First Unique Character in a String

#### Linked Lists (5)
1. #206 - Reverse Linked List
2. #141 - Linked List Cycle
3. #21 - Merge Two Sorted Lists
4. #92 - Reverse Linked List II
5. #23 - Merge k Sorted Lists

#### Trees (12)
1. #94 - Binary Tree Inorder Traversal
2. #102 - Binary Tree Level Order Traversal
3. #100 - Same Tree
4. #104 - Maximum Depth of Binary Tree
5. #226 - Invert Binary Tree
6. #98 - Validate Binary Search Tree
7. #235 - Lowest Common Ancestor of BST
8. #236 - Lowest Common Ancestor of Binary Tree
9. #112 - Path Sum
10. #113 - Path Sum II
11. #437 - Path Sum III
12. #199 - Binary Tree Right Side View

#### Dynamic Programming (8)
1. #70 - Climbing Stairs
2. #198 - House Robber
3. #322 - Coin Change
4. #518 - Coin Change II
5. #72 - Edit Distance
6. #1143 - Longest Common Subsequence
7. #416 - Partition Equal Subset Sum
8. #494 - Target Sum

#### Graphs (5)
1. #200 - Number of Islands
2. #547 - Number of Provinces
3. #207 - Course Schedule
4. #210 - Course Schedule II
5. #743 - Network Delay Time

#### Backtracking (5)
1. #46 - Permutations
2. #78 - Subsets
3. #79 - Word Search
4. #51 - N-Queens
5. #37 - Sudoku Solver

#### Heap/Priority Queue (3)
1. #215 - Kth Largest Element in an Array
2. #347 - Top K Frequent Elements
3. #23 - Merge k Sorted Lists

#### Bit Manipulation (2)
1. #136 - Single Number
2. #338 - Counting Bits

---

## Common Mistakes to Avoid

1. **Not understanding problem fully** â†’ Ask clarifying questions
2. **Jumping to coding** â†’ Think first, then code
3. **Not considering edge cases** â†’ Always test boundary conditions
4. **Poor variable naming** â†’ Use clear, descriptive names
5. **Not explaining approach** â†’ Communication is key
6. **Over-complicating solutions** â†’ Start simple, then optimize
7. **Not testing code** â†’ Always trace through examples
8. **Forgetting about complexity** â†’ Know time & space complexity

---

## Resources

### Books
- "Cracking the Coding Interview" by Gayle Laakmann McDowell
- "System Design Interview" by Alex Xu
- "Introduction to Algorithms" (CLRS)

### Websites
- LeetCode.com (Premium recommended)
- InterviewBit.com
- GeeksforGeeks.com
- SystemDesignInterview.com

### YouTube Channels
- Striver (Data Structures)
- TechDummies (System Design)
- CodeHelp (Problem solving)

---

## Final Tips

1. **Consistency over intensity** - Study 1-2 hours daily for 8 weeks
2. **Pattern recognition** - Focus on patterns, not memorizing solutions
3. **Write code** - Always code on paper/editor, not just thinking
4. **Explain clearly** - Practice explaining solutions out loud
5. **Review mistakes** - Learn from every wrong attempt
6. **Mock interviews** - Practice with real people
7. **Stay calm** - Nervousness is normal; take deep breaths

---

## Success Checklist

- [ ] Completed 150+ LeetCode problems
- [ ] Mastered at least 3 system design patterns
- [ ] Can solve medium problems in 20 minutes
- [ ] Can design system in 45 minutes
- [ ] Completed 5+ mock interviews
- [ ] Know complexity analysis well
- [ ] Comfortable with code communication
- [ ] Understand all patterns deeply
- [ ] Can explain solutions clearly
- [ ] Ready for FAANG!

---

**Good Luck! ğŸ¯**

