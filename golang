# Go Language Comprehensive Notes

## Table of Contents
1. [Introduction to Go](#introduction)
2. [Basic Syntax](#basic-syntax)
3. [Variables and Constants](#variables-and-constants)
4. [Data Types](#data-types)
5. [Control Structures](#control-structures)
6. [Functions](#functions)
7. [Arrays and Slices](#arrays-and-slices)
8. [Maps](#maps)
9. [Structs](#structs)
10. [Pointers](#pointers)
11. [Interfaces](#interfaces)
12. [Error Handling](#error-handling)
13. [Goroutines and Concurrency](#goroutines-and-concurrency)
14. [Channels](#channels)
15. [Packages and Modules](#packages-and-modules)

---

## Introduction

### What is Go?

Go (also called Golang) is a statically typed, compiled programming language designed at Google by Robert Griesemer, Rob Pike, and Ken Thompson in 2007 and publicly released in 2009.

### Why Go Was Created

Go was created to solve problems that Google faced with existing languages:
- **Slow compilation times** in C++ for large codebases
- **Complexity** in C++ making it hard to learn and maintain
- **Lack of concurrency support** in traditional languages
- **Poor dependency management** in existing systems

### Key Characteristics

**1. Statically Typed**
- Types are checked at compile time, catching errors before runtime
- Provides type safety and better performance
- But also has type inference for convenience

**2. Compiled Language**
- Go code is compiled to native machine code
- Results in fast execution (close to C/C++ performance)
- Single binary output makes deployment easy

**3. Garbage Collection**
- Automatic memory management
- No manual memory allocation/deallocation needed
- Low-latency GC suitable for server applications

**4. Built-in Concurrency**
- Goroutines: lightweight threads managed by Go runtime
- Channels: safe communication between goroutines
- Makes concurrent programming easy and safe

**5. Simple Syntax**
- Minimal keywords (only 25 keywords)
- One way to do things (opinionated design)
- Easy to read and maintain

**6. Strong Standard Library**
- HTTP servers and clients
- JSON/XML parsing
- Cryptography
- Testing framework
- And much more

### Go's Philosophy

- **Simplicity over complexity**: Easy to learn, read, and maintain
- **Composition over inheritance**: Uses interfaces and embedding
- **Explicit over implicit**: Clear error handling, no hidden control flow
- **Pragmatism**: Designed for real-world software engineering

### Hello World
```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}
```

**To run:**
```bash
go run main.go
```

**To build:**
```bash
go build main.go
./main  # or main.exe on Windows
```

---

## Basic Syntax

### Understanding Go Program Structure

A Go program is organized into packages. Every Go source file belongs to a package, and packages are Go's way of organizing and reusing code.

**Why Packages?**
- **Organization**: Group related code together
- **Encapsulation**: Control what's exported (public) vs internal (private)
- **Reusability**: Import and use code from other packages
- **Namespace**: Avoid naming conflicts

### Package Declaration

Every Go file starts with a package declaration.

**Theory:**
- `package main`: Special package that creates an executable program
  - Must have a `main()` function as entry point
  - Compiled to a binary you can run
  
- `package <name>`: Creates a library package
  - Can be imported by other packages
  - No main function needed
  - Example: `package utils`, `package models`
```go
package main  // executable package
// or
package mypackage  // library package
```

### Imports
```go
// Single import
import "fmt"

// Multiple imports
import (
    "fmt"
    "time"
    "math/rand"
)

// Aliased import
import (
    f "fmt"
    m "math"
)
```

### Comments
```go
// Single line comment

/*
   Multi-line
   comment
*/
```

---

## Variables and Constants

### Understanding Variables in Go

**Theory:**
Variables are named storage locations in memory that hold values. In Go:
- Variables must be used once declared (unused variables cause compilation errors)
- Go is statically typed (type is known at compile time)
- Variables have zero values (default values) if not initialized
- Variable names use camelCase convention

**Memory Concept:**
When you declare `var x int = 42`, Go:
1. Allocates memory space (enough for an int)
2. Associates the name "x" with that memory location
3. Stores the value 42 in that location

### Variable Declaration

```go
package main

import "fmt"

func main() {
    // Method 1: var keyword with type
    var name string = "John"
    
    // Method 2: var keyword with type inference
    var age = 25
    
    // Method 3: Short declaration (only inside functions)
    city := "New York"
    
    // Multiple declarations
    var x, y, z int = 1, 2, 3
    
    // Multiple variables with different types
    var (
        firstName string = "Alice"
        lastName  string = "Smith"
        userAge   int    = 30
    )
    
    fmt.Println(name, age, city)
    fmt.Println(x, y, z)
    fmt.Println(firstName, lastName, userAge)
}
```

### Zero Values

**Theory:**
Go initializes all variables to their "zero value" if no value is provided. This prevents undefined behavior and makes programs more predictable.

**Why Zero Values Matter:**
- No "undefined" or "null pointer" surprises
- Safe to use variables immediately after declaration
- Consistent behavior across all types

**Zero Values by Type:**
- Numbers (int, float): `0`
- Booleans: `false`
- Strings: `""` (empty string)
- Pointers, slices, maps, channels, functions, interfaces: `nil`

Variables declared without an explicit initial value are given their zero value:
```go
package main

import "fmt"

func main() {
    var i int       // 0
    var f float64   // 0.0
    var b bool      // false
    var s string    // "" (empty string)
    
    fmt.Printf("int: %v, float: %v, bool: %v, string: '%v'\n", i, f, b, s)
}
```

### Constants

**Theory:**
Constants are immutable values known at compile time. They:
- Cannot be changed after declaration
- Must be initialized when declared
- Are computed at compile time (not runtime)
- Don't occupy memory at runtime (compiler substitutes values)
- Can be untyped (flexible) or typed (strict)

**Use Cases:**
- Configuration values that never change
- Mathematical constants (Pi, E)
- Status codes, error codes
- API versions

**iota Explained:**
iota is a special constant generator that:
- Starts at 0 in each const block
- Increments by 1 for each line
- Resets in each new const block
- Useful for creating enumerations (enums)
```go
package main

import "fmt"

func main() {
    const Pi = 3.14159
    const Greeting = "Hello"
    
    // Multiple constants
    const (
        StatusOK    = 200
        StatusError = 500
    )
    
    // iota - automatic incrementing
    const (
        Sunday = iota    // 0
        Monday           // 1
        Tuesday          // 2
        Wednesday        // 3
    )
    
    fmt.Println(Pi, Greeting)
    fmt.Println(StatusOK, StatusError)
    fmt.Println(Monday, Wednesday)
}
```

---

## Data Types

### Understanding Go's Type System

**Theory:**
Go has a strong, static type system:
- **Strong typing**: Cannot automatically convert between incompatible types
- **Static typing**: Types are checked at compile time
- **Type safety**: Prevents type-related bugs

**Type Categories:**

1. **Basic Types**: Built into the language
   - Boolean, numeric (integers, floats), string
   
2. **Composite Types**: Built from other types
   - Arrays, slices, maps, structs
   
3. **Reference Types**: Hold references to underlying data
   - Slices, maps, channels, pointers, functions
   
4. **Interface Types**: Define behavior contracts

### Basic Types

**Numeric Types Explained:**

**Integers:**
- `int`: Platform-dependent (32 or 64 bit based on your system)
- `int8`, `int16`, `int32`, `int64`: Specific sizes
- `uint`: Unsigned platform-dependent
- `uint8` (byte), `uint16`, `uint32`, `uint64`: Unsigned specific sizes
- `rune`: Alias for int32, represents Unicode code points

**Why Different Sizes?**
- Memory efficiency: Use smaller types when possible
- Range requirements: int8 (-128 to 127) vs int64 (much larger)
- Interfacing with other systems: Specific sizes for compatibility

**Floating Point:**
- `float32`: 32-bit IEEE-754 (6-7 decimal precision)
- `float64`: 64-bit IEEE-754 (15-16 decimal precision)
- Use float64 by default for better precision

**Complex Numbers:**
- `complex64`: Two float32 (real + imaginary)
- `complex128`: Two float64
- Useful for scientific computing, signal processing
```go
package main

import "fmt"

func main() {
    // Boolean
    var isActive bool = true
    
    // String
    var message string = "Hello, Go!"
    
    // Integers
    var age int = 25           // Platform dependent (32 or 64 bit)
    var count int8 = 127       // -128 to 127
    var total int16 = 32767    // -32768 to 32767
    var population int32 = 1000000
    var bigNumber int64 = 9223372036854775807
    
    // Unsigned integers
    var positiveAge uint = 25
    var byteValue byte = 255   // alias for uint8
    var runeValue rune = '⌘'   // alias for int32, represents Unicode
    
    // Floating point
    var price float32 = 99.99
    var pi float64 = 3.14159265359
    
    // Complex numbers
    var complexNum complex64 = 1 + 2i
    var complexNum2 complex128 = complex(3, 4)
    
    fmt.Println(isActive, message, age)
    fmt.Println(price, pi)
    fmt.Println(complexNum, complexNum2)
}
```

### Type Conversion

**Theory:**
Go requires explicit type conversion - there's no automatic/implicit conversion.

**Why Explicit Conversion?**
- **Clarity**: Code intent is clear
- **Safety**: Prevents accidental data loss
- **Predictability**: No hidden conversions

**Conversion Rules:**
1. Numeric conversions may lose precision (float to int loses decimals)
2. Converting larger type to smaller may overflow
3. String conversions require strconv package (special handling)
4. Pointer conversions need unsafe package (dangerous)
```go
package main

import (
    "fmt"
    "strconv"
)

func main() {
    // Numeric conversions
    var x int = 42
    var y float64 = float64(x)
    var z uint = uint(y)
    
    fmt.Printf("x: %v (type: %T)\n", x, x)
    fmt.Printf("y: %v (type: %T)\n", y, y)
    fmt.Printf("z: %v (type: %T)\n", z, z)
    
    // String conversions
    str := "123"
    num, err := strconv.Atoi(str)  // String to int
    if err == nil {
        fmt.Println("Converted:", num)
    }
    
    number := 456
    text := strconv.Itoa(number)   // Int to string
    fmt.Println("String:", text)
    
    // Parse float
    floatStr := "3.14"
    floatNum, _ := strconv.ParseFloat(floatStr, 64)
    fmt.Println("Float:", floatNum)
}
```

---

## Control Structures

### Understanding Control Flow

**Theory:**
Control structures determine the order in which code executes. Go keeps it simple:
- No parentheses required around conditions
- Braces `{}` are mandatory (even for single statements)
- Can declare variables in condition statements

**Go's Simplicity:**
- Only one loop construct: `for`
- No while or do-while (use `for` instead)
- No ternary operator `? :` (use if-else)
- Switch doesn't need break (no fall-through by default)

### If-Else

**Theory:**
if-else provides conditional execution based on boolean expressions.

**Key Features:**
1. **No parentheses**: `if x > 5` not `if (x > 5)`
2. **Short statement**: Can declare variables in condition
3. **Scope**: Variables declared in if are scoped to if-else block
4. **Mandatory braces**: Always use `{}`

**When to Use Short Statement:**
```go
if err := doSomething(); err != nil {
    // err only exists in this block
}
// err doesn't exist here
```
Useful for error checking and temporary variables
```go
package main

import "fmt"

func main() {
    age := 20
    
    // Basic if-else
    if age >= 18 {
        fmt.Println("Adult")
    } else {
        fmt.Println("Minor")
    }
    
    // If with initialization
    if score := 85; score >= 90 {
        fmt.Println("Grade A")
    } else if score >= 80 {
        fmt.Println("Grade B")
    } else {
        fmt.Println("Grade C or below")
    }
}
```

### Switch

**Theory:**
Switch provides multi-way conditional execution.

**Go's Switch is Different:**
1. **No break needed**: Cases don't fall through by default
2. **fallthrough keyword**: Explicitly fall through if needed
3. **Multiple values**: `case 1, 2, 3:` checks multiple values
4. **Expressions**: Cases can be expressions, not just constants
5. **No condition**: Switch without condition acts like if-else chain
6. **Type switch**: Check variable type

**Why No Fall-through?**
- Fall-through is error-prone in other languages
- Most of the time you don't want it
- Go makes the common case easy
```go
package main

import (
    "fmt"
    "time"
)

func main() {
    // Basic switch
    day := "Monday"
    
    switch day {
    case "Monday":
        fmt.Println("Start of the week")
    case "Friday":
        fmt.Println("TGIF!")
    case "Saturday", "Sunday":
        fmt.Println("Weekend!")
    default:
        fmt.Println("Midweek day")
    }
    
    // Switch without condition (like if-else chain)
    hour := time.Now().Hour()
    
    switch {
    case hour < 12:
        fmt.Println("Good morning")
    case hour < 18:
        fmt.Println("Good afternoon")
    default:
        fmt.Println("Good evening")
    }
    
    // Type switch
    var i interface{} = "hello"
    
    switch v := i.(type) {
    case int:
        fmt.Printf("Integer: %d\n", v)
    case string:
        fmt.Printf("String: %s\n", v)
    case bool:
        fmt.Printf("Boolean: %v\n", v)
    default:
        fmt.Printf("Unknown type\n")
    }
}
```

### Loops

**Theory:**
Go simplifies looping by having only one keyword: `for`

**Why Only `for`?**
- Reduces language complexity
- `for` can do everything while/do-while can do
- One way to do things (Go's philosophy)

**Four Forms of For Loop:**

1. **Classic for**: `for init; condition; post {}`
   - Like C/Java for loops
   - init: runs once at start
   - condition: checked before each iteration
   - post: runs after each iteration

2. **While-style**: `for condition {}`
   - Like while loops in other languages
   - Loops while condition is true

3. **Infinite loop**: `for {}`
   - Loops forever until break/return
   - Use with break to exit when needed

4. **Range loop**: `for index, value := range collection {}`
   - Iterates over arrays, slices, maps, strings, channels
   - Returns index/key and value

**Loop Control:**
- `break`: Exit loop immediately
- `continue`: Skip to next iteration
- `goto`: Jump to label (rarely used, discouraged)

Go has only `for` loops, but they can be used in different ways:

```go
package main

import "fmt"

func main() {
    // Classic for loop
    for i := 0; i < 5; i++ {
        fmt.Println(i)
    }
    
    // While-style loop
    count := 0
    for count < 3 {
        fmt.Println("Count:", count)
        count++
    }
    
    // Infinite loop (use with break)
    counter := 0
    for {
        if counter >= 3 {
            break
        }
        fmt.Println("Infinite loop:", counter)
        counter++
    }
    
    // Continue statement
    for i := 0; i < 5; i++ {
        if i == 2 {
            continue  // Skip iteration
        }
        fmt.Println("Value:", i)
    }
    
    // Range loop (for arrays, slices, maps)
    numbers := []int{1, 2, 3, 4, 5}
    for index, value := range numbers {
        fmt.Printf("Index: %d, Value: %d\n", index, value)
    }
    
    // Range without index
    for _, value := range numbers {
        fmt.Println(value)
    }
}
```

---

## Functions

### Understanding Functions in Go

**Theory:**
Functions are first-class citizens in Go, meaning:
- Functions can be assigned to variables
- Functions can be passed as arguments
- Functions can be returned from other functions
- Functions can be anonymous (lambdas)

**Function Signature Components:**
```go
func functionName(param1 type1, param2 type2) (return1 type1, return2 type2) {
    // function body
}
```

**Key Concepts:**

1. **Multiple Return Values**
   - Common pattern: `(result, error)`
   - Allows returning both data and error state
   - Must handle or explicitly ignore all return values

2. **Named Return Values**
   - Pre-declares return variables
   - Can use "naked return" (just `return`)
   - Acts as documentation
   - Initialized to zero values

3. **Variadic Functions**
   - Accept variable number of arguments
   - Last parameter uses `...type` syntax
   - Inside function, treated as slice
   - Example: `fmt.Println` accepts any number of arguments

4. **Pass by Value**
   - Go passes arguments by value (copies data)
   - To modify original: pass pointer or use reference types
   - Slices, maps, channels are reference types (share underlying data)

### Basic Functions
```go
package main

import "fmt"

// Simple function
func greet() {
    fmt.Println("Hello!")
}

// Function with parameters
func add(a int, b int) int {
    return a + b
}

// Shortened parameter syntax
func multiply(a, b int) int {
    return a * b
}

// Multiple return values
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, fmt.Errorf("cannot divide by zero")
    }
    return a / b, nil
}

// Named return values
func rectangle(length, width float64) (area, perimeter float64) {
    area = length * width
    perimeter = 2 * (length + width)
    return  // naked return
}

// Variadic functions
func sum(numbers ...int) int {
    total := 0
    for _, num := range numbers {
        total += num
    }
    return total
}

func main() {
    greet()
    
    result := add(5, 3)
    fmt.Println("Add:", result)
    
    quotient, err := divide(10, 2)
    if err != nil {
        fmt.Println("Error:", err)
    } else {
        fmt.Println("Divide:", quotient)
    }
    
    area, perimeter := rectangle(5, 3)
    fmt.Printf("Area: %.2f, Perimeter: %.2f\n", area, perimeter)
    
    total := sum(1, 2, 3, 4, 5)
    fmt.Println("Sum:", total)
}
```

### Anonymous Functions and Closures

**Theory:**

**Anonymous Functions:**
- Functions without a name
- Can be defined inline
- Often used for short-lived operations
- Common in goroutines and callbacks

**Closures:**
A closure is a function that "closes over" (captures) variables from its surrounding scope.

**How Closures Work:**
```go
func makeCounter() func() int {
    count := 0  // This variable is captured
    return func() int {
        count++  // Closure accesses outer variable
        return count
    }
}
```

**Key Points:**
1. Inner function can access outer function's variables
2. Variables remain alive even after outer function returns
3. Each closure gets its own copy of captured variables
4. Useful for maintaining state, callbacks, decorators

**Use Cases:**
- Event handlers
- Callbacks
- Goroutines that need access to local variables
- Factory functions
- Middleware patterns
```go
package main

import "fmt"

func main() {
    // Anonymous function
    func() {
        fmt.Println("Anonymous function")
    }()
    
    // Assign to variable
    square := func(x int) int {
        return x * x
    }
    fmt.Println("Square:", square(5))
    
    // Closure - function that captures variables
    counter := func() func() int {
        count := 0
        return func() int {
            count++
            return count
        }
    }()
    
    fmt.Println(counter())  // 1
    fmt.Println(counter())  // 2
    fmt.Println(counter())  // 3
}
```

### Defer Statement

**Theory:**
Defer schedules a function call to execute after the surrounding function returns.

**How Defer Works:**
1. Defer statement is executed immediately
2. Function call is pushed onto a stack
3. Arguments are evaluated immediately
4. Function executes when surrounding function returns
5. Multiple defers execute in LIFO (Last In, First Out) order

**Why LIFO Order?**
```go
file.Open()    // Open file
defer file.Close()  // Close file

lock.Lock()    // Acquire lock  
defer lock.Unlock()  // Release lock
```
Reverse order ensures proper cleanup (unlock before close)

**Common Use Cases:**
1. **Resource Cleanup**: Close files, connections, locks
2. **Logging**: Log function exit
3. **Error Recovery**: Recover from panics
4. **Timing**: Measure function execution time

**Important:**
- Deferred arguments are evaluated immediately
- Deferred functions can modify named return values
- Defer runs even if panic occurs (before panic propagates)
```go
package main

import "fmt"

func main() {
    // Defer executes after surrounding function returns
    defer fmt.Println("World")
    fmt.Println("Hello")
    
    // Multiple defers execute in LIFO order
    defer fmt.Println("1")
    defer fmt.Println("2")
    defer fmt.Println("3")
    fmt.Println("Start")
    // Output: Start, 3, 2, 1
    
    // Common use: resource cleanup
    // defer file.Close()
    // defer db.Close()
}
```

---

## Arrays and Slices

### Understanding Arrays vs Slices

**Theory:**
Go has two sequence types: arrays (fixed-size) and slices (dynamic-size).

**Why Two Types?**
- Arrays: When size is known and fixed (rare in practice)
- Slices: When size is dynamic (most common use case)

**Memory Model:**
```
Array: [value][value][value][value][value]
       ↑ Fixed size, values stored directly

Slice: [ptr][len][cap] → [value][value][value][value][value]
       ↑ Header with pointer to underlying array
```

### Arrays

**Theory:**
Arrays in Go are:
- **Fixed size**: Size is part of type (`[5]int` ≠ `[10]int`)
- **Value types**: Copying creates new array with copied values
- **Zero-initialized**: All elements start at zero value
- **Pass by value**: Passing to function copies entire array

**When to Use Arrays:**
- Size is known at compile time and won't change
- Need value semantics (independent copy)
- Interfacing with fixed-size APIs
- Performance-critical code with small, fixed data

**Why Arrays Are Rare:**
- Size can't change
- Copying large arrays is expensive
- Slices are more flexible

Fixed-size sequences of elements:

```go
package main

import "fmt"

func main() {
    // Array declaration
    var arr1 [5]int  // Zero values: [0 0 0 0 0]
    
    // Array initialization
    arr2 := [5]int{1, 2, 3, 4, 5}
    
    // Let compiler count
    arr3 := [...]int{10, 20, 30}
    
    // Access elements
    fmt.Println("First:", arr2[0])
    arr2[0] = 100
    fmt.Println("Modified:", arr2)
    
    // Array length
    fmt.Println("Length:", len(arr2))
    
    // Iterate over array
    for i, v := range arr3 {
        fmt.Printf("Index %d: %d\n", i, v)
    }
    
    // 2D array
    matrix := [2][3]int{
        {1, 2, 3},
        {4, 5, 6},
    }
    fmt.Println("Matrix:", matrix)
}
```

### Slices

**Theory:**
Slices are Go's most used data structure for sequences.

**Slice Internals:**
A slice is a struct with three fields:
```go
type slice struct {
    ptr *element  // Pointer to underlying array
    len int       // Number of elements
    cap int       // Capacity of underlying array
}
```

**Length vs Capacity:**
- **Length**: Number of elements in slice
- **Capacity**: Number of elements in underlying array from first element of slice

**Why This Design?**
1. **Efficient**: Only copies 3 words (ptr, len, cap), not all data
2. **Flexible**: Can grow and shrink
3. **View**: Multiple slices can share same underlying array

**Slice Operations:**

1. **Slicing** `s[low:high]`:
   - Creates new slice viewing same array
   - Shares underlying data (changes affect both)
   - New length: `high - low`
   - New capacity: from low to end of array

2. **Append**:
   - Adds elements to slice
   - If capacity sufficient: modifies existing array
   - If capacity insufficient: allocates new array (2x capacity)
   - Always use returned slice: `s = append(s, elem)`

3. **Copy**:
   - Copies elements between slices
   - Doesn't share underlying array
   - Safe for independent modifications

**nil Slice vs Empty Slice:**
- `var s []int`: nil slice (len=0, cap=0, ptr=nil)
- `s := []int{}`: empty slice (len=0, cap=0, ptr≠nil)
- Both have length 0, but nil slice uses less memory

Dynamic-size, flexible view into arrays:

```go
package main

import "fmt"

func main() {
    // Create slice
    slice1 := []int{1, 2, 3, 4, 5}
    
    // Make slice with make()
    slice2 := make([]int, 5)      // length 5, capacity 5
    slice3 := make([]int, 3, 10)  // length 3, capacity 10
    
    fmt.Println("Slice1:", slice1)
    fmt.Println("Slice2:", slice2)
    fmt.Println("Length:", len(slice3), "Capacity:", cap(slice3))
    
    // Slicing operations
    numbers := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    fmt.Println("numbers[2:5]:", numbers[2:5])   // [2 3 4]
    fmt.Println("numbers[:4]:", numbers[:4])     // [0 1 2 3]
    fmt.Println("numbers[6:]:", numbers[6:])     // [6 7 8 9]
    fmt.Println("numbers[:]:", numbers[:])       // entire slice
    
    // Append to slice
    slice1 = append(slice1, 6)
    slice1 = append(slice1, 7, 8, 9)
    fmt.Println("After append:", slice1)
    
    // Append slice to slice
    slice4 := []int{10, 11, 12}
    slice1 = append(slice1, slice4...)
    fmt.Println("After append slice:", slice1)
    
    // Copy slice
    slice5 := make([]int, len(slice1))
    copy(slice5, slice1)
    fmt.Println("Copied:", slice5)
    
    // Remove element (example: remove index 2)
    index := 2
    slice1 = append(slice1[:index], slice1[index+1:]...)
    fmt.Println("After removal:", slice1)
}
```

---

## Maps

### Understanding Maps

**Theory:**
Maps are Go's built-in hash table/dictionary implementation.

**How Maps Work:**
1. Hash function converts key to integer (hash code)
2. Hash code determines bucket location
3. Value stored in that bucket
4. Collisions handled with chaining or probing

**Map Characteristics:**
- **Reference type**: Maps are references to underlying hash table
- **Unordered**: Iteration order is random (intentionally)
- **Dynamic**: Grows automatically as you add elements
- **nil map**: Cannot add to nil map (causes panic)
- **Zero value**: Accessing missing key returns zero value

**Key Requirements:**
- Keys must be comparable (can use `==`)
- Valid: int, string, pointer, array, struct (with comparable fields)
- Invalid: slices, maps, functions (not comparable)

**Why Random Iteration?**
Go intentionally randomizes map iteration to:
- Prevent code from depending on order
- Avoid security issues (hash collision attacks)
- Make bugs obvious (order-dependent code fails randomly)

**Performance:**
- Average O(1) for lookup, insert, delete
- Worst case O(n) with many collisions (rare)

**Thread Safety:**
- Maps are NOT thread-safe
- Concurrent reads are safe
- Concurrent read+write needs synchronization (mutex or sync.Map)

Key-value pairs (hash tables/dictionaries):

```go
package main

import "fmt"

func main() {
    // Create map using make
    ages := make(map[string]int)
    
    // Add key-value pairs
    ages["Alice"] = 25
    ages["Bob"] = 30
    ages["Charlie"] = 35
    
    // Map literal
    colors := map[string]string{
        "red":   "#FF0000",
        "green": "#00FF00",
        "blue":  "#0000FF",
    }
    
    // Access values
    fmt.Println("Alice's age:", ages["Alice"])
    fmt.Println("Red color code:", colors["red"])
    
    // Check if key exists
    age, exists := ages["David"]
    if exists {
        fmt.Println("David's age:", age)
    } else {
        fmt.Println("David not found")
    }
    
    // Delete key
    delete(ages, "Bob")
    fmt.Println("After deletion:", ages)
    
    // Iterate over map
    for name, age := range ages {
        fmt.Printf("%s is %d years old\n", name, age)
    }
    
    // Map length
    fmt.Println("Map size:", len(colors))
    
    // Map with struct values
    type Person struct {
        Name string
        Age  int
    }
    
    people := map[int]Person{
        1: {Name: "Alice", Age: 25},
        2: {Name: "Bob", Age: 30},
    }
    
    fmt.Println("People:", people)
}
```

---

## Structs

### Understanding Structs

**Theory:**
Structs are Go's way of creating custom data types by grouping related fields.

**Why Structs?**
- Group related data together
- Create domain models (User, Product, Order)
- Alternative to classes in OOP languages
- Foundation of Go's type system

**Struct Characteristics:**
1. **Value types**: Copying creates independent copy
2. **Zero value**: All fields initialized to their zero values
3. **Memory layout**: Fields stored sequentially in memory
4. **Exported fields**: Capitalized = public, lowercase = private

**Methods on Structs:**
Go doesn't have classes, but structs can have methods:
```go
func (receiver Type) MethodName() returnType {
    // method body
}
```

**Receiver Types:**

1. **Value receiver** `(s MyStruct)`:
   - Method receives copy of struct
   - Cannot modify original struct
   - Use for: small structs, read-only operations
   
2. **Pointer receiver** `(s *MyStruct)`:
   - Method receives pointer to struct
   - Can modify original struct
   - More efficient (no copying)
   - Use for: modifying struct, large structs

**Embedding (Composition):**
Go uses composition over inheritance:
```go
type Person struct {
    Name string
}

type Employee struct {
    Person  // Embedded struct
    EmployeeID int
}
```
- Employee "has a" Person (composition)
- Person's fields/methods promoted to Employee
- Access directly: `emp.Name` not `emp.Person.Name`

**Why Composition?**
- Simpler than inheritance
- More flexible
- Easier to understand
- Avoid deep inheritance hierarchies

**Struct Tags:**
Metadata attached to fields:
```go
type User struct {
    Name string `json:"name" db:"user_name"`
}
```
- Used by reflection-based libraries
- Common: JSON, XML, database mapping
- Format: `key:"value" key2:"value2"`

Custom data types that group related fields:

```go
package main

import "fmt"

// Define struct
type Person struct {
    FirstName string
    LastName  string
    Age       int
    Email     string
}

// Struct with embedded struct
type Address struct {
    Street  string
    City    string
    ZipCode string
}

type Employee struct {
    Person           // Embedded struct (composition)
    Address          // Another embedded struct
    EmployeeID int
    Department string
}

// Method on struct
func (p Person) FullName() string {
    return p.FirstName + " " + p.LastName
}

// Method with pointer receiver (can modify struct)
func (p *Person) HaveBirthday() {
    p.Age++
}

func main() {
    // Create struct instance
    person1 := Person{
        FirstName: "John",
        LastName:  "Doe",
        Age:       30,
        Email:     "john@example.com",
    }
    
    // Short syntax
    person2 := Person{"Jane", "Smith", 25, "jane@example.com"}
    
    // Partial initialization
    person3 := Person{FirstName: "Bob", Age: 40}
    
    // Access fields
    fmt.Println("Name:", person1.FirstName, person1.LastName)
    fmt.Println("Full name:", person1.FullName())
    
    // Modify fields
    person1.Age = 31
    person1.HaveBirthday()
    fmt.Println("New age:", person1.Age)
    
    // Pointer to struct
    person4 := &Person{
        FirstName: "Alice",
        LastName:  "Johnson",
        Age:       28,
    }
    fmt.Println("Via pointer:", person4.FirstName)
    
    // Embedded struct
    emp := Employee{
        Person: Person{
            FirstName: "Tom",
            LastName:  "Brown",
            Age:       35,
        },
        Address: Address{
            Street:  "123 Main St",
            City:    "New York",
            ZipCode: "10001",
        },
        EmployeeID: 1001,
        Department: "Engineering",
    }
    
    // Access embedded fields directly
    fmt.Printf("%s works in %s\n", emp.FullName(), emp.Department)
    fmt.Printf("Lives in %s\n", emp.City)
    
    // Anonymous struct
    product := struct {
        Name  string
        Price float64
    }{
        Name:  "Laptop",
        Price: 999.99,
    }
    fmt.Println("Product:", product)
}
```

---

## Pointers

### Understanding Pointers

**Theory:**
A pointer is a variable that stores the memory address of another variable.

**Why Pointers?**
1. **Efficiency**: Pass large structs by reference, not by value
2. **Modification**: Allow functions to modify caller's variables
3. **Shared data**: Multiple variables can point to same data
4. **Optional values**: nil pointer can represent "no value"

**Memory Visualization:**
```
Variable x:     Memory Address:    Value:
   x            0x1000             42
   p            0x2000             0x1000  (address of x)
```

**Pointer Operations:**

1. **Address-of operator** `&`:
   - Gets memory address of variable
   - `&x` returns pointer to x
   
2. **Dereference operator** `*`:
   - Accesses value at address
   - `*p` gets value that p points to
   - Also used to declare pointer types: `*int`

**Pointer Types:**
```go
var p *int        // pointer to int
var q *string     // pointer to string
var r *MyStruct   // pointer to struct
```

**nil Pointer:**
- Zero value of pointers
- Points to nothing (no memory address)
- Dereferencing nil pointer causes panic
- Always check for nil before dereferencing

**Pointer vs Value Semantics:**

```go
// Value semantics (copy)
func modifyValue(x int) {
    x = 100  // Modifies local copy
}

// Pointer semantics (reference)
func modifyPointer(x *int) {
    *x = 100  // Modifies original
}
```

**Go's Pointer Safety:**
- No pointer arithmetic (can't do `p++` to move pointer)
- No casting pointers to integers
- Prevents many memory bugs
- Use `unsafe` package to bypass (dangerous)

**When to Use Pointers:**
1. Modifying function arguments
2. Large structs (avoid copying)
3. Implementing data structures (trees, linked lists)
4. Sharing state between goroutines

**When NOT to Use Pointers:**
1. Small values (int, bool, small structs)
2. Slices, maps, channels (already references)
3. Interfaces (contain pointer internally)

Variables that store memory addresses:

```go
package main

import "fmt"

func main() {
    // Basic pointers
    x := 42
    var p *int = &x  // p points to x
    
    fmt.Println("Value of x:", x)
    fmt.Println("Address of x:", &x)
    fmt.Println("Pointer p:", p)
    fmt.Println("Value at p:", *p)  // Dereferencing
    
    // Modify through pointer
    *p = 100
    fmt.Println("New value of x:", x)
    
    // Zero value of pointer is nil
    var ptr *int
    if ptr == nil {
        fmt.Println("Pointer is nil")
    }
    
    // Pointers with functions
    y := 5
    increment(&y)
    fmt.Println("After increment:", y)
    
    // Pointer to struct
    type Person struct {
        Name string
        Age  int
    }
    
    person := Person{Name: "Alice", Age: 25}
    personPtr := &person
    
    // Both syntaxes work for struct pointers
    personPtr.Age = 26
    (*personPtr).Name = "Alicia"
    
    fmt.Println("Person:", person)
    
    // New function - allocates memory and returns pointer
    numPtr := new(int)
    *numPtr = 10
    fmt.Println("New int:", *numPtr)
}

func increment(n *int) {
    *n = *n + 1
}
```

---

## Interfaces

### Understanding Interfaces

**Theory:**
Interfaces define behavior by specifying method signatures without implementation.

**Key Concept:**
"If it walks like a duck and quacks like a duck, it's a duck"
- In Go: If a type has required methods, it implements the interface
- No explicit declaration needed (implicit implementation)

**Why Interfaces?**
1. **Abstraction**: Define what something does, not how
2. **Polymorphism**: Different types can be treated uniformly
3. **Decoupling**: Depend on behavior, not concrete types
4. **Testing**: Easy to mock/stub for tests
5. **Flexibility**: Add new implementations without changing existing code

**How Interfaces Work:**
```go
type Shape interface {
    Area() float64  // Method signature
}

// Rectangle implements Shape (implicitly)
type Rectangle struct { Width, Height float64 }

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}
```

**Interface Internals:**
An interface value holds:
```go
type interface struct {
    type *_type       // Type information
    data unsafe.Pointer  // Pointer to actual value
}
```

**Empty Interface:**
`interface{}` or `any` (Go 1.18+) can hold any type:
- No methods required
- Similar to `Object` in Java or `void*` in C
- Used for generic containers, unmarshaling JSON
- Type assertions needed to get actual value back

**Type Assertion:**
```go
var i interface{} = "hello"

// Type assertion
s := i.(string)  // Gets string, panics if wrong type

// Safe type assertion  
s, ok := i.(string)  // ok is false if wrong type
if ok {
    // Use s
}
```

**Type Switch:**
Check which type an interface holds:
```go
switch v := i.(type) {
case int:
    // v is int
case string:
    // v is string
default:
    // unknown type
}
```

**Interface Satisfaction:**
A type implements interface if it has all required methods:
- Method names must match
- Method signatures must match
- Receiver type doesn't matter (value or pointer)

**Pointer vs Value Receivers:**
```go
type Reader interface {
    Read() string
}

// Value receiver
func (t T) Read() string { ... }
// Both T and *T implement Reader

// Pointer receiver  
func (t *T) Read() string { ... }
// Only *T implements Reader
```

**Small Interface Principle:**
Go favors small, focused interfaces:
- Single method interfaces are common (Reader, Writer, Closer)
- Compose small interfaces into larger ones
- "Accept interfaces, return structs"

**Common Standard Interfaces:**
1. `io.Reader`: Read data
2. `io.Writer`: Write data
3. `io.Closer`: Close resource
4. `fmt.Stringer`: String representation
5. `error`: Error handling
6. `sort.Interface`: Sorting

Define behavior (method sets):

```go
package main

import (
    "fmt"
    "math"
)

// Interface definition
type Shape interface {
    Area() float64
    Perimeter() float64
}

// Struct 1: Rectangle
type Rectangle struct {
    Width  float64
    Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}

// Struct 2: Circle
type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return math.Pi * c.Radius * c.Radius
}

func (c Circle) Perimeter() float64 {
    return 2 * math.Pi * c.Radius
}

// Function that accepts interface
func printShapeInfo(s Shape) {
    fmt.Printf("Area: %.2f, Perimeter: %.2f\n", s.Area(), s.Perimeter())
}

// Empty interface (interface{}) - can hold any type
func describe(i interface{}) {
    fmt.Printf("Type: %T, Value: %v\n", i, i)
}

// Type assertion
func processValue(i interface{}) {
    // Check specific type
    if str, ok := i.(string); ok {
        fmt.Println("String:", str)
    } else if num, ok := i.(int); ok {
        fmt.Println("Integer:", num)
    } else {
        fmt.Println("Unknown type")
    }
}

func main() {
    // Create shapes
    rect := Rectangle{Width: 10, Height: 5}
    circle := Circle{Radius: 7}
    
    // Use interface
    printShapeInfo(rect)
    printShapeInfo(circle)
    
    // Store in interface variable
    var shape Shape
    shape = rect
    fmt.Printf("Rectangle area: %.2f\n", shape.Area())
    
    shape = circle
    fmt.Printf("Circle area: %.2f\n", shape.Area())
    
    // Empty interface
    describe(42)
    describe("hello")
    describe(3.14)
    describe(rect)
    
    // Type assertion
    processValue("test")
    processValue(123)
}
```

### Common Interfaces

```go
package main

import (
    "fmt"
    "io"
    "strings"
)

// Stringer interface - custom string representation
type Person struct {
    Name string
    Age  int
}

func (p Person) String() string {
    return fmt.Sprintf("%s (%d years old)", p.Name, p.Age)
}

// Error interface
type MyError struct {
    Message string
    Code    int
}

func (e MyError) Error() string {
    return fmt.Sprintf("Error %d: %s", e.Code, e.Message)
}

func main() {
    // Stringer interface
    person := Person{Name: "Alice", Age: 30}
    fmt.Println(person)  // Calls String() method
    
    // Reader interface
    reader := strings.NewReader("Hello, Go!")
    buf := make([]byte, 8)
    
    for {
        n, err := reader.Read(buf)
        if err == io.EOF {
            break
        }
        fmt.Printf("Read %d bytes: %s\n", n, buf[:n])
    }
    
    // Custom error
    err := MyError{Message: "Something went wrong", Code: 500}
    fmt.Println(err)
}
```

---

## Error Handling

### Understanding Go's Error Philosophy

**Theory:**
Go uses explicit error values instead of exceptions (try/catch).

**Why Not Exceptions?**

Problems with exceptions:
1. **Hidden control flow**: Can't see where errors might occur
2. **Forgotten handling**: Easy to forget try/catch
3. **Performance**: Exception handling has overhead
4. **Complexity**: Deep exception hierarchies

**Go's Approach:**
```go
result, err := doSomething()
if err != nil {
    // Handle error
}
// Use result
```

**Benefits:**
1. **Explicit**: Can see error handling in code
2. **Simple**: Just if statements
3. **Fast**: No exception overhead
4. **Clear**: Error handling path is obvious

**The error Interface:**
```go
type error interface {
    Error() string  // Returns error message
}
```
- Any type with `Error() string` is an error
- `nil` means no error
- Non-nil means error occurred

**Error Creation:**

1. **errors.New()**: Simple string errors
   ```go
   err := errors.New("something went wrong")
   ```

2. **fmt.Errorf()**: Formatted errors
   ```go
   err := fmt.Errorf("failed to open file: %s", filename)
   ```

3. **Custom errors**: Implement error interface
   ```go
   type MyError struct {
       Code int
       Msg  string
   }
   
   func (e *MyError) Error() string {
       return fmt.Sprintf("error %d: %s", e.Code, e.Msg)
   }
   ```

**Error Wrapping (Go 1.13+):**
```go
// Wrap error with context
err := fmt.Errorf("failed to process: %w", originalErr)

// Unwrap to get original
original := errors.Unwrap(err)

// Check for specific error
if errors.Is(err, ErrNotFound) {
    // Handle not found
}

// Check error type
var pathErr *os.PathError
if errors.As(err, &pathErr) {
    // Use pathErr
}
```

**Error Handling Patterns:**

1. **Return early**:
   ```go
   if err != nil {
       return err  // Propagate error up
   }
   ```

2. **Add context**:
   ```go
   if err != nil {
       return fmt.Errorf("failed to save user: %w", err)
   }
   ```

3. **Handle and continue**:
   ```go
   if err != nil {
       log.Printf("warning: %v", err)
       // Continue execution
   }
   ```

4. **Fatal error**:
   ```go
   if err != nil {
       log.Fatal(err)  // Exit program
   }
   ```

**Panic and Recover:**

**Panic**:
- Stops normal execution
- Runs deferred functions
- Program crashes (unless recovered)
- Use for: unrecoverable errors, programming bugs

**Recover**:
- Catches panic
- Must be called in deferred function
- Returns panic value
- Use for: preventing crash, cleanup

```go
func safe() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered:", r)
        }
    }()
    
    panic("something bad happened")
}
```

**When to Use What:**
- **Errors**: Expected failures (file not found, network timeout)
- **Panic**: Programming bugs (index out of range, nil pointer)
- **Recover**: Library code that shouldn't crash user's program

**Best Practices:**
1. Always check errors (don't ignore with `_`)
2. Add context when wrapping errors
3. Return errors, don't log and return
4. Create custom error types for important cases
5. Don't panic in library code
6. Use sentinel errors sparingly (`var ErrNotFound = errors.New(...)`)

Go uses explicit error values rather than exceptions:

```go
package main

import (
    "errors"
    "fmt"
    "strconv"
)

// Return error from function
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

// Custom error type
type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation error on field '%s': %s", e.Field, e.Message)
}

// Function with custom error
func validateAge(age int) error {
    if age < 0 {
        return &ValidationError{
            Field:   "age",
            Message: "must be positive",
        }
    }
    if age > 150 {
        return &ValidationError{
            Field:   "age",
            Message: "must be realistic",
        }
    }
    return nil
}

// Error wrapping (Go 1.13+)
func processData(data string) error {
    _, err := strconv.Atoi(data)
    if err != nil {
        return fmt.Errorf("failed to process data: %w", err)
    }
    return nil
}

func main() {
    // Basic error handling
    result, err := divide(10, 2)
    if err != nil {
        fmt.Println("Error:", err)
    } else {
        fmt.Println("Result:", result)
    }
    
    // Error case
    _, err = divide(10, 0)
    if err != nil {
        fmt.Println("Error:", err)
    }
    
    // Custom error
    err = validateAge(-5)
    if err != nil {
        fmt.Println("Validation error:", err)
    }
    
    err = validateAge(200)
    if err != nil {
        // Type assertion for custom error
        if valErr, ok := err.(*ValidationError); ok {
            fmt.Printf("Field: %s, Message: %s\n", valErr.Field, valErr.Message)
        }
    }
    
    // Error wrapping
    err = processData("abc")
    if err != nil {
        fmt.Println("Wrapped error:", err)
        
        // Unwrap error
        unwrapped := errors.Unwrap(err)
        fmt.Println("Unwrapped:", unwrapped)
    }
    
    // Panic and recover (use sparingly)
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered from panic:", r)
        }
    }()
    
    // This would cause panic
    // panic("Something went terribly wrong!")
}
```

---

## Goroutines and Concurrency

### Understanding Concurrency in Go

**Theory:**
Concurrency is about dealing with multiple things at once. Parallelism is about doing multiple things at once.

**Concurrency vs Parallelism:**
- **Concurrency**: Structure of program (multiple tasks making progress)
- **Parallelism**: Execution of program (tasks running simultaneously)
- Go provides concurrency primitives; parallelism depends on hardware

**Why Go's Concurrency Model?**

Traditional threads:
- Heavy (1-2 MB stack per thread)
- Expensive to create/destroy
- Limited by OS (thousands at most)
- Complex synchronization

Go's goroutines:
- Lightweight (2 KB initial stack)
- Cheap to create (microseconds)
- Millions can run concurrently
- Simple communication via channels

### Goroutines

**What is a Goroutine?**
- Lightweight thread managed by Go runtime
- Not OS threads (many goroutines multiplex onto OS threads)
- Go runtime schedules goroutines (M:N scheduling)
- Stack grows/shrinks dynamically

**How Goroutines Work:**
```
OS Thread 1      OS Thread 2      OS Thread 3
    |                |                |
    +-- G1            +-- G4           +-- G7
    +-- G2            +-- G5           +-- G8  
    +-- G3            +-- G6           +-- G9
    
G = Goroutine
```

**Starting a Goroutine:**
```go
go functionName()  // Runs in new goroutine
go func() {        // Anonymous function
    // code
}()
```

**Goroutine Properties:**
1. Non-blocking: Main doesn't wait for goroutine
2. Independent: Has its own call stack
3. Cheap: Can create millions
4. Scheduled: Go runtime handles scheduling

### Synchronization Primitives

**1. WaitGroup:**
Wait for collection of goroutines to finish:
```go
var wg sync.WaitGroup
wg.Add(1)     // Increment counter
go func() {
    defer wg.Done()  // Decrement when done
    // work
}()
wg.Wait()     // Block until counter is 0
```

**2. Mutex (Mutual Exclusion):**
Protect shared data from concurrent access:
```go
var mu sync.Mutex
mu.Lock()     // Acquire lock
// critical section
mu.Unlock()   // Release lock
```

**Why Mutex?**
- Prevent race conditions
- Only one goroutine in critical section
- Others wait until lock released

**3. RWMutex (Read-Write Mutex):**
Optimize for many readers, few writers:
```go
var rwmu sync.RWMutex
rwmu.RLock()   // Multiple readers can hold
rwmu.RUnlock()

rwmu.Lock()    // Exclusive writer lock
rwmu.Unlock()
```

**Rules:**
- Multiple readers OR one writer
- Never both simultaneously

**Race Conditions:**
```go
// BAD: Race condition
var counter int
go func() { counter++ }()
go func() { counter++ }()

// GOOD: Protected with mutex
var counter int
var mu sync.Mutex
go func() {
    mu.Lock()
    counter++
    mu.Unlock()
}()
```

**Detecting Races:**
```bash
go run -race main.go    # Run with race detector
go test -race           # Test with race detector
```

**Best Practices:**
1. Don't communicate by sharing memory; share memory by communicating (use channels)
2. Always defer unlock after lock
3. Keep critical sections small
4. Avoid nested locks (can deadlock)
5. Use RWMutex for read-heavy workloads
6. Use channels when possible (higher level)

Lightweight threads managed by Go runtime:

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// Simple goroutine
func sayHello(name string) {
    for i := 0; i < 3; i++ {
        fmt.Printf("Hello, %s! (%d)\n", name, i)
        time.Sleep(100 * time.Millisecond)
    }
}

// WaitGroup example
func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done()  // Signal completion
    
    fmt.Printf("Worker %d starting\n", id)
    time.Sleep(time.Second)
    fmt.Printf("Worker %d done\n", id)
}

// Mutex for safe concurrent access
var (
    counter int
    mutex   sync.Mutex
)

func increment(wg *sync.WaitGroup) {
    defer wg.Done()
    
    mutex.Lock()
    counter++
    mutex.Unlock()
}

// RWMutex - allows multiple readers or single writer
var (
    data    map[string]int
    rwMutex sync.RWMutex
)

func readData(key string) int {
    rwMutex.RLock()
    defer rwMutex.RUnlock()
    return data[key]
}

func writeData(key string, value int) {
    rwMutex.Lock()
    defer rwMutex.Unlock()
    data[key] = value
}

func main() {
    // Launch goroutine
    go sayHello("Alice")
    go sayHello("Bob")
    
    // Anonymous goroutine
    go func() {
        fmt.Println("Anonymous goroutine")
    }()
    
    // WaitGroup example
    var wg sync.WaitGroup
    
    for i := 1; i <= 3; i++ {
        wg.Add(1)
        go worker(i, &wg)
    }
    
    wg.Wait()  // Wait for all workers to finish
    fmt.Println("All workers completed")
    
    // Mutex example
    var wg2 sync.WaitGroup
    for i := 0; i < 1000; i++ {
        wg2.Add(1)
        go increment(&wg2)
    }
    wg2.Wait()
    fmt.Printf("Final counter: %d\n", counter)
    
    // RWMutex example
    data = make(map[string]int)
    
    // Writers
    go writeData("key1", 100)
    go writeData("key2", 200)
    
    time.Sleep(100 * time.Millisecond)
    
    // Readers
    fmt.Println("Read key1:", readData("key1"))
    fmt.Println("Read key2:", readData("key2"))
    
    // Keep main alive
    time.Sleep(2 * time.Second)
}
```

---

## Channels

### Understanding Channels

**Theory:**
Channels are typed conduits for communication between goroutines.

**Philosophy:**
"Don't communicate by sharing memory; share memory by communicating."

**Why Channels?**

Traditional approach (shared memory):
```go
var data int
var mu sync.Mutex

mu.Lock()      // Manual locking
data = 42
mu.Unlock()
```

Channel approach:
```go
ch := make(chan int)
ch <- 42       // Send
data := <-ch   // Receive
```

**Benefits:**
- No explicit locks needed
- Type-safe communication
- Synchronization built-in
- Prevent many race conditions

**Channel Types:**

**1. Unbuffered Channels:**
```go
ch := make(chan int)  // No buffer
```
- Send blocks until receive ready
- Receive blocks until send ready
- Synchronous communication
- Guarantees handoff between goroutines

**2. Buffered Channels:**
```go
ch := make(chan int, 5)  // Buffer size 5
```
- Send blocks only if buffer full
- Receive blocks only if buffer empty
- Asynchronous communication (up to buffer size)
- Use for: producer-consumer, rate limiting

**Channel Operations:**

**Send:**
```go
ch <- value  // Send value to channel
```
- Blocks if channel full (or unbuffered and no receiver)
- Panics if channel closed

**Receive:**
```go
value := <-ch         // Receive and assign
value, ok := <-ch     // Receive with status
```
- Blocks if channel empty
- `ok` is false if channel closed and empty

**Close:**
```go
close(ch)  // Close channel
```
- Signals no more values will be sent
- Receivers get zero value and `ok=false`
- Sending to closed channel panics
- Only sender should close

**Range over Channel:**
```go
for value := range ch {
    // Receives until channel closed
}
```

**Select Statement:**
Wait on multiple channel operations:
```go
select {
case v := <-ch1:
    // Received from ch1
case v := <-ch2:
    // Received from ch2
case ch3 <- value:
    // Sent to ch3
default:
    // None ready (non-blocking)
}
```

**Select Properties:**
- Blocks until one case ready
- Random choice if multiple ready
- Default makes it non-blocking
- Use for: timeouts, cancellation, multiplexing

**Channel Directions:**
Restrict channel usage:
```go
func send(ch chan<- int) {  // Send-only
    ch <- 42
}

func receive(ch <-chan int) {  // Receive-only
    value := <-ch
}
```

**Benefits:**
- Clearer intent
- Prevent misuse
- Better API design

**Channel Idioms:**

**1. Done Channel:**
```go
done := make(chan bool)
go func() {
    // work
    done <- true
}()
<-done  // Wait for completion
```

**2. Timeout:**
```go
select {
case result := <-ch:
    // Got result
case <-time.After(5 * time.Second):
    // Timeout
}
```

**3. Cancellation:**
```go
quit := make(chan bool)
go func() {
    for {
        select {
        case <-quit:
            return
        default:
            // work
        }
    }
}()
quit <- true  // Cancel
```

**Common Patterns:**

**1. Pipeline:**
Chain of stages connected by channels:
```go
gen() -> square() -> print()
```

**2. Fan-out, Fan-in:**
- Fan-out: Multiple goroutines read from same channel
- Fan-in: Multiple channels merged into one

**3. Worker Pool:**
Fixed number of workers processing jobs:
```go
jobs := make(chan Job, 100)
for i := 0; i < 5; i++ {
    go worker(jobs)  // 5 workers
}
```

**Deadlock:**
Occurs when goroutines wait on each other:
```go
// DEADLOCK: Nobody to receive
ch := make(chan int)
ch <- 42  // Blocks forever
```

**Preventing Deadlock:**
1. Ensure receiver for every send
2. Use buffered channels
3. Use select with timeout/default
4. Close channels when done

**Best Practices:**
1. Close channels from sender side
2. Check if closed before sending
3. Use buffered channels for known capacity
4. Don't close receive-only channels
5. Nil channels block forever (use in select)
6. Context package for cancellation (modern approach)

Communication between goroutines:

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    // Create unbuffered channel
    ch := make(chan int)
    
    // Send and receive
    go func() {
        ch <- 42  // Send
    }()
    
    value := <-ch  // Receive
    fmt.Println("Received:", value)
    
    // Buffered channel
    buffered := make(chan string, 2)
    buffered <- "hello"
    buffered <- "world"
    // buffered <- "third"  // Would block without buffer space
    
    fmt.Println(<-buffered)
    fmt.Println(<-buffered)
    
    // Channel direction (send-only, receive-only)
    messages := make(chan string)
    
    go sendOnly(messages)
    receiveOnly(messages)
    
    // Close channel
    jobs := make(chan int, 5)
    go func() {
        for i := 1; i <= 5; i++ {
            jobs <- i
        }
        close(jobs)  // Close when done
    }()
    
    // Range over channel
    for job := range jobs {
        fmt.Println("Job:", job)
    }
    
    // Select statement - wait on multiple channels
    ch1 := make(chan string)
    ch2 := make(chan string)
    
    go func() {
        time.Sleep(1 * time.Second)
        ch1 <- "from ch1"
    }()
    
    go func() {
        time.Sleep(2 * time.Second)
        ch2 <- "from ch2"
    }()
    
    for i := 0; i < 2; i++ {
        select {
        case msg1 := <-ch1:
            fmt.Println("Received:", msg1)
        case msg2 := <-ch2:
            fmt.Println("Received:", msg2)
        case <-time.After(3 * time.Second):
            fmt.Println("Timeout")
        }
    }
    
    // Non-blocking operations
    messages2 := make(chan string)
    signals := make(chan bool)
    
    select {
    case msg := <-messages2:
        fmt.Println("Received:", msg)
    default:
        fmt.Println("No message received")
    }
    
    msg := "hi"
    select {
    case messages2 <- msg:
        fmt.Println("Sent:", msg)
    default:
        fmt.Println("No receiver, message not sent")
    }
    
    // Multiple select cases
    select {
    case msg := <-messages2:
        fmt.Println("Received:", msg)
    case sig := <-signals:
        fmt.Println("Signal:", sig)
    default:
        fmt.Println("Nothing ready")
    }
}

func sendOnly(ch chan<- string) {
    ch <- "message"
}

func receiveOnly(ch <-chan string) {
    msg := <-ch
    fmt.Println("Received:", msg)
}
```

### Channel Patterns

```go
package main

import (
    "fmt"
    "time"
)

// Worker pool pattern
func worker(id int, jobs <-chan int, results chan<- int) {
    for job := range jobs {
        fmt.Printf("Worker %d processing job %d\n", id, job)
        time.Sleep(time.Second)
        results <- job * 2
    }
}

// Pipeline pattern
func generator(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        for _, n := range nums {
            out <- n
        }
        close(out)
    }()
    return out
}

func square(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            out <- n * n
        }
        close(out)
    }()
    return out
}

// Fan-out, fan-in pattern
func fanOut(in <-chan int, n int) []<-chan int {
    channels := make([]<-chan int, n)
    for i := 0; i < n; i++ {
        channels[i] = square(in)
    }
    return channels
}

func fanIn(channels ...<-chan int) <-chan int {
    out := make(chan int)
    for _, ch := range channels {
        go func(c <-chan int) {
            for n := range c {
                out <- n
            }
        }(ch)
    }
    return out
}

func main() {
    // Worker pool
    jobs := make(chan int, 100)
    results := make(chan int, 100)
    
    // Start 3 workers
    for w := 1; w <= 3; w++ {
        go worker(w, jobs, results)
    }
    
    // Send jobs
    for j := 1; j <= 5; j++ {
        jobs <- j
    }
    close(jobs)
    
    // Collect results
    for r := 1; r <= 5; r++ {
        fmt.Println("Result:", <-results)
    }
    
    // Pipeline
    input := generator(1, 2, 3, 4, 5)
    output := square(input)
    
    for result := range output {
        fmt.Println("Squared:", result)
    }
}
```

---

## Packages and Modules

### Understanding Go's Package System

**Theory:**
Packages are Go's way of organizing and reusing code.

**Package Hierarchy:**
```
Module (Repository level)
  └─ Packages (Directory level)
      └─ Go files (File level)
```

**Why Packages?**
1. **Organization**: Group related functionality
2. **Encapsulation**: Hide internal implementation
3. **Reusability**: Share code across projects
4. **Namespace**: Avoid naming conflicts

**Package Rules:**

1. **One package per directory**: All `.go` files in directory must have same package name
2. **Package name**: Usually matches directory name (convention)
3. **main package**: Special - creates executable
4. **Exported names**: Start with capital letter (public)
5. **Unexported names**: Start with lowercase (private to package)

**Visibility Example:**
```go
package mypackage

// Exported (visible outside package)
type User struct {
    Name string      // Exported field
    email string     // Unexported field
}

func NewUser() User { }  // Exported
func validate() bool { } // Unexported
```

**Import Paths:**
```go
import "fmt"                    // Standard library
import "github.com/user/repo"   // Remote package
import "myproject/internal/db"  // Local package
```

**Import Variants:**
```go
import "fmt"              // Normal
import f "fmt"           // Alias
import . "fmt"           // Dot import (discouraged)
import _ "mypackage"     // Side effects only (runs init)
```

### Go Modules

**Theory:**
Modules are collections of packages with versioned dependencies.

**Why Modules?**
Before modules (GOPATH era):
- All code in single workspace
- No versioning
- Dependency hell
- Reproducibility issues

With modules:
- Each project is self-contained
- Semantic versioning
- Reproducible builds
- Dependency isolation

**go.mod File:**
```go
module github.com/username/project  // Module path

go 1.21  // Go version

require (
    github.com/gin-gonic/gin v1.9.0  // Dependencies
    github.com/lib/pq v1.10.9
)

replace (
    // Replace dependency (for local dev)
    github.com/old/pkg => github.com/new/pkg v1.0.0
)

exclude github.com/bad/pkg v1.2.3  // Exclude version
```

**go.sum File:**
- Checksums of dependencies
- Ensures integrity
- Should be committed to version control
- Automatically managed

**Module Commands:**
```bash
go mod init [module-path]  # Initialize new module
go mod tidy                # Add missing, remove unused
go mod download            # Download dependencies
go mod verify              # Verify checksums
go mod vendor              # Copy deps to vendor/
go mod graph               # Print dependency graph
```

**Semantic Versioning:**
```
v1.2.3
│ │ └─ Patch (bug fixes)
│ └─── Minor (new features, backward compatible)
└───── Major (breaking changes)
```

**Version Selection:**
- Go uses minimum version selection (MVS)
- Chooses minimum version that satisfies all requirements
- Predictable and reproducible

**Internal Packages:**
```
myproject/
  └─ internal/        # Only importable by myproject
      └─ database/
      └─ utils/
```
- Enforce encapsulation
- Cannot be imported by external projects

### Package Structure

```go
// File: mymath/operations.go
package mymath

// Exported function (starts with capital letter)
func Add(a, b int) int {
    return a + b
}

// Unexported function (starts with lowercase)
func multiply(a, b int) int {
    return a * b
}

// Exported constant
const Pi = 3.14159

// Unexported constant
const epsilon = 0.0001
```

```go
// File: main.go
package main

import (
    "fmt"
    "myproject/mymath"  // Import custom package
)

func main() {
    result := mymath.Add(5, 3)
    fmt.Println("Sum:", result)
    fmt.Println("Pi:", mymath.Pi)
    
    // Cannot access: mymath.multiply() or mymath.epsilon
}
```

### Go Modules

Initialize a module:
```bash
go mod init github.com/username/projectname
```

Module file (go.mod):
```
module github.com/username/projectname

go 1.21

require (
    github.com/gorilla/mux v1.8.0
    github.com/lib/pq v1.10.9
)
```

Common commands:
```bash
go mod tidy        # Add missing and remove unused modules
go mod download    # Download modules to local cache
go mod vendor      # Copy dependencies to vendor/
go get github.com/package/name  # Add dependency
go get -u          # Update dependencies
```

### Init Function

**Theory:**
`init()` is a special function that runs automatically before `main()`.

**Execution Order:**
1. Package-level variable initialization (in order of declaration)
2. All `init()` functions (in order they appear)
3. Import dependencies first (depth-first)
4. Finally, `main()` runs

**Init Properties:**
- No parameters, no return value
- Can have multiple `init()` in same file/package
- Cannot be called explicitly
- Runs exactly once per package
- Order within package: by file name alphabetically

**Use Cases:**
- Initialize global variables
- Register drivers (database, image formats)
- Validate configuration
- Run setup code

**Example Execution:**
```
Import package A
  \u2192 A's variable init
  \u2192 A's init()
Import package B (depends on A)
  \u2192 B's variable init  
  \u2192 B's init()
Main package
  \u2192 main's variable init
  \u2192 main's init()
  \u2192 main()

```go
package main

import "fmt"

// init runs before main
func init() {
    fmt.Println("Init function 1")
}

func init() {
    fmt.Println("Init function 2")
}

func main() {
    fmt.Println("Main function")
}

// Output:
// Init function 1
// Init function 2
// Main function
```

---

## Additional Important Topics

### JSON Handling

```go
package main

import (
    "encoding/json"
    "fmt"
)

type User struct {
    ID       int    `json:"id"`
    Name     string `json:"name"`
    Email    string `json:"email"`
    Password string `json:"-"`  // Omit from JSON
    Age      int    `json:"age,omitempty"`  // Omit if zero
}

func main() {
    // Marshal (struct to JSON)
    user := User{
        ID:       1,
        Name:     "John Doe",
        Email:    "john@example.com",
        Password: "secret",
        Age:      30,
    }
    
    jsonData, err := json.Marshal(user)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Println("JSON:", string(jsonData))
    
    // Pretty print
    prettyJSON, _ := json.MarshalIndent(user, "", "  ")
    fmt.Println("Pretty JSON:\n", string(prettyJSON))
    
    // Unmarshal (JSON to struct)
    jsonStr := `{"id":2,"name":"Jane Smith","email":"jane@example.com"}`
    var user2 User
    err = json.Unmarshal([]byte(jsonStr), &user2)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Unmarshaled: %+v\n", user2)
    
    // Working with maps
    var result map[string]interface{}
    json.Unmarshal([]byte(jsonStr), &result)
    fmt.Println("Map:", result)
}
```

### File Operations

```go
package main

import (
    "bufio"
    "fmt"
    "io"
    "io/ioutil"
    "os"
)

func main() {
    // Write to file
    data := []byte("Hello, Go!\n")
    err := ioutil.WriteFile("test.txt", data, 0644)
    if err != nil {
        fmt.Println("Error writing:", err)
        return
    }
    
    // Read entire file
    content, err := ioutil.ReadFile("test.txt")
    if err != nil {
        fmt.Println("Error reading:", err)
        return
    }
    fmt.Println("Content:", string(content))
    
    // Open file
    file, err := os.Open("test.txt")
    if err != nil {
        fmt.Println("Error opening:", err)
        return
    }
    defer file.Close()
    
    // Read with buffered reader
    scanner := bufio.NewScanner(file)
    for scanner.Scan() {
        fmt.Println("Line:", scanner.Text())
    }
    
    // Create and write
    file2, err := os.Create("output.txt")
    if err != nil {
        fmt.Println("Error creating:", err)
        return
    }
    defer file2.Close()
    
    writer := bufio.NewWriter(file2)
    writer.WriteString("Line 1\n")
    writer.WriteString("Line 2\n")
    writer.Flush()
    
    // Copy file
    source, _ := os.Open("test.txt")
    defer source.Close()
    
    destination, _ := os.Create("copy.txt")
    defer destination.Close()
    
    io.Copy(destination, source)
}
```

### Testing

```go
// File: calculator.go
package calculator

func Add(a, b int) int {
    return a + b
}

func Subtract(a, b int) int {
    return a - b
}
```

```go
// File: calculator_test.go
package calculator

import "testing"

func TestAdd(t *testing.T) {
    result := Add(2, 3)
    expected := 5
    
    if result != expected {
        t.Errorf("Add(2, 3) = %d; want %d", result, expected)
    }
}

func TestSubtract(t *testing.T) {
    tests := []struct {
        name     string
        a, b     int
        expected int
    }{
        {"positive numbers", 5, 3, 2},
        {"negative result", 3, 5, -2},
        {"zero", 5, 5, 0},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := Subtract(tt.a, tt.b)
            if result != tt.expected {
                t.Errorf("got %d, want %d", result, tt.expected)
            }
        })
    }
}

// Benchmark
func BenchmarkAdd(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Add(2, 3)
    }
}
```

Run tests:
```bash
go test                  # Run tests
go test -v              # Verbose output
go test -cover          # Show coverage
go test -bench=.        # Run benchmarks
```

---

## Best Practices

1. **Error Handling**: Always check errors
2. **Use gofmt**: Format code consistently
3. **Use golint**: Check for style mistakes
4. **Keep it simple**: Favor clarity over cleverness
5. **Use defer**: For cleanup operations
6. **Avoid goroutine leaks**: Always ensure goroutines can exit
7. **Use context**: For cancellation and timeouts
8. **Document exports**: Add comments to exported functions/types
9. **Use interfaces**: For flexibility and testing
10. **Handle panics**: Use recover only when necessary

---

## Go Interview Questions & Answers

### Conceptual Questions

#### 1. What is Go and why was it created?

**Answer:**
Go (Golang) is a statically typed, compiled programming language created by Google in 2009 by Robert Griesemer, Rob Pike, and Ken Thompson.

**Why created:**
- Solve slow compilation times in large C++ codebases
- Simplify complex C++ features while maintaining performance
- Built-in concurrency support for modern multicore processors
- Better dependency management
- Fast compilation and execution

**Key features:**
- Garbage collection
- Goroutines for concurrency
- Channels for communication
- Simple syntax (25 keywords)
- Fast compilation
- Single binary deployment

---

#### 2. What are goroutines and how do they differ from threads?

**Answer:**

**Goroutines:**
- Lightweight (2 KB initial stack vs 1-2 MB for threads)
- Managed by Go runtime (not OS)
- Multiplexed onto OS threads (M:N scheduling)
- Very cheap to create (millions possible)
- Cooperative scheduling

**OS Threads:**
- Heavy (large stack size)
- Managed by OS kernel
- 1:1 mapping with kernel threads
- Expensive to create (thousands max)
- Preemptive scheduling

**Example:**
```go
// Creating a goroutine is simple
go myFunction()  // Just add 'go' keyword

// vs thread in other languages (more complex)
```

---

#### 3. Explain channels in Go. What's the difference between buffered and unbuffered channels?

**Answer:**

**Channels** are typed conduits for communication between goroutines.

**Unbuffered Channel:**
```go
ch := make(chan int)  // No buffer
```
- Send blocks until someone receives
- Receive blocks until someone sends
- Synchronous communication
- Guarantees handoff

**Buffered Channel:**
```go
ch := make(chan int, 5)  // Buffer size 5
```
- Send blocks only when buffer is full
- Receive blocks only when buffer is empty
- Asynchronous (up to buffer size)
- No guaranteed handoff

**Example:**
```go
// Unbuffered - blocks until received
ch := make(chan int)
go func() {
    ch <- 42  // Blocks here until main receives
}()
value := <-ch  // Now goroutine can continue

// Buffered - doesn't block if buffer has space
ch := make(chan int, 2)
ch <- 1  // Doesn't block
ch <- 2  // Doesn't block
ch <- 3  // Would block (buffer full)
```

---

#### 4. What is the difference between `make` and `new` in Go?

**Answer:**

**`new(T)`:**
- Allocates memory for type T
- Returns `*T` (pointer to T)
- Memory is zeroed
- Rarely used

```go
p := new(int)      // p is *int, *p = 0
s := new([]int)    // s is *[]int, *s = nil
```

**`make(T, args)`:**
- Creates slices, maps, and channels only
- Returns initialized T (not pointer)
- Required for these types

```go
s := make([]int, 5)          // []int with len=5, cap=5
m := make(map[string]int)    // Initialized map
ch := make(chan int, 10)     // Channel with buffer 10
```

**Key Difference:**
- `new` returns pointer to zeroed memory
- `make` returns initialized, ready-to-use value
- `make` is only for slices, maps, channels

---

#### 5. Explain interfaces in Go. What is an empty interface?

**Answer:**

**Interface** defines a contract of methods. Types implement interfaces implicitly.

```go
type Writer interface {
    Write([]byte) (int, error)
}

// Any type with Write method implements Writer
type File struct {}

func (f File) Write(data []byte) (int, error) {
    // Implementation
    return len(data), nil
}

// File implements Writer automatically
```

**Empty Interface:**
```go
interface{} // or 'any' in Go 1.18+
```
- Has no methods
- Every type implements it
- Can hold any value
- Similar to `Object` in Java or `void*` in C

**Use cases:**
```go
func PrintAnything(v interface{}) {
    fmt.Println(v)
}

PrintAnything(42)
PrintAnything("hello")
PrintAnything([]int{1, 2, 3})
```

**Type assertion to get value back:**
```go
var i interface{} = "hello"

s := i.(string)        // Type assertion
s, ok := i.(string)    // Safe type assertion
```

---

#### 6. What is the difference between value receiver and pointer receiver?

**Answer:**

**Value Receiver:**
```go
func (p Person) GetName() string {
    return p.Name
}
```
- Receives copy of struct
- Cannot modify original
- Use for small structs
- Use for read-only operations

**Pointer Receiver:**
```go
func (p *Person) SetName(name string) {
    p.Name = name  // Modifies original
}
```
- Receives pointer to struct
- Can modify original
- Use for large structs (avoid copying)
- Use when need to modify

**Example:**
```go
type Counter struct {
    count int
}

// Value receiver - doesn't modify original
func (c Counter) Increment() {
    c.count++  // Modifies copy only
}

// Pointer receiver - modifies original
func (c *Counter) IncrementPtr() {
    c.count++  // Modifies original
}

func main() {
    c := Counter{count: 0}
    c.Increment()    // c.count still 0
    c.IncrementPtr() // c.count now 1
}
```

**Rule of thumb:** Use pointer receivers unless you have a good reason not to.

---

#### 7. How does Go handle errors? Why doesn't Go have exceptions?

**Answer:**

**Go's Approach:**
- Explicit error values (not exceptions)
- Errors are returned as values
- Must check explicitly

```go
result, err := doSomething()
if err != nil {
    // Handle error
    return err
}
// Use result
```

**Why No Exceptions:**

**Problems with exceptions:**
1. Hidden control flow (can't see where errors occur)
2. Easy to forget try/catch
3. Performance overhead
4. Complex exception hierarchies

**Benefits of Go's approach:**
1. Explicit error handling (visible in code)
2. Simple (just if statements)
3. Fast (no stack unwinding)
4. Clear (error path is obvious)

**Panic/Recover for Programming Errors:**
```go
// Panic for unrecoverable errors
if user == nil {
    panic("user cannot be nil")
}

// Recover to catch panics
defer func() {
    if r := recover(); r != nil {
        fmt.Println("Recovered:", r)
    }
}()
```

---

#### 8. What is a slice and how does it differ from an array?

**Answer:**

**Array:**
```go
var arr [5]int  // Fixed size 5
```
- Fixed size (part of type)
- Value type (copying copies all elements)
- Size cannot change
- Rarely used directly

**Slice:**
```go
var slice []int  // Dynamic size
slice = append(slice, 1, 2, 3)
```
- Dynamic size
- Reference type (points to underlying array)
- Can grow and shrink
- Most commonly used

**Slice Internals:**
```go
type slice struct {
    ptr *element  // Pointer to array
    len int       // Number of elements
    cap int       // Capacity of array
}
```

**Example:**
```go
// Array
arr := [3]int{1, 2, 3}
arr2 := arr  // Copies all elements

// Slice
slice := []int{1, 2, 3}
slice2 := slice  // Copies pointer, shares data
slice2[0] = 99   // Affects both slices
```

---

#### 9. What is the `defer` statement and when would you use it?

**Answer:**

**Defer** schedules function call to execute after surrounding function returns.

**Execution:**
- Deferred calls pushed onto stack
- Execute in LIFO order
- Run even if panic occurs
- Arguments evaluated immediately

**Use Cases:**

**1. Resource Cleanup:**
```go
file, err := os.Open("file.txt")
if err != nil {
    return err
}
defer file.Close()  // Ensures file is closed

// Work with file
// File closed automatically when function returns
```

**2. Unlock Mutexes:**
```go
mu.Lock()
defer mu.Unlock()

// Critical section
// Unlock happens automatically
```

**3. Recover from Panic:**
```go
defer func() {
    if r := recover(); r != nil {
        log.Println("Recovered:", r)
    }
}()
```

**4. Logging:**
```go
func trace(name string) func() {
    fmt.Println("Entering:", name)
    return func() {
        fmt.Println("Exiting:", name)
    }
}

func myFunc() {
    defer trace("myFunc")()
    // Function body
}
```

**LIFO Order:**
```go
defer fmt.Println("1")
defer fmt.Println("2")
defer fmt.Println("3")
// Output: 3, 2, 1
```

---

#### 10. What is the difference between concurrency and parallelism?

**Answer:**

**Concurrency:**
- **Structure** of program
- Dealing with multiple things at once
- Multiple tasks making progress (not necessarily simultaneously)
- About composition

**Parallelism:**
- **Execution** of program
- Doing multiple things at once
- Multiple tasks running simultaneously
- Requires multiple CPUs/cores

**Example:**

**Concurrency (Single Core):**
```
Time →
Core: [Task A][Task B][Task A][Task B]
      Tasks interleaved (context switching)
```

**Parallelism (Multi Core):**
```
Time →
Core 1: [Task A][Task A][Task A]
Core 2: [Task B][Task B][Task B]
        Tasks truly simultaneous
```

**In Go:**
```go
// Concurrent (goroutines)
go task1()  // Structured for concurrency
go task2()  // May or may not run in parallel

// Runtime decides parallelism based on:
// - Number of CPU cores (GOMAXPROCS)
// - Available resources
// - Scheduling
```

**Quote from Rob Pike:**
> "Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once."

---

### Coding Questions

#### Question 1: Implement a function to reverse a string

**Problem:**
Write a function that reverses a string. Handle Unicode properly.

**Solution:**
```go
package main

import "fmt"

// Method 1: Using runes (handles Unicode)
func reverseString(s string) string {
    runes := []rune(s)
    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
        runes[i], runes[j] = runes[j], runes[i]
    }
    return string(runes)
}

// Method 2: Using string builder
func reverseStringBuilder(s string) string {
    runes := []rune(s)
    var result strings.Builder
    result.Grow(len(s))
    
    for i := len(runes) - 1; i >= 0; i-- {
        result.WriteRune(runes[i])
    }
    return result.String()
}

func main() {
    fmt.Println(reverseString("hello"))      // "olleh"
    fmt.Println(reverseString("世界"))        // "界世" (Unicode)
    fmt.Println(reverseString("Go! 🚀"))     // "🚀 !oG" (Emoji)
}
```

**Time Complexity:** O(n)
**Space Complexity:** O(n)

**Key Points:**
- Must convert to `[]rune` for Unicode (not `[]byte`)
- String is immutable in Go
- Runes handle multi-byte characters

---

#### Question 2: Find duplicate elements in a slice

**Problem:**
Given a slice of integers, return all duplicate elements.

**Solution:**
```go
package main

import "fmt"

// Method 1: Using map
func findDuplicates(nums []int) []int {
    seen := make(map[int]bool)
    duplicates := make(map[int]bool)
    result := []int{}
    
    for _, num := range nums {
        if seen[num] {
            duplicates[num] = true
        }
        seen[num] = true
    }
    
    for num := range duplicates {
        result = append(result, num)
    }
    
    return result
}

// Method 2: With count
func findDuplicatesWithCount(nums []int) map[int]int {
    count := make(map[int]int)
    
    for _, num := range nums {
        count[num]++
    }
    
    duplicates := make(map[int]int)
    for num, cnt := range count {
        if cnt > 1 {
            duplicates[num] = cnt
        }
    }
    
    return duplicates
}

func main() {
    nums := []int{1, 2, 3, 2, 4, 5, 1, 6, 1}
    fmt.Println(findDuplicates(nums))              // [1, 2]
    fmt.Println(findDuplicatesWithCount(nums))     // map[1:3 2:2]
}
```

**Time Complexity:** O(n)
**Space Complexity:** O(n)

---

#### Question 3: Implement a thread-safe counter

**Problem:**
Create a counter that can be safely used by multiple goroutines.

**Solution:**
```go
package main

import (
    "fmt"
    "sync"
)

// Method 1: Using Mutex
type Counter struct {
    mu    sync.Mutex
    value int
}

func (c *Counter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value++
}

func (c *Counter) Value() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.value
}

// Method 2: Using channels
type ChannelCounter struct {
    ops chan func(*int)
}

func NewChannelCounter() *ChannelCounter {
    c := &ChannelCounter{
        ops: make(chan func(*int)),
    }
    
    go func() {
        var value int
        for op := range c.ops {
            op(&value)
        }
    }()
    
    return c
}

func (c *ChannelCounter) Increment() {
    c.ops <- func(v *int) { *v++ }
}

func (c *ChannelCounter) Value() int {
    result := make(chan int)
    c.ops <- func(v *int) { result <- *v }
    return <-result
}

// Method 3: Using atomic
type AtomicCounter struct {
    value int64
}

func (c *AtomicCounter) Increment() {
    atomic.AddInt64(&c.value, 1)
}

func (c *AtomicCounter) Value() int64 {
    return atomic.LoadInt64(&c.value)
}

func main() {
    counter := &Counter{}
    var wg sync.WaitGroup
    
    // Start 100 goroutines
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for j := 0; j < 100; j++ {
                counter.Increment()
            }
        }()
    }
    
    wg.Wait()
    fmt.Println("Final count:", counter.Value())  // 10000
}
```

**Key Points:**
- Mutex for general synchronization
- Channels for message passing
- Atomic for simple counters (fastest)

---

#### Question 4: Implement worker pool pattern

**Problem:**
Create a worker pool that processes jobs concurrently.

**Solution:**
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type Job struct {
    ID   int
    Data string
}

type Result struct {
    Job    Job
    Result string
    Error  error
}

type WorkerPool struct {
    numWorkers int
    jobs       chan Job
    results    chan Result
    wg         sync.WaitGroup
}

func NewWorkerPool(numWorkers int) *WorkerPool {
    return &WorkerPool{
        numWorkers: numWorkers,
        jobs:       make(chan Job, 100),
        results:    make(chan Result, 100),
    }
}

func (wp *WorkerPool) Start() {
    for i := 0; i < wp.numWorkers; i++ {
        wp.wg.Add(1)
        go wp.worker(i)
    }
}

func (wp *WorkerPool) worker(id int) {
    defer wp.wg.Done()
    
    for job := range wp.jobs {
        fmt.Printf("Worker %d processing job %d\n", id, job.ID)
        
        // Simulate work
        time.Sleep(100 * time.Millisecond)
        
        result := Result{
            Job:    job,
            Result: fmt.Sprintf("Processed: %s", job.Data),
        }
        
        wp.results <- result
    }
}

func (wp *WorkerPool) Submit(job Job) {
    wp.jobs <- job
}

func (wp *WorkerPool) Close() {
    close(wp.jobs)
    wp.wg.Wait()
    close(wp.results)
}

func (wp *WorkerPool) Results() <-chan Result {
    return wp.results
}

func main() {
    pool := NewWorkerPool(3)
    pool.Start()
    
    // Submit jobs
    go func() {
        for i := 1; i <= 10; i++ {
            pool.Submit(Job{
                ID:   i,
                Data: fmt.Sprintf("Task %d", i),
            })
        }
        pool.Close()
    }()
    
    // Collect results
    for result := range pool.Results() {
        fmt.Printf("Result: %s\n", result.Result)
    }
}
```

**Output:**
```
Worker 1 processing job 1
Worker 2 processing job 2
Worker 3 processing job 3
Result: Processed: Task 1
Worker 1 processing job 4
...
```

---

#### Question 5: Implement LRU Cache

**Problem:**
Implement a Least Recently Used (LRU) cache with O(1) operations.

**Solution:**
```go
package main

import (
    "container/list"
    "fmt"
)

type LRUCache struct {
    capacity int
    cache    map[int]*list.Element
    list     *list.List
}

type entry struct {
    key   int
    value int
}

func NewLRUCache(capacity int) *LRUCache {
    return &LRUCache{
        capacity: capacity,
        cache:    make(map[int]*list.Element),
        list:     list.New(),
    }
}

func (c *LRUCache) Get(key int) int {
    if elem, ok := c.cache[key]; ok {
        c.list.MoveToFront(elem)
        return elem.Value.(*entry).value
    }
    return -1
}

func (c *LRUCache) Put(key, value int) {
    if elem, ok := c.cache[key]; ok {
        c.list.MoveToFront(elem)
        elem.Value.(*entry).value = value
        return
    }
    
    if c.list.Len() >= c.capacity {
        back := c.list.Back()
        if back != nil {
            c.list.Remove(back)
            delete(c.cache, back.Value.(*entry).key)
        }
    }
    
    elem := c.list.PushFront(&entry{key, value})
    c.cache[key] = elem
}

func main() {
    cache := NewLRUCache(2)
    
    cache.Put(1, 1)
    cache.Put(2, 2)
    fmt.Println(cache.Get(1))  // 1
    
    cache.Put(3, 3)            // Evicts key 2
    fmt.Println(cache.Get(2))  // -1 (not found)
    
    cache.Put(4, 4)            // Evicts key 1
    fmt.Println(cache.Get(1))  // -1 (not found)
    fmt.Println(cache.Get(3))  // 3
    fmt.Println(cache.Get(4))  // 4
}
```

**Time Complexity:** O(1) for Get and Put
**Space Complexity:** O(capacity)

---

#### Question 6: Merge two sorted slices

**Problem:**
Given two sorted slices, merge them into one sorted slice.

**Solution:**
```go
package main

import "fmt"

func mergeSorted(nums1, nums2 []int) []int {
    result := make([]int, 0, len(nums1)+len(nums2))
    i, j := 0, 0
    
    for i < len(nums1) && j < len(nums2) {
        if nums1[i] <= nums2[j] {
            result = append(result, nums1[i])
            i++
        } else {
            result = append(result, nums2[j])
            j++
        }
    }
    
    // Append remaining elements
    result = append(result, nums1[i:]...)
    result = append(result, nums2[j:]...)
    
    return result
}

func main() {
    nums1 := []int{1, 3, 5, 7}
    nums2 := []int{2, 4, 6, 8}
    
    fmt.Println(mergeSorted(nums1, nums2))
    // Output: [1 2 3 4 5 6 7 8]
}
```

**Time Complexity:** O(n + m)
**Space Complexity:** O(n + m)

---

#### Question 7: Rate limiter implementation

**Problem:**
Implement a simple rate limiter that allows N requests per time window.

**Solution:**
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type RateLimiter struct {
    tokens     int
    maxTokens  int
    refillRate time.Duration
    mu         sync.Mutex
    lastRefill time.Time
}

func NewRateLimiter(maxTokens int, refillRate time.Duration) *RateLimiter {
    return &RateLimiter{
        tokens:     maxTokens,
        maxTokens:  maxTokens,
        refillRate: refillRate,
        lastRefill: time.Now(),
    }
}

func (rl *RateLimiter) Allow() bool {
    rl.mu.Lock()
    defer rl.mu.Unlock()
    
    // Refill tokens
    now := time.Now()
    elapsed := now.Sub(rl.lastRefill)
    tokensToAdd := int(elapsed / rl.refillRate)
    
    if tokensToAdd > 0 {
        rl.tokens = min(rl.maxTokens, rl.tokens+tokensToAdd)
        rl.lastRefill = now
    }
    
    // Check if request allowed
    if rl.tokens > 0 {
        rl.tokens--
        return true
    }
    
    return false
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

// Alternative: Token bucket with goroutine
type TokenBucket struct {
    tokens    chan struct{}
    maxTokens int
}

func NewTokenBucket(maxTokens int, refillRate time.Duration) *TokenBucket {
    tb := &TokenBucket{
        tokens:    make(chan struct{}, maxTokens),
        maxTokens: maxTokens,
    }
    
    // Fill initially
    for i := 0; i < maxTokens; i++ {
        tb.tokens <- struct{}{}
    }
    
    // Refill periodically
    go func() {
        ticker := time.NewTicker(refillRate)
        defer ticker.Stop()
        
        for range ticker.C {
            select {
            case tb.tokens <- struct{}{}:
            default:
                // Bucket full
            }
        }
    }()
    
    return tb
}

func (tb *TokenBucket) Allow() bool {
    select {
    case <-tb.tokens:
        return true
    default:
        return false
    }
}

func main() {
    limiter := NewRateLimiter(5, 1*time.Second)
    
    for i := 0; i < 10; i++ {
        if limiter.Allow() {
            fmt.Printf("Request %d: Allowed\n", i+1)
        } else {
            fmt.Printf("Request %d: Rate limited\n", i+1)
        }
        time.Sleep(500 * time.Millisecond)
    }
}
```

---

#### Question 8: Find the first non-repeating character

**Problem:**
Find the first character in a string that doesn't repeat.

**Solution:**
```go
package main

import "fmt"

func firstNonRepeating(s string) rune {
    count := make(map[rune]int)
    
    // Count occurrences
    for _, char := range s {
        count[char]++
    }
    
    // Find first non-repeating
    for _, char := range s {
        if count[char] == 1 {
            return char
        }
    }
    
    return 0 // Not found
}

// Alternative: Preserve order with slice
func firstNonRepeatingOrdered(s string) rune {
    type charCount struct {
        char  rune
        count int
    }
    
    seen := make(map[rune]int)
    order := []rune{}
    
    for _, char := range s {
        if seen[char] == 0 {
            order = append(order, char)
        }
        seen[char]++
    }
    
    for _, char := range order {
        if seen[char] == 1 {
            return char
        }
    }
    
    return 0
}

func main() {
    fmt.Printf("%c\n", firstNonRepeating("leetcode"))      // 'l'
    fmt.Printf("%c\n", firstNonRepeating("loveleetcode"))  // 'v'
    fmt.Printf("%c\n", firstNonRepeating("aabb"))          // 0 (none)
}
```

**Time Complexity:** O(n)
**Space Complexity:** O(k) where k is unique characters

---

#### Question 9: Implement a concurrent download manager

**Problem:**
Download multiple files concurrently with error handling.

**Solution:**
```go
package main

import (
    "fmt"
    "io"
    "net/http"
    "os"
    "sync"
)

type DownloadResult struct {
    URL      string
    Filename string
    Error    error
}

func downloadFile(url, filename string) error {
    resp, err := http.Get(url)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return fmt.Errorf("bad status: %s", resp.Status)
    }
    
    file, err := os.Create(filename)
    if err != nil {
        return err
    }
    defer file.Close()
    
    _, err = io.Copy(file, resp.Body)
    return err
}

func downloadConcurrent(urls map[string]string, maxConcurrent int) []DownloadResult {
    results := make([]DownloadResult, 0, len(urls))
    resultsChan := make(chan DownloadResult, len(urls))
    
    // Create semaphore to limit concurrency
    sem := make(chan struct{}, maxConcurrent)
    var wg sync.WaitGroup
    
    for url, filename := range urls {
        wg.Add(1)
        go func(u, f string) {
            defer wg.Done()
            
            // Acquire semaphore
            sem <- struct{}{}
            defer func() { <-sem }()
            
            err := downloadFile(u, f)
            resultsChan <- DownloadResult{
                URL:      u,
                Filename: f,
                Error:    err,
            }
        }(url, filename)
    }
    
    // Close results channel when done
    go func() {
        wg.Wait()
        close(resultsChan)
    }()
    
    // Collect results
    for result := range resultsChan {
        results = append(results, result)
    }
    
    return results
}

func main() {
    urls := map[string]string{
        "https://example.com/file1.txt": "file1.txt",
        "https://example.com/file2.txt": "file2.txt",
        "https://example.com/file3.txt": "file3.txt",
    }
    
    results := downloadConcurrent(urls, 2) // Max 2 concurrent downloads
    
    for _, result := range results {
        if result.Error != nil {
            fmt.Printf("Failed to download %s: %v\n", result.URL, result.Error)
        } else {
            fmt.Printf("Successfully downloaded %s to %s\n", result.URL, result.Filename)
        }
    }
}
```

---

#### Question 10: Binary search implementation

**Problem:**
Implement binary search on a sorted slice.

**Solution:**
```go
package main

import "fmt"

// Iterative approach
func binarySearch(nums []int, target int) int {
    left, right := 0, len(nums)-1
    
    for left <= right {
        mid := left + (right-left)/2
        
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    
    return -1 // Not found
}

// Recursive approach
func binarySearchRecursive(nums []int, target int) int {
    return binarySearchHelper(nums, target, 0, len(nums)-1)
}

func binarySearchHelper(nums []int, target, left, right int) int {
    if left > right {
        return -1
    }
    
    mid := left + (right-left)/2
    
    if nums[mid] == target {
        return mid
    } else if nums[mid] < target {
        return binarySearchHelper(nums, target, mid+1, right)
    } else {
        return binarySearchHelper(nums, target, left, mid-1)
    }
}

// Find first occurrence
func findFirst(nums []int, target int) int {
    left, right := 0, len(nums)-1
    result := -1
    
    for left <= right {
        mid := left + (right-left)/2
        
        if nums[mid] == target {
            result = mid
            right = mid - 1 // Continue searching left
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    
    return result
}

func main() {
    nums := []int{1, 3, 5, 7, 9, 11, 13, 15}
    
    fmt.Println(binarySearch(nums, 7))            // 3
    fmt.Println(binarySearch(nums, 4))            // -1
    fmt.Println(binarySearchRecursive(nums, 11))  // 5
    
    nums2 := []int{1, 2, 2, 2, 3, 4, 5}
    fmt.Println(findFirst(nums2, 2))              // 1 (first occurrence)
}
```

**Time Complexity:** O(log n)
**Space Complexity:** O(1) iterative, O(log n) recursive

---

### Advanced Coding Questions

#### Question 11: Implement context with timeout

**Problem:**
Demonstrate proper context usage with timeout and cancellation.

**Solution:**
```go
package main

import (
    "context"
    "fmt"
    "time"
)

func doWork(ctx context.Context, id int) error {
    for i := 0; i < 5; i++ {
        select {
        case <-ctx.Done():
            return ctx.Err()
        default:
            fmt.Printf("Worker %d: Working... (%d/5)\n", id, i+1)
            time.Sleep(500 * time.Millisecond)
        }
    }
    return nil
}

func main() {
    // Example 1: Context with timeout
    ctx1, cancel1 := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel1()
    
    err := doWork(ctx1, 1)
    if err != nil {
        fmt.Printf("Worker 1 stopped: %v\n", err)
    }
    
    // Example 2: Context with cancellation
    ctx2, cancel2 := context.WithCancel(context.Background())
    
    go func() {
        time.Sleep(1 * time.Second)
        fmt.Println("Cancelling worker 2...")
        cancel2()
    }()
    
    err = doWork(ctx2, 2)
    if err != nil {
        fmt.Printf("Worker 2 stopped: %v\n", err)
    }
    
    // Example 3: Context with deadline
    deadline := time.Now().Add(1500 * time.Millisecond)
    ctx3, cancel3 := context.WithDeadline(context.Background(), deadline)
    defer cancel3()
    
    err = doWork(ctx3, 3)
    if err != nil {
        fmt.Printf("Worker 3 stopped: %v\n", err)
    }
}
```

---

#### Question 12: Implement a simple pub/sub system

**Problem:**
Create a publish-subscribe system with multiple subscribers.

**Solution:**
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type PubSub struct {
    mu          sync.RWMutex
    subscribers map[string][]chan interface{}
}

func NewPubSub() *PubSub {
    return &PubSub{
        subscribers: make(map[string][]chan interface{}),
    }
}

func (ps *PubSub) Subscribe(topic string) <-chan interface{} {
    ps.mu.Lock()
    defer ps.mu.Unlock()
    
    ch := make(chan interface{}, 10)
    ps.subscribers[topic] = append(ps.subscribers[topic], ch)
    return ch
}

func (ps *PubSub) Publish(topic string, message interface{}) {
    ps.mu.RLock()
    defer ps.mu.RUnlock()
    
    for _, ch := range ps.subscribers[topic] {
        go func(c chan interface{}) {
            c <- message
        }(ch)
    }
}

func (ps *PubSub) Close(topic string) {
    ps.mu.Lock()
    defer ps.mu.Unlock()
    
    for _, ch := range ps.subscribers[topic] {
        close(ch)
    }
    delete(ps.subscribers, topic)
}

func main() {
    pubsub := NewPubSub()
    
    // Subscriber 1
    sub1 := pubsub.Subscribe("news")
    go func() {
        for msg := range sub1 {
            fmt.Printf("Subscriber 1 received: %v\n", msg)
        }
    }()
    
    // Subscriber 2
    sub2 := pubsub.Subscribe("news")
    go func() {
        for msg := range sub2 {
            fmt.Printf("Subscriber 2 received: %v\n", msg)
        }
    }()
    
    // Publish messages
    time.Sleep(100 * time.Millisecond)
    pubsub.Publish("news", "Breaking news!")
    pubsub.Publish("news", "Weather update")
    
    time.Sleep(1 * time.Second)
    pubsub.Close("news")
}
```

---

This covers the fundamentals of Go with comprehensive interview questions and coding challenges. Practice these concepts and explore the standard library for more advanced features!
