# JUnit Testing - Complete Notes and Theory

## Table of Contents
1. [Fundamentals of Testing](#fundamentals-of-testing)
2. [Introduction to JUnit](#introduction-to-junit)
3. [JUnit History and Versions](#junit-history-and-versions)
4. [Core Concepts](#core-concepts)
5. [Test Execution Flow & Lifecycle](#test-execution-flow--lifecycle)
6. [JUnit 4 vs JUnit 5](#junit-4-vs-junit-5)
7. [Annotations](#annotations)
8. [Assertions](#assertions)
9. [Test Fixtures](#test-fixtures)
10. [Parameterized Tests](#parameterized-tests)
11. [Test Suites](#test-suites)
12. [Mocking with Mockito](#mocking-with-mockito)
13. [Exception Testing](#exception-testing)
14. [Test Isolation & Independence](#test-isolation--independence)
15. [Best Practices](#best-practices)
16. [Real-World Examples](#real-world-examples)
17. [Advanced Testing Patterns](#advanced-testing-patterns)
18. [Common Pitfalls and Solutions](#common-pitfalls-and-solutions)

---

## Fundamentals of Testing

### What is Testing?
Testing is a systematic process of evaluating a software application to detect differences between given input and expected output. It ensures the software meets specified requirements and functions correctly.

### Types of Testing
1. **Unit Testing**: Testing individual components (methods, classes) in isolation
2. **Integration Testing**: Testing how multiple components work together
3. **End-to-End Testing**: Testing complete workflows
4. **System Testing**: Testing entire system functionality
5. **Regression Testing**: Ensuring changes don't break existing functionality
6. **Performance Testing**: Testing speed and resource utilization
7. **Acceptance Testing**: Testing against business requirements

### Why Unit Testing Matters
- **Early Bug Detection**: Catch bugs before they reach production
- **Code Quality**: Forces better design and architecture
- **Documentation**: Tests act as living documentation
- **Confidence**: Enables safe refactoring
- **Cost Reduction**: Cheaper to fix bugs early
- **Maintainability**: Makes code easier to modify and extend

### The Testing Pyramid
```
      /\
     /  \     E2E Tests (10%)
    /    \
   /------\
  /        \   Integration Tests (30%)
 /          \
/------------\
     Unit Tests (60%)
```

**Key Principle**: More unit tests, fewer integration tests, minimal E2E tests

### Testing Best Principles
1. **Independence**: Tests should not depend on each other
2. **Repeatability**: Tests should produce same results every time
3. **Self-Checking**: Tests should report pass/fail automatically
4. **Timeliness**: Tests should be written close to production code
5. **Clarity**: Test code should be clear and understandable

### Test-Driven Development (TDD) Cycle
```
1. RED: Write failing test
   ↓
2. GREEN: Write minimal code to pass test
   ↓
3. REFACTOR: Improve code while maintaining passing tests
   ↓
Back to step 1
```

---

## Introduction to JUnit

### What is JUnit?
JUnit is an open-source unit testing framework for Java. It provides a simple and elegant way to write automated tests and run them repeatedly. JUnit is the de facto standard for unit testing in the Java ecosystem and has influenced testing frameworks in other languages.

### Historical Context
- Created by **Kent Beck** and **Erich Gamma** in 2004
- Based on **SUnit** (Smalltalk) and **xUnit** (generic testing framework pattern)
- Part of the larger xUnit family (NUnit for .NET, pytest for Python, etc.)
- Widely adopted in enterprise Java development

### Key Features
- **Simple API**: Easy-to-use annotations and assertions for readable tests
- **Test Automation**: Integrates with Maven, Gradle, Jenkins for CI/CD pipelines
- **IDE Integration**: Built-in support in Eclipse, IntelliJ, NetBeans
- **Extensible**: Custom rules, extensions, and listeners
- **Performance**: Fast execution and minimal overhead
- **Standards-Based**: Follows xUnit patterns widely understood by developers

### Why JUnit is Critical
1. **Bug Detection**: Catch defects early before reaching production
   - Studies show unit tests catch 40-80% of bugs
   - Much cheaper to fix bugs early
   
2. **Regression Prevention**: Automated checks prevent accidental breakage
   - Safe refactoring of legacy code
   - Confident API changes
   
3. **Documentation**: Tests serve as executable examples
   - Show how to use code
   - Demonstrate expected behavior
   - More current than comments
   
4. **Design Improvement**: Writing testable code leads to better design
   - Forces loose coupling
   - Promotes single responsibility
   - Enables better separation of concerns
   
5. **Refactoring Safety**: Comprehensive tests enable continuous improvement
   - Change implementation without behavior change
   - Try new approaches without fear
   
6. **Team Communication**: Tests facilitate knowledge sharing
   - New developers understand code behavior
   - Documentation of edge cases
   - Specification of requirements

### Unit Testing vs Other Test Types

| Type | Scope | Speed | Cost | Frequency |
|------|-------|-------|------|-----------|
| Unit | Single method/class | Very Fast | Low | Every commit |
| Integration | Multiple components | Medium | Medium | Daily |
| E2E | Full system | Slow | High | Weekly |
| Performance | Load testing | Slow | High | Monthly |

### Key Points
✓ JUnit is the standard Java testing framework  
✓ Follows xUnit pattern used across all languages  
✓ Enables Test-Driven Development (TDD)  
✓ Integrates with all major build tools and IDEs  
✓ Supports both JUnit 4 (annotations) and JUnit 5 (modular)

---

## JUnit History and Versions

### Timeline:
- **JUnit 3 (2003)**: Extended TestCase - XML-based test suites
- **JUnit 4 (2006)**: Introduced annotations (@Test, @Before, @After)
- **JUnit 5 (2017)**: Complete rewrite, modular architecture (Jupiter, Vintage, Platform)

### Major Evolution:
```
JUnit 3: Extends TestCase
class CalculatorTest extends TestCase {
    public void testAdd() { }
}

JUnit 4: Annotations
@Test
public void testAdd() { }

JUnit 5: Modern, Extensible
@Test
void testAdd() { }
```

---

## Test Execution Flow & Lifecycle

### Understanding Test Execution
When you run a JUnit test, the framework follows a specific lifecycle. Understanding this is crucial for writing reliable tests.

### JUnit 4 Lifecycle (Per Test)
```
1. Class is loaded
   ↓
2. @BeforeClass (static) - runs ONCE before all tests
   ↓
   ↓ FOR EACH TEST:
   ├─ 3. Test instance created (constructor)
   ├─ 4. @Before - setup before test
   ├─ 5. @Test - execute test
   ├─ 6. @After - cleanup after test
   ↓
7. @AfterClass (static) - runs ONCE after all tests
```

### Detailed Lifecycle Example
```java
public class LifecycleTest {
    
    @BeforeClass
    public static void beforeClass() {
        System.out.println("1. BEFORE CLASS - Once at start");
    }
    
    @Before
    public void before() {
        System.out.println("  2. BEFORE - Before each test");
    }
    
    @Test
    public void test1() {
        System.out.println("    3. TEST1");
    }
    
    @Test
    public void test2() {
        System.out.println("    3. TEST2");
    }
    
    @After
    public void after() {
        System.out.println("  4. AFTER - After each test");
    }
    
    @AfterClass
    public static void afterClass() {
        System.out.println("5. AFTER CLASS - Once at end");
    }
}
```

**Output:**
```
1. BEFORE CLASS - Once at start
  2. BEFORE - Before each test
    3. TEST1
  4. AFTER - After each test
  2. BEFORE - Before each test
    3. TEST2
  4. AFTER - After each test
5. AFTER CLASS - Once at end
```

### Test Instance Creation
**Important**: JUnit creates a **new instance** of the test class for each test method!

```java
public class InstanceTest {
    private int counter = 0;
    
    @Before
    public void setUp() {
        counter = 0;  // Counter reset for each test
    }
    
    @Test
    public void test1() {
        counter++;
        assertEquals(1, counter);  // PASSES
    }
    
    @Test
    public void test2() {
        // counter is 0 again (new instance)
        assertEquals(0, counter);  // PASSES
    }
}
```

### Why New Instance Per Test?
- **Test Isolation**: Each test gets clean state
- **No Side Effects**: Changes in one test don't affect others
- **Independence**: Tests can run in any order
- **Parallel Execution**: Enables thread-safe parallel test runs

### Lifecycle Theory
1. **Setup (Before)**: Prepare test environment
   - Create objects
   - Initialize resources
   - Configure mocks
   
2. **Execution (Test)**: Run actual test code
   - Execute code under test
   - No setup or cleanup
   
3. **Verification (Assert)**: Verify results
   - Check output
   - Verify side effects
   - Confirm expectations
   
4. **Cleanup (After)**: Clean up resources
   - Close connections
   - Release memory
   - Reset state

### Key Points
✓ JUnit creates new test instance for each test  
✓ @Before/@BeforeClass setup occurs before each test  
✓ @After/@AfterClass cleanup occurs after each test  
✓ Static setup/teardown runs once, instance runs for each test  
✓ Test isolation prevents inter-test dependencies  
✓ Lifecycle ensures predictable, repeatable test execution

---

## Core Concepts

### 1. Test Class
A Java class that contains test methods. Follows naming convention: `*Test.java` or `*TestCase.java`

**Characteristics:**
- Public class (usually)
- Can have constructors, setup methods, test methods
- New instance created per test method
- Can be abstract (for sharing common test logic)

```java
public class CalculatorTest {
    // Test methods and fixtures go here
}
```

**Why public?** Makes it discoverable by test runners

### 2. Test Method
A method annotated with `@Test` that tests a specific behavior. Should test one logical unit of behavior.

**Characteristics:**
- Public method (usually)
- No parameters (unless using parameterized tests)
- No return value (void)
- Throws no checked exceptions (or caught)
- Independent of other test methods

```java
@Test
public void testAdd() {
    // One logical unit of behavior
}
```

**Naming Convention:**
- `test[What]`: testAddition(), testNegativeNumber()
- `[Should][Behavior][When][Condition]`: shouldReturnSumWhenAddingNumbers()
- `given[Precondition]_when[Action]_then[Result]`: givenTwoNumbers_whenAdded_thenReturnSum()

### 3. AAA Pattern (Arrange-Act-Assert)

The most important testing pattern. Divides test into three phases:

```java
@Test
public void testAdd() {
    // PHASE 1: ARRANGE - Set up test data and preconditions
    Calculator calc = new Calculator();
    int a = 2;
    int b = 3;
    int expected = 5;
    
    // PHASE 2: ACT - Execute the code being tested
    int result = calc.add(a, b);
    
    // PHASE 3: ASSERT - Verify the result matches expectation
    assertEquals(expected, result);
}
```

**Theory Behind AAA:**
- **Clarity**: Obvious what's setup vs execution vs verification
- **Maintainability**: Easy to modify test data
- **Reusability**: Setup can be extracted to fixtures
- **Documentation**: Shows how to use code

**Advanced AAA Pattern:**
```java
@Test
public void testComplexBehavior() {
    // ARRANGE
    Database db = new Database();
    User user = new User("john@example.com");
    db.insertUser(user);
    
    // ACT
    User retrieved = db.findUser("john@example.com");
    
    // ASSERT
    assertNotNull(retrieved);
    assertEquals("john@example.com", retrieved.getEmail());
    
    // CLEANUP (sometimes added)
    db.deleteUser(user);
}
```

### 4. Test Categories

#### Unit Tests
- Test smallest testable unit (usually one method)
- No external dependencies (mock them)
- Fast execution (< 100ms)
- Test implementation details

```java
@Test
void testCalculateDiscount() {
    PricingService service = new PricingService();
    double discount = service.calculateDiscount(100.0, 0.10);
    assertEquals(10.0, discount);
}
```

#### Integration Tests
- Test multiple components working together
- May use real dependencies (database, file system)
- Slower than unit tests (100ms - 1s)
- Test component boundaries

```java
@Test
void testUserCreationWithDatabase() {
    UserService service = new UserService(new JdbcUserRepository());
    User user = service.createUser("john@example.com");
    assertNotNull(user.getId());
}
```

#### End-to-End Tests
- Test complete workflows
- Use real system dependencies
- Very slow (> 1s)
- Test user scenarios

```java
@Test
void testCompleteOrderFlow() {
    // Login -> Browse -> Add to cart -> Checkout -> Confirm
}
```

### 5. Test Quality Metrics

#### Code Coverage
Measures percentage of code executed by tests.

```java
// Line Coverage: 66% (2 of 3 lines)
public int divide(int a, int b) {
    if (b == 0) throw new ArithmeticException();  // Covered
    return a / b;  // Covered
}                 // Not covered: what about negative?
```

**Coverage Types:**
- **Line Coverage**: % of lines executed
- **Branch Coverage**: % of decision branches taken
- **Path Coverage**: % of code paths executed
- **Method Coverage**: % of methods called

**Coverage Goals:**
- Non-critical code: 60-70%
- Standard code: 75-85%
- Critical code: 90-100%

#### Test Reliability
- **Consistency**: Same result every run
- **Stability**: No random failures (flakiness)
- **Determinism**: No timing or order dependencies

### 6. Isolation and Dependencies

**Theory of Test Isolation:**
Each test should be independent and not affect others.

```java
// GOOD: Isolated tests
@Test
void testAddition() {
    assertEquals(5, calculator.add(2, 3));
}

@Test
void testSubtraction() {
    assertEquals(1, calculator.subtract(3, 2));
}

// BAD: Dependent tests
private static int result;

@Test
void testStep1() {
    result = calculator.add(2, 3);
}

@Test
void testStep2() {
    // Depends on testStep1 running first!
    assertEquals(8, calculator.add(result, 3));
}
```

### 7. Test Execution Context

Understanding what affects test execution:

```java
public class ExecutionContextTest {
    private Random random = new Random();
    
    // BAD: Depends on external system time
    @Test
    void testTimeSensitive() {
        LocalDateTime now = LocalDateTime.now();
        assertTrue(now.isBefore(LocalDateTime.now()));  // Flaky!
    }
    
    // GOOD: Deterministic
    @Test
    void testWithFixedTime() {
        LocalDateTime fixed = LocalDateTime.of(2023, 1, 1, 12, 0);
        assertTrue(fixed.isAfter(LocalDateTime.of(2023, 1, 1, 11, 0)));
    }
    
    // BAD: Random data
    @Test
    void testWithRandom() {
        int value = random.nextInt();
        assertTrue(value > 0);  // Flaky!
    }
    
    // GOOD: Predictable data
    @Test
    void testWithFixedData() {
        assertTrue(42 > 0);  // Always passes
    }
}
```

### Key Points
✓ Test class holds related test methods  
✓ Each test method should test one behavior  
✓ AAA pattern provides clear test structure  
✓ Unit tests are fast and isolated  
✓ Tests should be independent and repeatable  
✓ Coverage measures code quality but isn't everything  
✓ Isolation prevents test interdependencies

---

## JUnit 4 vs JUnit 5

### Comparison Table

| Feature | JUnit 4 | JUnit 5 |
|---------|---------|---------|
| Annotations | @Test, @Before, @After | @Test, @BeforeEach, @AfterEach |
| Architecture | Monolithic | Modular (Platform, Jupiter, Vintage) |
| Extension | Rules (@Rule) | Extensions (@ExtendWith) |
| Parameterized Tests | @RunWith, @Parameterized | @ParameterizedTest |
| Meta-annotations | Limited | Full support |
| Lambda Support | Limited | Full support |
| Conditional Tests | Not native | @EnabledIf, @DisabledIf |
| Test Naming | Method name | @DisplayName |

### Key Differences in Syntax

```java
// JUnit 4
@Before
public void setUp() { }

@After
public void tearDown() { }

// JUnit 5
@BeforeEach
void setUp() { }

@AfterEach
void tearDown() { }
```

---

## Annotations

### JUnit 4 Annotations

#### 1. @Test
Marks a method as a test method.
```java
@Test
public void testCalculation() {
    assertEquals(4, 2 + 2);
}
```

#### 2. @Before
Runs before each test method.
```java
@Before
public void setUp() {
    calculator = new Calculator();
}
```

#### 3. @After
Runs after each test method.
```java
@After
public void tearDown() {
    calculator = null;
}
```

#### 4. @BeforeClass
Runs once before all tests in the class (must be static).
```java
@BeforeClass
public static void setUpClass() {
    System.out.println("Test class starting");
}
```

#### 5. @AfterClass
Runs once after all tests (must be static).
```java
@AfterClass
public static void tearDownClass() {
    System.out.println("Test class finished");
}
```

#### 6. @Test(timeout = milliseconds)
Test fails if it takes longer than specified time.
```java
@Test(timeout = 1000)
public void testPerformance() {
    // Code should complete within 1000ms
}
```

#### 7. @Test(expected = Exception.class)
Test passes if specified exception is thrown.
```java
@Test(expected = ArithmeticException.class)
public void testDivisionByZero() {
    calculator.divide(5, 0);
}
```

#### 8. @Ignore
Skips the test.
```java
@Ignore("Not implemented yet")
@Test
public void testFeatureX() { }
```

### JUnit 5 Annotations

#### 1. @Test
Same as JUnit 4.
```java
@Test
void testCalculation() {
    assertEquals(4, 2 + 2);
}
```

#### 2. @BeforeEach
Replaces @Before
```java
@BeforeEach
void setUp() {
    calculator = new Calculator();
}
```

#### 3. @AfterEach
Replaces @After
```java
@AfterEach
void tearDown() {
    calculator = null;
}
```

#### 4. @BeforeAll
Replaces @BeforeClass (must be static)
```java
@BeforeAll
static void setUpClass() { }
```

#### 5. @AfterAll
Replaces @AfterClass (must be static)
```java
@AfterAll
static void tearDownClass() { }
```

#### 6. @DisplayName
Provides a custom test name.
```java
@Test
@DisplayName("Addition of two positive numbers")
void testAddition() { }
```

#### 7. @Disabled
Disables a test.
```java
@Test
@Disabled("Feature not ready")
void testNewFeature() { }
```

#### 8. @EnabledIf / @DisabledIf
Conditional test execution.
```java
@Test
@EnabledIf("systemProperty.os.name matches '.*Windows.*'")
void testOnWindows() { }
```

#### 9. @ParameterizedTest
Marks method as parameterized test.
```java
@ParameterizedTest
@ValueSource(ints = {1, 2, 3})
void testWithNumbers(int number) { }
```

#### 10. @ExtendWith
Registers extensions for tests.
```java
@ExtendWith(MockitoExtension.class)
class MyTest { }
```

---

## Assertions

### Common Assertions

#### 1. assertEquals
```java
assertEquals(expected, actual);
assertEquals(5, 2 + 3);
assertEquals("Hello", "Hello");
```

#### 2. assertNotEquals
```java
assertNotEquals(unexpected, actual);
assertNotEquals(5, 2 + 2);
```

#### 3. assertTrue / assertFalse
```java
assertTrue(condition);
assertFalse(condition);

assertTrue(5 > 3);
assertFalse(5 < 3);
```

#### 4. assertNull / assertNotNull
```java
assertNull(object);
assertNotNull(object);

String str = null;
assertNull(str);
```

#### 5. assertSame / assertNotSame
```java
assertSame(obj1, obj2);        // Reference equality
assertNotSame(obj1, obj2);

String a = new String("test");
String b = a;
assertSame(a, b);              // Same object reference
```

#### 6. assertArrayEquals
```java
assertArrayEquals(expectedArray, actualArray);

int[] expected = {1, 2, 3};
int[] actual = {1, 2, 3};
assertArrayEquals(expected, actual);
```

#### 7. assertThat (Hamcrest)
```java
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;

assertThat(actual, is(expected));
assertThat(list, hasItems(1, 2, 3));
assertThat(string, containsString("test"));
```

#### 8. fail
```java
fail("Test should not reach this point");
fail("Expected exception was not thrown");
```

#### 9. Custom Assertion Messages
```java
assertEquals("Numbers should be equal", expected, actual);

// JUnit 5 with lambda
assertEquals(5, 2 + 3, 
    () -> "Custom message: calculation failed");
```

### Assertion Methods Summary
```java
// Equality
assertEquals(expected, actual)
assertNotEquals(unexpected, actual)

// Boolean
assertTrue(condition)
assertFalse(condition)

// Null checks
assertNull(object)
assertNotNull(object)

// Reference equality
assertSame(obj1, obj2)
assertNotSame(obj1, obj2)

// Arrays
assertArrayEquals(expected, actual)

// Exceptions (JUnit 4)
@Test(expected = Exception.class)

// Exceptions (JUnit 5)
assertThrows(Exception.class, () -> code)

// Custom
fail(message)
```

---

## Test Fixtures

### Test Fixture Definition
A test fixture is a fixed state of software objects used as a baseline for running tests.

### Example: Complete Test Fixture

```java
public class BankAccountTest {
    
    private BankAccount account;
    
    @Before
    public void setUp() {
        // FIXTURE SETUP - runs before each test
        account = new BankAccount("John", 1000.0);
    }
    
    @After
    public void tearDown() {
        // FIXTURE TEARDOWN - cleanup after each test
        account = null;
    }
    
    @Test
    public void testDeposit() {
        // Test uses fixture created in setUp()
        account.deposit(500.0);
        assertEquals(1500.0, account.getBalance());
    }
    
    @Test
    public void testWithdraw() {
        account.withdraw(200.0);
        assertEquals(800.0, account.getBalance());
    }
}
```

### Using @BeforeClass and @AfterClass

```java
public class ExpensiveSetupTest {
    
    private static DatabaseConnection dbConnection;
    
    @BeforeClass
    public static void setUpClass() {
        // Expensive setup - runs once
        dbConnection = new DatabaseConnection("prod_db");
        dbConnection.connect();
    }
    
    @AfterClass
    public static void tearDownClass() {
        // Cleanup - runs once
        dbConnection.close();
    }
    
    @Before
    public void setUp() {
        // Per-test setup
        dbConnection.clearTables();
    }
    
    @Test
    public void testQuery1() {
        // Uses shared dbConnection
    }
    
    @Test
    public void testQuery2() {
        // Uses shared dbConnection
    }
}
```

### Lifecycle Order
```
1. setUpClass() - once
   2. setUp() - once
      3. test1()
   4. tearDown()
   5. setUp() - again
      6. test2()
   7. tearDown()
   ...
8. tearDownClass() - once
```

---

## Parameterized Tests

### JUnit 4 Parameterized Tests

```java
@RunWith(Parameterized.class)
public class CalculatorParameterizedTest {
    
    private int inputA;
    private int inputB;
    private int expected;
    
    // Constructor for parameters
    public CalculatorParameterizedTest(int inputA, int inputB, int expected) {
        this.inputA = inputA;
        this.inputB = inputB;
        this.expected = expected;
    }
    
    // Provide test data
    @Parameterized.Parameters
    public static Collection<Object[]> data() {
        return Arrays.asList(new Object[][]{
            {2, 3, 5},
            {0, 5, 5},
            {-1, 1, 0},
            {10, 20, 30}
        });
    }
    
    @Test
    public void testAdd() {
        Calculator calc = new Calculator();
        assertEquals(expected, calc.add(inputA, inputB));
    }
}
```

### JUnit 5 Parameterized Tests

#### 1. @ValueSource
```java
@ParameterizedTest
@ValueSource(ints = {1, 2, 3, 4})
void testWithNumbers(int number) {
    assertTrue(number > 0);
}
```

#### 2. @CsvSource
```java
@ParameterizedTest
@CsvSource({
    "2, 3, 5",
    "0, 5, 5",
    "-1, 1, 0"
})
void testAdd(int a, int b, int expected) {
    assertEquals(expected, new Calculator().add(a, b));
}
```

#### 3. @CsvFileSource
```java
@ParameterizedTest
@CsvFileSource(resources = "/test-data.csv")
void testFromFile(int a, int b, int expected) {
    assertEquals(expected, new Calculator().add(a, b));
}
```

#### 4. @MethodSource
```java
@ParameterizedTest
@MethodSource("provideAdditionData")
void testAdd(int a, int b, int expected) {
    assertEquals(expected, new Calculator().add(a, b));
}

static Stream<Arguments> provideAdditionData() {
    return Stream.of(
        Arguments.of(2, 3, 5),
        Arguments.of(0, 5, 5),
        Arguments.of(-1, 1, 0)
    );
}
```

#### 5. @ArgumentsSource
```java
class AdditionArgumentProvider implements ArgumentsProvider {
    @Override
    public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
        return Stream.of(
            Arguments.of(2, 3, 5),
            Arguments.of(0, 5, 5)
        );
    }
}

@ParameterizedTest
@ArgumentsSource(AdditionArgumentProvider.class)
void testAdd(int a, int b, int expected) {
    assertEquals(expected, new Calculator().add(a, b));
}
```

---

## Test Suites

### Test Suite Definition
A test suite is a collection of tests grouped together for execution.

### JUnit 4 Test Suites

```java
@RunWith(Suite.class)
@Suite.SuiteClasses({
    CalculatorTest.class,
    StringUtilTest.class,
    DateUtilTest.class
})
public class AllTests {
    // Empty class
}
```

### Hierarchical Test Suites

```java
@RunWith(Suite.class)
@Suite.SuiteClasses({CalculatorTest.class})
public class UnitTests {
}

@RunWith(Suite.class)
@Suite.SuiteClasses({DatabaseTest.class, APITest.class})
public class IntegrationTests {
}

@RunWith(Suite.class)
@Suite.SuiteClasses({UnitTests.class, IntegrationTests.class})
public class AllTests {
}
```

### JUnit 5 Test Suites

```java
@Suite
@SelectClasses({CalculatorTest.class, StringUtilTest.class})
public class AllTests {
}
```

### Advanced JUnit 5 Test Suite

```java
@Suite
@SelectClasses(CalculatorTest.class)
@IncludeTags("fast")
@ExcludePackages("com.example.slow")
public class FastTests {
}
```

---

## Mocking with Mockito

### What is Mocking?
Creating fake objects that simulate real objects in controlled ways for testing.

### Why Mockito?
- Isolate unit under test
- Simulate external dependencies
- Verify method calls
- Control behavior of dependencies

### Basic Setup

#### Maven Dependency
```xml
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>5.2.0</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-junit-jupiter</artifactId>
    <version>5.2.0</version>
    <scope>test</scope>
</dependency>
```

#### Gradle Dependency
```gradle
testImplementation 'org.mockito:mockito-core:5.2.0'
testImplementation 'org.mockito:mockito-junit-jupiter:5.2.0'
```

### Creating Mocks

#### 1. Using @Mock Annotation
```java
@ExtendWith(MockitoExtension.class)
public class UserServiceTest {
    
    @Mock
    UserRepository userRepository;
    
    @InjectMocks
    UserService userService;
    
    @Test
    void testFindUser() {
        // Mock is ready to use
    }
}
```

#### 2. Using mock() Method
```java
UserRepository mockRepository = mock(UserRepository.class);
UserService service = new UserService(mockRepository);
```

### Stubbing (Configuring Mock Behavior)

#### 1. when().thenReturn()
```java
@Test
void testGetUser() {
    User user = new User(1, "John");
    when(userRepository.findById(1)).thenReturn(user);
    
    User result = userService.getUser(1);
    assertEquals("John", result.getName());
}
```

#### 2. when().thenThrow()
```java
@Test
void testUserNotFound() {
    when(userRepository.findById(999))
        .thenThrow(new UserNotFoundException("Not found"));
    
    assertThrows(UserNotFoundException.class, 
        () -> userService.getUser(999));
}
```

#### 3. when().thenAnswer()
```java
@Test
void testWithCustomAnswer() {
    when(userRepository.save(any(User.class)))
        .thenAnswer(invocation -> {
            User user = invocation.getArgument(0);
            user.setId(100);
            return user;
        });
    
    User saved = userRepository.save(new User("John"));
    assertEquals(100, saved.getId());
}
```

#### 4. Argument Matchers
```java
// Match any string
when(userRepository.findByName(anyString())).thenReturn(user);

// Match specific type
when(userRepository.save(any(User.class))).thenReturn(user);

// Match any integer
when(calculator.add(anyInt(), anyInt())).thenReturn(10);

// Custom matchers
when(userRepository.findById(eq(1))).thenReturn(user);
when(userRepository.search(contains("John"))).thenReturn(users);
```

### Verification (Checking Mock Calls)

#### 1. verify() - Verify Method Was Called
```java
@Test
void testSaveUser() {
    User user = new User("John");
    userService.createUser(user);
    
    verify(userRepository).save(user);
}
```

#### 2. verify() with Times
```java
verify(userRepository, times(1)).save(user);
verify(userRepository, times(2)).findAll();
verify(userRepository, never()).delete(user);
verify(userRepository, atLeast(1)).save(any());
verify(userRepository, atMost(5)).findAll();
```

#### 3. Argument Capture
```java
@Test
void testCaptureArguments() {
    ArgumentCaptor<User> captor = ArgumentCaptor.forClass(User.class);
    
    userService.createUser(new User("John"));
    
    verify(userRepository).save(captor.capture());
    User savedUser = captor.getValue();
    
    assertEquals("John", savedUser.getName());
}
```

#### 4. Verify Interaction Order
```java
InOrder inOrder = inOrder(userRepository, emailService);

userService.updateUser(user);

inOrder.verify(userRepository).save(user);
inOrder.verify(emailService).sendNotification(user);
```

### Mocking Example: Complete Test Class

```java
@ExtendWith(MockitoExtension.class)
public class UserServiceTest {
    
    @Mock
    private UserRepository userRepository;
    
    @Mock
    private EmailService emailService;
    
    @InjectMocks
    private UserService userService;
    
    private User testUser;
    
    @BeforeEach
    void setUp() {
        testUser = new User(1, "john@example.com");
    }
    
    @Test
    void testCreateUser() {
        // Arrange
        when(userRepository.save(any(User.class))).thenReturn(testUser);
        
        // Act
        User result = userService.createUser(testUser);
        
        // Assert
        assertNotNull(result);
        assertEquals("john@example.com", result.getEmail());
        verify(userRepository).save(testUser);
        verify(emailService).sendWelcomeEmail(testUser.getEmail());
    }
    
    @Test
    void testGetUserNotFound() {
        // Arrange
        when(userRepository.findById(999))
            .thenThrow(new UserNotFoundException("User not found"));
        
        // Act & Assert
        assertThrows(UserNotFoundException.class, 
            () -> userService.getUser(999));
    }
    
    @Test
    void testUpdateUser() {
        // Arrange
        when(userRepository.save(any(User.class))).thenReturn(testUser);
        
        // Act
        testUser.setEmail("newemail@example.com");
        User result = userService.updateUser(testUser);
        
        // Assert
        ArgumentCaptor<User> captor = ArgumentCaptor.forClass(User.class);
        verify(userRepository).save(captor.capture());
        assertEquals("newemail@example.com", captor.getValue().getEmail());
    }
}
```

---

## Exception Testing

### Theory of Exception Testing
Exception testing verifies that code throws appropriate exceptions under error conditions. This is a critical part of comprehensive testing.

### JUnit 4 Exception Testing

#### 1. Using @Test(expected = ...)
```java
@Test(expected = ArithmeticException.class)
public void testDivisionByZeroThrowsException() {
    calculator.divide(10, 0);
}
```

**Limitations:**
- Only checks that exception is thrown
- Doesn't verify exception message
- Doesn't verify exception cause
- Doesn't verify exception properties

```java
// BAD: Cannot verify exception message
@Test(expected = UserNotFoundException.class)
public void testFindNonExistentUser() {
    userRepository.findById(999);  // Only verifies exception type
}
```

#### 2. Using try-catch
```java
@Test
public void testDivisionByZeroWithTryCatch() {
    try {
        calculator.divide(10, 0);
        fail("Expected ArithmeticException");
    } catch (ArithmeticException e) {
        assertEquals("/ by zero", e.getMessage());
    }
}
```

### JUnit 5 Exception Testing

#### 1. Using assertThrows()
**The modern, preferred approach**

```java
@Test
void testDivisionByZeroThrowsException() {
    // Verify exception is thrown
    assertThrows(ArithmeticException.class, 
        () -> calculator.divide(10, 0));
}
```

#### 2. Verify Exception Properties
```java
@Test
void testExceptionMessage() {
    // Capture and verify exception details
    UserNotFoundException exception = assertThrows(
        UserNotFoundException.class,
        () -> userRepository.findById(999)
    );
    
    assertEquals("User not found with id: 999", exception.getMessage());
}
```

#### 3. Verify Exception Cause
```java
@Test
void testExceptionCause() {
    DataAccessException exception = assertThrows(
        DataAccessException.class,
        () -> database.query("invalid sql")
    );
    
    assertNotNull(exception.getCause());
    assertTrue(exception.getCause() instanceof SQLException);
}
```

#### 4. Multiple Assertions on Exception
```java
@Test
void testCompleteExceptionValidation() {
    ValidationException exception = assertThrows(
        ValidationException.class,
        () -> validator.validate(null)
    );
    
    // Verify multiple aspects
    assertEquals("Validation failed", exception.getMessage());
    assertEquals(400, exception.getStatusCode());
    assertNotNull(exception.getTimestamp());
}
```

### Advanced Exception Testing Patterns

#### Testing Specific Exception Conditions
```java
public class OrderService {
    public Order createOrder(Order order) {
        if (order.getTotal() < 0) {
            throw new InvalidOrderException("Total cannot be negative");
        }
        // ...
    }
}

@ExtendWith(MockitoExtension.class)
public class OrderServiceExceptionTest {
    
    @Test
    void testNegativeOrderThrowsException() {
        Order negativeOrder = new Order(-100.0);
        
        InvalidOrderException exception = assertThrows(
            InvalidOrderException.class,
            () -> orderService.createOrder(negativeOrder)
        );
        
        assertEquals("Total cannot be negative", exception.getMessage());
    }
    
    @Test
    void testNullOrderThrowsException() {
        assertThrows(NullPointerException.class, 
            () -> orderService.createOrder(null));
    }
}
```

#### Testing Exception Hierarchy
```java
public class ErrorHandlingTest {
    
    // General exception class (superclass)
    @Test
    void testThrowsRuntimeException() {
        assertThrows(RuntimeException.class, 
            () -> {
                throw new SpecificRuntimeException("Error");
            });
    }
    
    // Specific exception class (subclass)
    @Test
    void testThrowsSpecificException() {
        assertThrows(SpecificRuntimeException.class, 
            () -> {
                throw new SpecificRuntimeException("Error");
            });
    }
}
```

#### Lambda vs Traditional Syntax
```java
// Modern: Lambda (preferred in JUnit 5)
@Test
void testModernException() {
    assertThrows(IOException.class, () -> {
        fileReader.read("nonexistent.txt");
    });
}

// Traditional: Explicit exception reference
@Test
public void testTraditionalException() {
    try {
        fileReader.read("nonexistent.txt");
        fail("Should throw IOException");
    } catch (IOException e) {
        assertNotNull(e);
    }
}
```

### Custom Exception Testing
```java
public class CustomExceptionTest {
    
    @Test
    void testCustomExceptionWithCustomCode() {
        ApiException exception = assertThrows(
            ApiException.class,
            () -> api.call(null)
        );
        
        assertEquals(400, exception.getErrorCode());
        assertEquals("BAD_REQUEST", exception.getErrorType());
        assertTrue(exception.isRetryable());
    }
}
```

### Key Points
✓ Exception testing verifies error handling paths  
✓ JUnit 5's assertThrows() is preferred over @Test(expected=...)  
✓ Verify exception type, message, cause, and properties  
✓ Test both happy path and error paths  
✓ Use lambda syntax in JUnit 5 for cleaner code  
✓ Test specific exception conditions, not just exception presence

---

## Test Isolation & Independence

### Theory of Test Independence
Each test must be completely independent. Violations create fragile, hard-to-debug tests.

### Independence Violations

#### 1. Shared Mutable State
```java
// BAD: Tests share state
public class BadTestIsolation {
    private static List<String> sharedList = new ArrayList<>();
    
    @Test
    void test1() {
        sharedList.add("item1");
        assertEquals(1, sharedList.size());
    }
    
    @Test
    void test2() {
        // Fails if test1 ran first!
        assertEquals(0, sharedList.size());
    }
}

// GOOD: Each test has own data
public class GoodTestIsolation {
    private List<String> localList;
    
    @Before
    public void setUp() {
        localList = new ArrayList<>();  // Fresh instance per test
    }
    
    @Test
    void test1() {
        localList.add("item1");
        assertEquals(1, localList.size());
    }
    
    @Test
    void test2() {
        // Always has empty list
        assertEquals(0, localList.size());
    }
}
```

#### 2. Execution Order Dependencies
```java
// BAD: Tests depend on execution order
public class OrderDependentTests {
    private static String data = "";
    
    @Test
    void testA_SetupData() {
        data = "initialized";
    }
    
    @Test
    void testB_UseData() {
        // Depends on testA running first!
        assertEquals("initialized", data);
    }
}

// GOOD: Each test is self-contained
public class IndependentTests {
    private String data;
    
    @Before
    public void setUp() {
        data = "initialized";  // Always available
    }
    
    @Test
    void testA() {
        assertEquals("initialized", data);
    }
    
    @Test
    void testB() {
        assertEquals("initialized", data);  // No dependency
    }
}
```

#### 3. Side Effects on External Systems
```java
// BAD: Tests modify shared resources
@Test
void testModifiesDatabase() {
    database.insert(new User("test"));
    // Other tests now see this user!
}

// GOOD: Cleanup after test
@Test
void testWithCleanup() {
    User user = new User("test");
    database.insert(user);
    
    assertTrue(database.exists(user));
    
    // Cleanup
    database.delete(user);
}

// BETTER: Use mocks
@Test
void testWithMock() {
    when(mockDatabase.insert(any(User.class)))
        .thenReturn(true);
    
    service.createUser(new User("test"));
    
    verify(mockDatabase).insert(any(User.class));
}
```

#### 4. Parallel Execution Issues
```java
// BAD: Not thread-safe
public class NotThreadSafeTest {
    private static int counter = 0;  // Shared mutable state
    
    @Test
    void testIncrement() {
        counter++;
        assertEquals(1, counter);  // Fails in parallel execution
    }
}

// GOOD: Thread-safe
public class ThreadSafeTest {
    private int localCounter = 0;  // Instance variable
    
    @Test
    void testIncrement() {
        localCounter++;
        assertEquals(1, localCounter);  // Always passes
    }
}
```

### Best Practices for Independence

#### 1. Fixture Reset Per Test
```java
public class ProperFixtureReset {
    private Database db;
    private UserRepository userRepo;
    
    @Before
    public void setUp() {
        // Fresh instances per test
        db = new Database();
        userRepo = new UserRepository(db);
    }
    
    @After
    public void tearDown() {
        // Cleanup
        db.close();
    }
}
```

#### 2. Using @BeforeEach and @AfterEach (JUnit 5)
```java
@ExtendWith(MockitoExtension.class)
public class ProperCleanup {
    private List<String> testData;
    
    @BeforeEach
    void setUp() {
        testData = new ArrayList<>();
    }
    
    @AfterEach
    void tearDown() {
        testData.clear();
    }
    
    @Test
    void test1() {
        testData.add("A");
        assertEquals(1, testData.size());
    }
    
    @Test
    void test2() {
        // testData is fresh and empty
        assertEquals(0, testData.size());
    }
}
```

#### 3. Isolating External Dependencies
```java
@ExtendWith(MockitoExtension.class)
public class IsolatedDependencies {
    
    @Mock
    private EmailService emailService;
    
    @Mock
    private UserRepository userRepo;
    
    @InjectMocks
    private UserService userService;
    
    @Test
    void testCreateUserIsolated() {
        // Mocks isolate external dependencies
        when(userRepo.save(any())).thenReturn(new User(1, "John"));
        
        User result = userService.createUser(new User("John"));
        
        assertNotNull(result.getId());
        // Email service not called in isolation
    }
}
```

### Testing in Parallel
```java
// pom.xml for Maven parallel execution
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-plugin</artifactId>
    <version>2.22.2</version>
    <configuration>
        <parallel>methods</parallel>
        <threadCount>4</threadCount>
    </configuration>
</plugin>

// All tests must be independent for parallel execution to work
```

### Key Points
✓ Each test must be completely independent  
✓ Use @Before/@BeforeEach to reset state per test  
✓ Mock external dependencies  
✓ Avoid shared mutable static state  
✓ No execution order dependencies  
✓ Clean up resources in @After/@AfterEach  
✓ Tests must be safe for parallel execution

---

## Best Practices

### 1. Test Naming Convention

**Theory:** Test names are documentation. They should clearly express what is being tested.

**Naming Patterns:**

#### Pattern 1: Method-Based
```java
test[UnitOfWork]_[StateUnderTest]_[ExpectedBehavior]()

@Test
void testAdd_WithPositiveNumbers_ReturnsCorrectSum() { }

@Test
void testAdd_WithNegativeNumbers_ReturnsCorrectSum() { }
```

#### Pattern 2: Behavior-Driven
```java
given[Precondition]_when[Action]_then[Result]()

@Test
void givenTwoNumbers_whenAdded_thenReturnSum() { }

@Test
void givenEmptyList_whenChecking_thenReturnTrue() { }
```

#### Pattern 3: Specification-Based
```java
[Should][Behavior][When][Condition]()

@Test
void shouldReturnSumWhenAddingNumbers() { }

@Test
void shouldThrowExceptionWhenDividingByZero() { }
```

**Bad Examples:**
```java
// Too vague
@Test
void test1() { }

// Unclear
@Test
void testCalculator() { }

// Misleading
@Test
void testSuccessfully() { }
```

**Theory Behind Good Names:**
- Tests serve as documentation
- Name explains the test in natural language
- Makes failures immediately clear
- Reduces need to read test code
- Enables better error messages

### 2. One Assertion Per Test (When Possible)

**Theory:** Single assertion tests are easier to debug and understand.

```java
// GOOD: Each test has single logical assertion
@Test
void testAddition() {
    assertEquals(5, calculator.add(2, 3));
}

@Test
void testSubtraction() {
    assertEquals(1, calculator.subtract(3, 2));
}

@Test
void testMultiplication() {
    assertEquals(6, calculator.multiply(2, 3));
}

// ACCEPTABLE: Multiple related assertions for single behavior
@Test
void testUserCreation() {
    User user = new User("John", 25);
    
    // All verify single behavior: valid user creation
    assertTrue(user.isValid());
    assertEquals("John", user.getName());
    assertEquals(25, user.getAge());
}

// BAD: Multiple unrelated assertions
@Test
void testMultipleBehaviors() {
    User user = new User("John", 25);
    assertEquals("John", user.getName());     // Separate concern
    
    calculator.add(2, 3);
    assertEquals(5, calculator.getResult()); // Different unit
    
    // First failure stops test, other assertions never run
}
```

**Why Single Assertion?**
- Clearer failure cause
- Better for debugging
- More precise coverage reporting
- Easier to understand purpose
- Enables data-driven testing

**Exception:** Related assertions testing one behavior are acceptable.

### 3. Test Independence

**Theory:** Tests must have no hidden dependencies on other tests.

```java
// BAD: Shared mutable state
private static List<String> sharedData;

@Test
void testAddToList() {
    sharedData.add("item");
    assertEquals(1, sharedData.size());
}

@Test
void testListIsEmpty() {
    assertEquals(0, sharedData.size());  // Fails if testAddToList ran first!
}

// GOOD: Independent tests
private List<String> localData;

@Before
void setUp() {
    localData = new ArrayList<>();  // Fresh per test
}

@Test
void testAddToList() {
    localData.add("item");
    assertEquals(1, localData.size());
}

@Test
void testListIsEmpty() {
    assertEquals(0, localData.size());  // Always fresh
}
```

### 4. Clear Arrange-Act-Assert Structure

**Theory:** The AAA pattern makes tests predictable and maintainable.

```java
@Test
void testComplexBehavior() {
    // ARRANGE: Set up the scenario
    Customer customer = new Customer("John", 1000.0);
    Item item = new Item("Book", 25.0);
    ShoppingCart cart = new ShoppingCart();
    
    // ACT: Perform the action
    cart.add(item);
    customer.checkout(cart);
    
    // ASSERT: Verify the result
    assertTrue(customer.hasItem(item));
    assertEquals(975.0, customer.getBalance());
}
```

**Benefits:**
- Clear separation of concerns
- Easy to identify test phases
- Simple to extract to fixtures
- Supports parameterization
- Enables test data generation

### 5. Use Meaningful Assertion Messages

**Theory:** Clear messages help quickly identify failures.

```java
// BAD: No message (cryptic failure)
assertEquals(5, calculator.add(2, 3));
// Failure: expected 5 but was 6

// GOOD: Descriptive message
assertEquals(5, calculator.add(2, 3), 
    "Adding 2 and 3 should equal 5");
// Failure: Adding 2 and 3 should equal 5 -- expected 5 but was 6

// BETTER: Lambda message (lazy evaluation, no overhead if passes)
assertEquals(5, result,
    () -> String.format("Adding %d and %d should equal %d but got %d", 
        2, 3, 5, result));

// ADVANCED: Hamcrest matchers
assertThat(result, 
    is(5))); 
    // Better: use descriptive matcher name
assertThat(result, 
    equalTo(5));
```

### 6. Test Edge Cases

**Theory:** Edge cases catch bugs that normal cases miss.

```java
public int divide(int a, int b) {
    if (b == 0) throw new ArithmeticException();
    return a / b;
}

@Test
void testEdgeCases() {
    // Boundary: zero divisor
    assertThrows(ArithmeticException.class, 
        () -> divide(10, 0));
    
    // Boundary: zero dividend
    assertEquals(0, divide(0, 5));
    
    // Boundary: negative numbers
    assertEquals(-2, divide(-10, 5));
    
    // Boundary: same numbers
    assertEquals(1, divide(5, 5));
    
    // Boundary: large numbers
    assertEquals(1, divide(Integer.MAX_VALUE, Integer.MAX_VALUE));
}
```

**Common Edge Cases:**
- Null values
- Empty collections
- Negative numbers
- Zero
- Maximum/minimum values
- Empty strings
- Duplicate values

### 7. Mock External Dependencies

**Theory:** Isolating dependencies makes unit tests truly unit tests.

```java
// BAD: Testing implementation + external system
@Test
void testSendEmail() {
    UserService service = new UserService(new RealEmailService("smtp.gmail.com"));
    
    // Slow, flaky (depends on Gmail), not unit test
    service.notifyUser("test@example.com");
}

// GOOD: Isolated unit test with mock
@Mock
EmailService mockEmailService;

@InjectMocks
UserService userService;

@Test
void testSendEmail() {
    when(mockEmailService.send(any())).thenReturn(true);
    
    userService.notifyUser("test@example.com");
    
    verify(mockEmailService).send("test@example.com");
}
```

### 8. Test Both Success and Failure Cases

**Theory:** Comprehensive testing includes positive and negative paths.

```java
@Test
void testHappyPath() {
    when(userRepository.findById(1)).thenReturn(user);
    
    User result = userService.getUser(1);
    
    assertNotNull(result);
    assertEquals("John", result.getName());
}

@Test
void testUserNotFound() {
    when(userRepository.findById(999))
        .thenThrow(new UserNotFoundException());
    
    assertThrows(UserNotFoundException.class,
        () -> userService.getUser(999));
}

@Test
void testInvalidInput() {
    assertThrows(IllegalArgumentException.class,
        () -> userService.getUser(null));
}
```

### 9. Use Descriptive Variable Names

**Theory:** Clear variable names make tests self-documenting.

```java
// GOOD: Names explain the purpose
@Test
void testDiscount() {
    double originalPrice = 100.0;
    double discountPercentage = 0.20;
    double expectedDiscountedPrice = 80.0;
    
    double actualPrice = priceService.applyDiscount(
        originalPrice, 
        discountPercentage
    );
    
    assertEquals(expectedDiscountedPrice, actualPrice);
}

// BAD: Cryptic variable names
@Test
void testDiscount() {
    double a = 100.0;
    double b = 0.20;
    double c = 80.0;
    
    double d = priceService.applyDiscount(a, b);
    
    assertEquals(c, d);
}
```

### 10. Avoid Test Interdependencies

**Theory:** Running tests in any order should work.

```java
// BAD: Shared state creates order dependency
private static String sharedState;

@Test
void testA() {
    sharedState = "A";
}

@Test
void testB() {
    assertEquals("A", sharedState);  // Fails if testA doesn't run first
}

// GOOD: Each test is independent
private String localState;

@Before
void setUp() {
    localState = null;
}

@Test
void testA() {
    localState = "A";
    assertEquals("A", localState);
}

@Test
void testB() {
    // Fresh state regardless of test execution order
    assertNull(localState);
}
```

### 11. Keep Tests Fast and Isolated

**Theory:** Fast tests get run more often; isolation prevents environmental issues.

```java
// BAD: Slow integration test in unit test
@Test
void testSlowIntegration() {
    Database realDb = new Database("prod_connection");
    realDb.connect();  // 5 seconds
    realDb.insert(user);
    Thread.sleep(2000);  // Wait for replication
    
    User result = realDb.findById(1);
    
    realDb.close();  // 2 seconds
}

// GOOD: Fast unit test with mocks
@Mock
Database mockDb;

@Test
void testFastUnit() {
    when(mockDb.findById(1)).thenReturn(user);
    
    User result = userService.getUser(1);
    
    assertNotNull(result);  // < 1ms
}
```

**Why Fast Tests Matter:**
- Developers run them more frequently
- Faster feedback on changes
- Enables TDD workflow
- Supports continuous integration

### 12. Document Complex Test Logic

**Theory:** Complex tests need explanation.

```java
@Test
void testComplexCalculation() {
    // Test case: User with 5 orders, each with 10% volume discount,
    // plus 20% loyalty discount, minus $5 promotional credit
    // Expected: 10 * 90 * 80 - 5 = 715
    
    when(mockRepository.getOrders(user)).thenReturn(
        IntStream.range(0, 5)
            .mapToObj(i -> new Order(10.0))
            .collect(Collectors.toList())
    );
    
    double total = pricingService.calculate(user);
    
    assertEquals(715.0, total, 0.01);
}
```

### Key Points for Best Practices
✓ Use descriptive, self-documenting test names  
✓ One logical assertion per test when possible  
✓ Ensure tests are independent and can run in any order  
✓ Follow AAA pattern (Arrange-Act-Assert)  
✓ Provide meaningful failure messages  
✓ Test edge cases and error conditions  
✓ Mock external dependencies  
✓ Test both happy path and error paths  
✓ Use clear, descriptive variable names  
✓ Keep tests fast and isolated  
✓ Document complex test logic  
✓ Run tests frequently during development

### 6. Test Edge Cases
```java
@Test
void testAddWithEdgeCases() {
    // Test with zeros
    assertEquals(3, calculator.add(0, 3));
    
    // Test with negative numbers
    assertEquals(-1, calculator.add(-5, 4));
    
    // Test with large numbers
    assertEquals(2000000000, calculator.add(1000000000, 1000000000));
}
```

### 7. Mock External Dependencies
```java
// Good: Mock external services
@Mock
private ApiClient apiClient;

@Test
void testUserCreationWithExternalApi() {
    when(apiClient.notifyUser(any())).thenReturn(true);
    // Test logic without making real API calls
}

// Bad: Real dependency in test
@Test
void testUserCreationWithRealApi() {
    ApiClient realClient = new ApiClient("http://real-api.com");
    // Slow, flaky, depends on external system
}
```

### 8. Test Both Success and Failure Cases
```java
@Test
void testSuccessScenario() {
    // Happy path
    when(repository.save(user)).thenReturn(user);
    User result = service.saveUser(user);
    assertNotNull(result);
}

@Test
void testFailureScenario() {
    // Error path
    when(repository.save(user))
        .thenThrow(new DatabaseException("Connection failed"));
    
    assertThrows(DatabaseException.class, 
        () -> service.saveUser(user));
}
```

### 9. Use Descriptive Variable Names
```java
// Good
int expectedSum = 5;
int actualResult = calculator.add(2, 3);
assertEquals(expectedSum, actualResult);

// Bad
int a = 5;
int b = calculator.add(2, 3);
assertEquals(a, b);
```

### 10. Keep Tests Fast and Isolated
```java
// Good: In-memory mock
@Mock
UserRepository mockRepository;

// Bad: Slow integration with real database
UserRepository realRepository = new JdbcUserRepository("prod_db");
```

### 11. Avoid Test Interdependencies
```java
// Good: Share setup via @Before, not state
@Before
public void setup() {
    calculator = new Calculator();
}

// Bad: Shared mutable state
private static Calculator calculator;

@Test
public void test1() {
    calculator.add(1, 1);
}

@Test
public void test2() {
    // Depends on state from test1
    assertEquals(2, calculator.getLastResult());
}
```

### 12. Code Coverage Targets
- **Line Coverage**: Aim for 80%+
- **Branch Coverage**: Aim for 70%+
- **Critical Code**: Aim for 100%

```bash
# JaCoCo Maven plugin for coverage
mvn clean test jacoco:report
```

---

## Real-World Examples

### Example 1: Calculator Service Tests

```java
public class CalculatorServiceTest {
    
    private CalculatorService calculator;
    
    @Before
    public void setUp() {
        calculator = new CalculatorService();
    }
    
    @Test
    public void testAddition() {
        assertEquals(5, calculator.add(2, 3));
    }
    
    @Test
    public void testAdditionWithNegatives() {
        assertEquals(-1, calculator.add(-5, 4));
    }
    
    @Test
    public void testDivisionByZero() {
        assertThrows(ArithmeticException.class, 
            () -> calculator.divide(10, 0));
    }
    
    @Test
    @DisplayName("Multiplication of large numbers")
    public void testMultiplication() {
        assertEquals(1000000000, calculator.multiply(1000000, 1000));
    }
}
```

### Example 2: User Service with Mocking

```java
@ExtendWith(MockitoExtension.class)
public class UserServiceTest {
    
    @Mock
    private UserRepository userRepository;
    
    @Mock
    private EmailService emailService;
    
    @InjectMocks
    private UserService userService;
    
    @Test
    void shouldCreateUserAndSendEmail() {
        // Arrange
        User newUser = new User("john@example.com", "password");
        User savedUser = new User(1, "john@example.com", "password");
        when(userRepository.save(newUser)).thenReturn(savedUser);
        
        // Act
        User result = userService.createUser(newUser);
        
        // Assert
        assertNotNull(result.getId());
        verify(emailService).sendWelcomeEmail("john@example.com");
    }
    
    @Test
    void shouldThrowExceptionWhenUserExists() {
        // Arrange
        User user = new User("john@example.com", "password");
        when(userRepository.findByEmail("john@example.com"))
            .thenReturn(user);
        
        // Act & Assert
        assertThrows(UserAlreadyExistsException.class,
            () -> userService.createUser(user));
    }
    
    @Test
    void shouldUpdateUser() {
        // Arrange
        User user = new User(1, "john@example.com", "password");
        when(userRepository.update(user)).thenReturn(user);
        
        // Act
        user.setEmail("newemail@example.com");
        userService.updateUser(user);
        
        // Assert
        ArgumentCaptor<User> captor = ArgumentCaptor.forClass(User.class);
        verify(userRepository).update(captor.capture());
        assertEquals("newemail@example.com", captor.getValue().getEmail());
    }
}
```

### Example 3: Parameterized Tests

```java
@ExtendWith(MockitoExtension.class)
public class MathUtilsParameterizedTest {
    
    @ParameterizedTest
    @CsvSource({
        "2, 3, 5",
        "0, 0, 0",
        "-1, 1, 0",
        "100, 200, 300"
    })
    void testAddition(int a, int b, int expected) {
        assertEquals(expected, a + b);
    }
    
    @ParameterizedTest
    @ValueSource(ints = {1, 2, 3, 4, 5})
    void testIsPositive(int number) {
        assertTrue(number > 0);
    }
    
    @ParameterizedTest
    @MethodSource("provideStringsForBlankCheck")
    void testBlankStrings(String input, boolean expected) {
        assertEquals(expected, input.isBlank());
    }
    
    static Stream<Arguments> provideStringsForBlankCheck() {
        return Stream.of(
            Arguments.of("", true),
            Arguments.of("   ", true),
            Arguments.of("hello", false),
            Arguments.of("  hello  ", false)
        );
    }
}
```

### Example 4: Test Suite

```java
@Suite
@SelectClasses({
    CalculatorServiceTest.class,
    UserServiceTest.class,
    MathUtilsParameterizedTest.class
})
public class AllUnitTests {
    // This class remains empty, just used to hold annotations
}

// Run with: mvn test -Dtest=AllUnitTests
```

### Example 5: Complete Real-World Service

```java
@ExtendWith(MockitoExtension.class)
public class OrderServiceTest {
    
    @Mock
    private OrderRepository orderRepository;
    
    @Mock
    private PaymentService paymentService;
    
    @Mock
    private NotificationService notificationService;
    
    @InjectMocks
    private OrderService orderService;
    
    private Order testOrder;
    private Customer testCustomer;
    
    @BeforeEach
    void setUp() {
        testCustomer = new Customer(1, "John Doe", "john@example.com");
        testOrder = new Order(1, testCustomer, new BigDecimal("99.99"));
    }
    
    @Test
    void shouldCreateOrderAndProcessPayment() {
        // Arrange
        when(orderRepository.save(any(Order.class))).thenReturn(testOrder);
        when(paymentService.processPayment(testOrder)).thenReturn(true);
        
        // Act
        Order result = orderService.createOrder(testOrder);
        
        // Assert
        assertNotNull(result.getId());
        assertEquals("PENDING", result.getStatus());
        verify(paymentService).processPayment(testOrder);
        verify(notificationService).notifyCustomer(testCustomer);
    }
    
    @Test
    void shouldCancelOrderIfPaymentFails() {
        // Arrange
        when(paymentService.processPayment(testOrder)).thenReturn(false);
        
        // Act
        orderService.createOrder(testOrder);
        
        // Assert
        verify(orderRepository).update(argThat(order -> 
            "CANCELLED".equals(order.getStatus())));
    }
    
    @ParameterizedTest
    @CsvSource({
        "PENDING, true, CONFIRMED",
        "CONFIRMED, true, SHIPPED",
        "SHIPPED, true, DELIVERED"
    })
    void shouldTransitionOrderStatus(String from, boolean success, String to) {
        // Arrange
        testOrder.setStatus(from);
        
        // Act
        orderService.transitionOrder(testOrder, success);
        
        // Assert
        assertEquals(to, testOrder.getStatus());
    }
}
```

---

## Advanced Testing Patterns

### 1. Builder Pattern for Test Data

**Theory:** Builder pattern reduces setup code and improves readability.

```java
// GOOD: Fluent builder for test data
public class UserBuilder {
    private String email = "test@example.com";
    private String name = "Test User";
    private int age = 25;
    
    public UserBuilder withEmail(String email) {
        this.email = email;
        return this;
    }
    
    public UserBuilder withName(String name) {
        this.name = name;
        return this;
    }
    
    public UserBuilder withAge(int age) {
        this.age = age;
        return this;
    }
    
    public User build() {
        return new User(email, name, age);
    }
}

@Test
void testUserCreation() {
    User user = new UserBuilder()
        .withEmail("john@example.com")
        .withAge(30)
        .build();
    
    assertEquals("john@example.com", user.getEmail());
    assertEquals(30, user.getAge());
}

@Test
void testWithDefaults() {
    User user = new UserBuilder().build();  // Uses defaults
    assertEquals("test@example.com", user.getEmail());
}
```

**Benefits:**
- Readable test data creation
- Default values reduce setup code
- Easy to create variations
- Supports immutable objects

### 2. TestFixture Base Class

**Theory:** Shared test setup reduces duplication.

```java
// Base class for common setup
public abstract class TestFixture {
    @Mock
    protected UserRepository userRepository;
    
    @Mock
    protected EmailService emailService;
    
    @InjectMocks
    protected UserService userService;
    
    protected User testUser;
    protected List<User> testUsers;
    
    @BeforeEach
    public void setUp() {
        testUser = new User(1, "john@example.com");
        testUsers = Arrays.asList(
            new User(1, "user1@example.com"),
            new User(2, "user2@example.com")
        );
    }
}

// Test class inherits common setup
public class UserServiceTest extends TestFixture {
    
    @Test
    void testCreateUser() {
        when(userRepository.save(testUser)).thenReturn(testUser);
        
        User result = userService.createUser(testUser);
        
        assertNotNull(result.getId());
    }
    
    @Test
    void testGetAllUsers() {
        when(userRepository.findAll()).thenReturn(testUsers);
        
        List<User> result = userService.getAllUsers();
        
        assertEquals(2, result.size());
    }
}
```

### 3. Custom Assertions

**Theory:** Domain-specific assertions improve test readability.

```java
public class OrderAssertions {
    private Order order;
    
    private OrderAssertions(Order order) {
        this.order = order;
    }
    
    public static OrderAssertions assertThat(Order order) {
        return new OrderAssertions(order);
    }
    
    public OrderAssertions hasStatus(String status) {
        assertEquals(status, order.getStatus(), 
            "Order status should be " + status);
        return this;
    }
    
    public OrderAssertions hasTotalAmount(double amount) {
        assertEquals(amount, order.getTotal(), 0.01,
            "Order total should be " + amount);
        return this;
    }
    
    public OrderAssertions hasItemCount(int count) {
        assertEquals(count, order.getItems().size(),
            "Order should have " + count + " items");
        return this;
    }
}

// Usage in tests
@Test
void testOrderCreation() {
    Order order = orderService.createOrder(items);
    
    assertThat(order)
        .hasStatus("PENDING")
        .hasTotalAmount(99.99)
        .hasItemCount(3);
}
```

### 4. Test Categories and Tagging

**Theory:** Tags enable selective test execution.

```java
// JUnit 5 Tags
public class ServiceTest {
    
    @Test
    @Tag("unit")
    void testBasicFunctionality() { }
    
    @Test
    @Tag("integration")
    @Tag("slow")
    void testWithDatabase() { }
    
    @Test
    @Tag("security")
    void testAuthorizationCheck() { }
}

// Maven: Run only unit tests
// mvn test -Dgroups=unit

// Gradle: Run only unit tests
// gradle test --tests *ServiceTest --include-pattern **/unit/**
```

### 5. Spy vs Mock

**Theory:** Spies allow partial mocking of real objects.

```java
@ExtendWith(MockitoExtension.class)
public class SpyVsMockTest {
    
    @Test
    void demoMock() {
        List<String> mockedList = mock(ArrayList.class);
        
        // Mock returns null for unmocked methods
        mockedList.add("A");
        assertEquals(0, mockedList.size());  // Not tracked
    }
    
    @Test
    void demoSpy() {
        List<String> spyList = spy(new ArrayList<>());
        
        // Spy calls real methods
        spyList.add("A");
        assertEquals(1, spyList.size());  // Real behavior
        
        // But can still verify calls
        verify(spyList).add("A");
    }
    
    @Test
    void spyUsage() {
        UserRepository spyRepository = spy(new JdbcUserRepository());
        
        // Call real repository logic
        User user = spyRepository.findById(1);
        
        // But verify it was called
        verify(spyRepository).findById(1);
        
        // Can also stub some methods
        when(spyRepository.getStatus()).thenReturn("connected");
    }
}
```

### 6. Behavior-Driven Development (BDD)

**Theory:** BDD uses Given-When-Then structure with special libraries.

```java
// Using BDD style with Mockito
@ExtendWith(MockitoExtension.class)
public class UserServiceBDDTest {
    
    @Mock
    UserRepository userRepository;
    
    @InjectMocks
    UserService userService;
    
    @Test
    void userCanCreateAccountWithValidEmail() {
        // GIVEN: A user with valid email exists
        User user = new User("john@example.com");
        BDDMockito.given(userRepository.save(user))
            .willReturn(new User(1, "john@example.com"));
        
        // WHEN: User creates an account
        User result = userService.createUser(user);
        
        // THEN: Account is created successfully
        assertNotNull(result.getId());
        BDDMockito.then(userRepository).should().save(user);
    }
    
    @Test
    void userCannotCreateAccountWithInvalidEmail() {
        // GIVEN: Invalid email format
        User user = new User("invalid-email");
        
        // WHEN: User tries to create account
        // THEN: Exception is thrown
        assertThrows(InvalidEmailException.class,
            () -> userService.createUser(user));
    }
}
```

### 7. Data-Driven Testing

**Theory:** Separate test logic from test data for better coverage.

```java
@ExtendWith(MockitoExtension.class)
public class DataDrivenTest {
    
    @ParameterizedTest
    @CsvSource({
        "john@example.com, valid",
        "invalid.email, invalid",
        "user@, invalid",
        "@example.com, invalid",
        "test+tag@example.co.uk, valid"
    })
    void testEmailValidation(String email, String expected) {
        // ARRANGE & ACT
        boolean isValid = emailValidator.isValid(email);
        
        // ASSERT
        if ("valid".equals(expected)) {
            assertTrue(isValid, email + " should be valid");
        } else {
            assertFalse(isValid, email + " should be invalid");
        }
    }
    
    static class CreditCardTestCase {
        String cardNumber;
        boolean shouldBeValid;
        
        CreditCardTestCase(String cardNumber, boolean shouldBeValid) {
            this.cardNumber = cardNumber;
            this.shouldBeValid = shouldBeValid;
        }
    }
    
    @ParameterizedTest
    @MethodSource("creditCardTestCases")
    void testCreditCardValidation(CreditCardTestCase testCase) {
        boolean result = cardValidator.isValid(testCase.cardNumber);
        assertEquals(testCase.shouldBeValid, result);
    }
    
    static Stream<CreditCardTestCase> creditCardTestCases() {
        return Stream.of(
            new CreditCardTestCase("4532015112830366", true),
            new CreditCardTestCase("4532015112830367", false),
            new CreditCardTestCase("invalid", false),
            new CreditCardTestCase("", false)
        );
    }
}
```

### 8. Mutation Testing

**Theory:** Verify tests are actually catching bugs.

```bash
# Maven: Add PIT mutation testing plugin
# pom.xml
<plugin>
    <groupId>org.pitest</groupId>
    <artifactId>pitest-maven</artifactId>
    <version>1.14.2</version>
    <configuration>
        <targetClasses>
            <param>com.example.service.*</param>
        </targetClasses>
    </configuration>
</plugin>

# Run mutation tests
mvn org.pitest:pitest-maven:mutationCoverage

# This intentionally introduces bugs and checks if tests catch them
# Example: Changes > to >=, true to false, etc.
```

### Key Points for Advanced Patterns
✓ Use builder pattern for complex test data  
✓ Extract common setup to base fixture classes  
✓ Create domain-specific custom assertions  
✓ Tag tests for selective execution  
✓ Understand difference between Spies and Mocks  
✓ Apply BDD structure for behavior verification  
✓ Use data-driven tests to reduce duplication  
✓ Consider mutation testing for quality assurance

---

## Advanced Topics

### 1. Custom Rules (JUnit 4)
```java
public class RandomPortRule implements TestRule {
    private int port;
    
    @Override
    public Statement apply(Statement base, Description description) {
        return new Statement() {
            @Override
            public void evaluate() throws Throwable {
                port = randomPort();
                base.evaluate();
            }
        };
    }
    
    public int getPort() { return port; }
    private int randomPort() { return new Random().nextInt(65535) + 1000; }
}

public class ServerTest {
    @Rule
    public RandomPortRule portRule = new RandomPortRule();
    
    @Test
    public void testServer() {
        int port = portRule.getPort();
        // Use port
    }
}
```

### 2. Custom Extensions (JUnit 5)
```java
public class LoggingExtension implements TestExecutionListener {
    @Override
    public void testStarted(TestExecutionContext context) {
        System.out.println("Test started: " + context.getDisplayName());
    }
}

@ExtendWith(LoggingExtension.class)
public class MyTest {
    @Test
    void myTest() { }
}
```

### 3. Nested Tests (JUnit 5)
```java
public class CalculatorTest {
    
    @Nested
    @DisplayName("Addition tests")
    class AdditionTests {
        @Test
        void testAddPositive() { }
        
        @Test
        void testAddNegative() { }
    }
    
    @Nested
    @DisplayName("Subtraction tests")
    class SubtractionTests {
        @Test
        void testSubtractPositive() { }
    }
}
```

---

## Common Pitfalls and Solutions

### Pitfall Analysis with Examples

| Pitfall | Problem | Impact | Solution |
|---------|---------|--------|----------|
| **Mutable Shared State** | Tests modify shared objects affecting other tests | Flaky, order-dependent failures | Use @Before to reset state per test |
| **Unclear Test Names** | Hard to understand test purpose from name | Time spent debugging; unclear coverage | Use descriptive names: testAddition_WithPositiveNumbers_ReturnsCorrectSum() |
| **Testing Implementation** | Tests depend on how code is written | Break on refactoring even if behavior unchanged | Test public behavior, not private implementation |
| **Too Many Assertions** | Multiple failures in one test | First failure stops test; hard to identify cause | One logical assertion per test |
| **Testing Private Methods** | Tight coupling to implementation details | Tests break on refactoring | Test through public interface only |
| **Slow Tests** | Slow test suite discourages running tests | Slow feedback loop; reduced test frequency | Mock external dependencies; use in-memory alternatives |
| **Flaky Tests** | Random failures based on timing or data | Unreliable test suite; hard to debug | Use deterministic data; avoid time dependencies |
| **No Exception Testing** | Error paths untested | Poor error handling in production | Test both success and error paths |
| **Over-Mocking** | Mocking too much code | Tests don't verify real interactions | Mock only external dependencies; test real logic |
| **Under-Mocking** | Testing with real external systems | Slow, flaky, order-dependent tests | Mock databases, APIs, file systems |

### Detailed Pitfall Examples

#### Pitfall 1: Mutable Shared State
```java
// PROBLEM: Shared state causes test interference
public class FlakeyTest {
    private static List<String> items = new ArrayList<>();  // Shared!
    
    @Test
    void testAddItem() {
        items.add("A");
        assertEquals(1, items.size());  // May fail!
    }
    
    @Test
    void testEmptyList() {
        assertEquals(0, items.size());  // May fail if testAddItem ran first!
    }
}

// SOLUTION: Reset state before each test
public class FixedTest {
    private List<String> items;
    
    @Before
    public void setUp() {
        items = new ArrayList<>();  // Fresh per test
    }
    
    @Test
    void testAddItem() {
        items.add("A");
        assertEquals(1, items.size());  // Always passes
    }
    
    @Test
    void testEmptyList() {
        assertEquals(0, items.size());  // Always passes
    }
}
```

#### Pitfall 2: Testing Private Methods
```java
// PROBLEM: Tests tied to implementation
public class WrongApproach {
    private PrivateClass privClass = new PrivateClass();
    
    @Test
    void testPrivateMethod() throws Exception {
        // Reflection to access private method (BAD)
        Method method = PrivateClass.class
            .getDeclaredMethod("privateMethod");
        method.setAccessible(true);
        int result = (int) method.invoke(privClass);
        
        assertEquals(42, result);  // Tests implementation, not behavior
    }
}

// SOLUTION: Test through public interface
public class CorrectApproach {
    private PrivateClass privClass = new PrivateClass();
    
    @Test
    void testPublicBehavior() {
        int result = privClass.publicMethod();  // Tests behavior
        assertEquals(42, result);  // Works if private method changes
    }
}
```

#### Pitfall 3: No Exception Testing
```java
// PROBLEM: Error paths untested
public class IncompleteCoverage {
    @Test
    void testHappyPath() {
        // Only tests success case
        User user = userService.createUser(validUser);
        assertNotNull(user);
    }
    // Error paths never tested!
}

// SOLUTION: Test both paths
public class CompleteCoverage {
    @Test
    void testHappyPath() {
        User user = userService.createUser(validUser);
        assertNotNull(user);
    }
    
    @Test
    void testNullInput() {
        assertThrows(NullPointerException.class,
            () -> userService.createUser(null));
    }
    
    @Test
    void testInvalidEmail() {
        User invalidUser = new User("not-an-email");
        assertThrows(IllegalArgumentException.class,
            () -> userService.createUser(invalidUser));
    }
}
```

#### Pitfall 4: Flaky Tests
```java
// PROBLEM: Time-dependent tests
public class FlakyTest {
    @Test
    void testTimeSensitive() {
        long startTime = System.currentTimeMillis();
        processData();
        long endTime = System.currentTimeMillis();
        
        assertTrue(endTime - startTime < 100);  // Flaky on slow system!
    }
}

// SOLUTION: Use fixed time or mock time
public class StableTest {
    @Test
    void testWithMockedTime() {
        // Mock time provider instead of using system time
        when(mockTimeProvider.getCurrentTime())
            .thenReturn(1000000L);
        
        // Deterministic test
        assertEquals(1000000L, mockTimeProvider.getCurrentTime());
    }
}
```

#### Pitfall 5: Slow Tests
```java
// PROBLEM: Tests are slow due to real dependencies
@Test
public void testSlowIntegration() {
    Database realDb = new Database("production");
    realDb.connect();  // 5 seconds
    realDb.insert(largeDataset);  // 10 seconds
    
    List<User> results = realDb.query("SELECT * FROM users");
    // Total: ~20 seconds for one test!
}

// SOLUTION: Mock external dependencies
@Mock
Database mockDb;

@Test
public void testFastUnit() {
    when(mockDb.query(any())).thenReturn(testUsers);
    
    List<User> results = userService.getAllUsers();
    
    assertEquals(2, results.size());  // < 1ms
}
```

### Prevention Checklist
- [ ] Is each test completely independent?
- [ ] Does test name clearly describe what's tested?
- [ ] Are external dependencies mocked?
- [ ] Does test verify behavior, not implementation?
- [ ] Are private methods not tested directly?
- [ ] Is test deterministic (no random/time dependencies)?
- [ ] Does test complete in < 100ms?
- [ ] Are both success and error paths tested?
- [ ] Can tests run in any order?
- [ ] Can tests run in parallel?

### Key Points for Pitfalls
✓ Shared state causes test interference  
✓ Test names should document behavior  
✓ Test public interface, not private implementation  
✓ Mock external dependencies to ensure speed  
✓ Test error cases in addition to happy path  
✓ Avoid time-dependent and random test data  
✓ Keep tests isolated and independent  
✓ Run tests frequently to catch issues early  
✓ Use static code analysis to detect test issues

---

## Summary and Key Takeaways

### Core JUnit Concepts
1. **JUnit Framework**: Standard Java testing framework following xUnit pattern
2. **Test Lifecycle**: Tests run in controlled lifecycle with setup/teardown
3. **Annotations**: Declarative test configuration (@Test, @Before, etc.)
4. **Assertions**: Verify expected behavior with fluent API
5. **Fixtures**: Reusable test data and setup code
6. **Mocking**: Isolate code under test from dependencies

### Testing Fundamentals
- **Unit Testing**: Test small units in isolation
- **AAA Pattern**: Arrange-Act-Assert structure
- **Test Independence**: No shared state or order dependencies
- **Determinism**: Same result every time
- **Speed**: Fast feedback on changes
- **Clarity**: Self-documenting test code

### JUnit 4 vs JUnit 5
- **JUnit 4**: Annotation-based testing framework
- **JUnit 5**: Modular architecture with Platform, Jupiter, Vintage
- **Jupiter**: Modern JUnit 5 testing engine
- **Features**: JUnit 5 adds parameterized tests, extensions, tags, nested tests

### Best Practices
1. Use descriptive test names
2. One logical assertion per test
3. Ensure test independence
4. Follow AAA pattern
5. Mock external dependencies
6. Test edge cases
7. Test error paths
8. Keep tests fast
9. Use meaningful assertion messages
10. Document complex logic

### Testing Workflow (TDD)
```
RED: Write failing test
  ↓
GREEN: Write minimal code to pass
  ↓
REFACTOR: Improve while maintaining passing tests
  ↓
Repeat
```

### Quality Metrics
- **Code Coverage**: 75-85% target
- **Test Speed**: < 100ms per unit test
- **Flakiness**: 0% - tests must be deterministic
- **Independence**: 100% - no shared state
- **Clarity**: Test names document behavior

### Common Patterns
- **Builder Pattern**: Fluent test data creation
- **Fixture Base Class**: Shared setup code
- **Custom Assertions**: Domain-specific verification
- **Parameterized Tests**: Data-driven testing
- **BDD**: Given-When-Then structure
- **Spies**: Partial mocking for selective verification

### Anti-Patterns to Avoid
- Shared mutable state
- Unclear test names
- Testing private methods
- Over-mocking
- Under-mocking
- Slow tests
- Flaky tests
- Execution order dependencies
- Untested error paths
- Too many assertions

### When to Use JUnit
- **Always**: Unit testing Java code
- **Always**: Regression testing
- **Always**: TDD development
- **Often**: Integration testing
- **Sometimes**: E2E testing (consider Selenium/Cypress)
- **Rarely**: Performance testing (use JMH)

### Testing Pyramid
```
        E2E Tests (10%)
           /  \
         /      \
    Integration Tests (30%)
      /              \
    /                  \
Unit Tests (60%)
```

### Key Competencies Covered
✓ JUnit framework fundamentals  
✓ Test lifecycle and fixtures  
✓ Assertion and exception testing  
✓ Mockito mocking framework  
✓ Parameterized and data-driven tests  
✓ Test organization and suites  
✓ Best practices and patterns  
✓ Common pitfalls and solutions  
✓ Advanced testing techniques  
✓ Test-Driven Development (TDD)  
✓ Code coverage analysis  
✓ Behavior-Driven Development (BDD)

### Further Learning
- **JUnit Official**: junit.org
- **Mockito Documentation**: site.mockito.org
- **Test Driven Development**: "Test Driven Development: By Example" by Kent Beck
- **Clean Code**: Testing chapter in "Clean Code" by Robert Martin
- **Working Effectively with Legacy Code**: Michael Feathers

### Practice Exercises
1. Convert manual test to JUnit
2. Increase code coverage to 80%
3. Write parameterized test with 10+ data points
4. Create test suite with nested tests
5. Implement custom assertions
6. Build test fixture base class
7. Practice mocking complex dependencies
8. Write BDD-style tests
9. Fix flaky tests in legacy code
10. Apply builder pattern to test data

---

This comprehensive guide covers JUnit testing from fundamentals through advanced patterns, providing the theoretical foundation and practical examples needed to master unit testing in Java.

---

# JUnit Interview Questions & Answers

## Complete Guide from Beginner to Advanced

---

## Beginner Level Questions

### Q1: What is JUnit and why is it important?

**Answer:**

JUnit is an open-source unit testing framework for Java that enables developers to write and run automated tests for individual units of code (methods, classes). It's the de facto standard for unit testing in the Java ecosystem.

**Importance:**
- **Early Bug Detection**: Catches defects before they reach production
- **Code Quality**: Ensures code meets specifications and design standards
- **Regression Prevention**: Verifies changes don't break existing functionality
- **Documentation**: Tests serve as executable documentation of code behavior
- **Refactoring Confidence**: Allows safe code improvements with test verification
- **Development Speed**: TDD approach can accelerate overall development
- **Maintenance**: Makes code easier to modify and extend

**Key Statistics:**
- High adoption rate in enterprise Java development
- Integrates seamlessly with CI/CD pipelines
- Supported by all major IDEs (Eclipse, IntelliJ, NetBeans)
- Actively maintained with regular updates

---

### Q2: What are the main differences between JUnit 4 and JUnit 5?

**Answer:**

| Feature | JUnit 4 | JUnit 5 |
|---------|---------|---------|
| **Architecture** | Monolithic | Modular (Platform, Jupiter, Vintage) |
| **Annotations** | `@Test`, `@Before`, `@After` | `@Test`, `@BeforeEach`, `@AfterEach` |
| **Setup/Teardown** | `@BeforeClass`, `@AfterClass` | `@BeforeAll`, `@AfterAll` |
| **Parametrized Tests** | `@RunWith(Parameterized.class)` | `@ParameterizedTest` (native) |
| **Meta-Annotations** | No support | Full support |
| **Extension Model** | Rules | Cleaner Extensions API |
| **Java Version** | Java 1.3+ | Java 8+ (lambda support) |
| **Lambda Support** | No | Full support |
| **Conditional Test Execution** | No | `@EnabledIf`, `@DisabledIf` |
| **Test Tags** | No | `@Tag` for categorization |
| **Nesting Tests** | No | `@Nested` for organization |

**Migration Path:**
- JUnit 4 tests can run on JUnit 5 via Vintage engine
- Gradual migration possible without rewriting all tests
- New projects should use JUnit 5

---

### Q3: What are the core annotations in JUnit?

**Answer:**

**Test Lifecycle Annotations:**

```java
@BeforeAll     // Runs once before any test method (static, JUnit 5: @BeforeAll)
@BeforeClass   // Runs once before any test method (JUnit 4)

@BeforeEach    // Runs before each @Test method (JUnit 5)
@Before        // Runs before each @Test method (JUnit 4)

@Test          // Marks method as a test case

@AfterEach     // Runs after each @Test method (JUnit 5)
@After         // Runs after each @Test method (JUnit 4)

@AfterAll      // Runs once after all test methods (static, JUnit 5)
@AfterClass    // Runs once after all test methods (JUnit 4)
```

**Conditional Execution (JUnit 5):**
```java
@Disabled          // Disables test method
@EnabledOnOs       // Enable on specific OS
@EnabledIfEnvironmentVariable  // Conditional on env var
@EnabledIf         // Custom condition
```

**Organization (JUnit 5):**
```java
@Nested     // Groups related test cases in inner class
@Tag        // Tags tests for filtering
```

**Execution Control:**
```java
@ParameterizedTest  // Runs test with multiple parameter sets
@RepeatedTest       // Runs test multiple times
@TestFactory        // Dynamic test generation
```

---

### Q4: What are assertions and what are commonly used assertions?

**Answer:**

Assertions are statements that verify the expected behavior of code. They check if actual results match expected results and fail the test if they don't.

**Common Assertions (JUnit 4 & 5):**

```java
// Equality
assertEquals(expected, actual);
assertEquals(expected, actual, "Error message");
assertNotEquals(expected, actual);

// Null checks
assertNull(object);
assertNotNull(object);

// Boolean conditions
assertTrue(condition);
assertFalse(condition);

// Object identity
assertSame(expected, actual);           // Same reference
assertNotSame(expected, actual);        // Different reference

// Arrays
assertArrayEquals(expected, actual);

// Iterable/Collections
assertEquals(expected, actual);         // For collections

// Exception testing
assertThrows(ExceptionType.class, () -> {
    // code that should throw exception
});

// Timeout (JUnit 4)
@Test(timeout = 1000)  // Test must complete in 1000ms

// Timeout (JUnit 5)
assertTimeout(Duration.ofSeconds(2), () -> {
    // code that should complete within 2 seconds
});
```

**AssertJ (Fluent Assertions):**
```java
assertThat(actual).isEqualTo(expected);
assertThat(actual).isNotNull().isInstanceOf(String.class);
assertThat(list).contains(item1, item2).hasSize(2);
assertThat(exception).hasMessage("Error");
```

**Best Practice:** Use one assertion per test method or group related assertions logically.

---

### Q5: What is a test fixture and how do you set it up?

**Answer:**

A **test fixture** is the setup of objects or state needed by tests to run properly. It ensures each test starts in a known, consistent state.

**Setup Methods:**

```java
// JUnit 4
public class CalculatorTest {
    private Calculator calculator;
    private List<Integer> numbers;
    
    @BeforeClass
    public static void setUpClass() {
        // Expensive setup (database, server)
        // Runs once before all tests
    }
    
    @Before
    public void setUp() {
        // Fresh setup for each test
        calculator = new Calculator();
        numbers = new ArrayList<>();
    }
    
    @After
    public void tearDown() {
        // Cleanup after each test
        calculator = null;
        numbers = null;
    }
    
    @AfterClass
    public static void tearDownClass() {
        // Final cleanup (close database, server)
    }
}

// JUnit 5 equivalent
public class CalculatorTest {
    @BeforeAll
    static void setUpAll() { }
    
    @BeforeEach
    void setUp() { }
    
    @AfterEach
    void tearDown() { }
    
    @AfterAll
    static void tearDownAll() { }
}
```

**Test Fixture Best Practices:**
- Keep fixtures minimal and focused
- Use builder pattern for complex setup
- Reuse fixtures via inheritance
- Document assumptions in fixture setup
- Clean up resources in tearDown

**Execution Order:**
```
BeforeClass (static, once)
  ↓
BeforeEach (before each @Test)
  ↓
@Test
  ↓
AfterEach (after each @Test)
  ↓
AfterClass (static, once)
```

---

## Intermediate Level Questions

### Q6: What is mocking and when should you use it?

**Answer:**

**Mocking** is the practice of creating fake objects (mocks) that simulate the behavior of real objects. Mocks help isolate the code under test from its dependencies.

**Why Mock:**
- **Isolation**: Test units independently without external dependencies
- **Speed**: Eliminate slow operations (database, API calls)
- **Reliability**: Remove flaky dependencies
- **Simulation**: Simulate error conditions easily
- **Control**: Control dependency behavior precisely

**Common Scenarios:**
```java
// Database operation
@Test
public void testUserService() {
    UserRepository mockRepo = mock(UserRepository.class);
    when(mockRepo.findById(1)).thenReturn(new User(1, "John"));
    
    UserService service = new UserService(mockRepo);
    User user = service.getUser(1);
    
    assertEquals("John", user.getName());
    verify(mockRepo).findById(1);
}

// External API call
@Test
public void testWeatherService() {
    WeatherAPI mockAPI = mock(WeatherAPI.class);
    when(mockAPI.getTemperature("NYC")).thenReturn(75);
    
    WeatherService service = new WeatherService(mockAPI);
    int temp = service.getTemperature("NYC");
    
    assertEquals(75, temp);
}

// Void method verification
@Test
public void testEmailNotification() {
    EmailService mockEmail = mock(EmailService.class);
    UserService service = new UserService(mockEmail);
    
    service.registerUser("user@example.com");
    
    verify(mockEmail).sendWelcomeEmail("user@example.com");
}
```

**Mock vs Stub vs Spy:**
| Type | Behavior | Verification | Usage |
|------|----------|--------------|-------|
| Mock | Fake behavior | Yes | Most common |
| Stub | Canned responses | No | Simple responses |
| Spy | Real + selective override | Yes | Real objects, partial mocking |

---

### Q7: What are parameterized tests and when are they useful?

**Answer:**

**Parameterized tests** run the same test logic with different input parameters, reducing code duplication and enabling data-driven testing.

**JUnit 4 Approach:**
```java
@RunWith(Parameterized.class)
public class CalculatorParameterizedTest {
    private int a;
    private int b;
    private int expected;
    
    @Parameterized.Parameters
    public static Collection<Object[]> data() {
        return Arrays.asList(new Object[][] {
            { 2, 3, 5 },      // a, b, expected sum
            { 0, 0, 0 },
            { -1, 1, 0 },
            { 100, 200, 300 }
        });
    }
    
    public CalculatorParameterizedTest(int a, int b, int expected) {
        this.a = a;
        this.b = b;
        this.expected = expected;
    }
    
    @Test
    public void testAdd() {
        Calculator calc = new Calculator();
        assertEquals(expected, calc.add(a, b));
    }
}
```

**JUnit 5 Approach (More Elegant):**
```java
@ParameterizedTest
@ValueSource(ints = { 1, 2, 3, 4, 5 })
void testIsPrime(int number) {
    assertTrue(isPrime(number));
}

@ParameterizedTest
@CsvSource({
    "2, 3, 5",
    "0, 0, 0",
    "-1, 1, 0"
})
void testAdd(int a, int b, int expected) {
    Calculator calc = new Calculator();
    assertEquals(expected, calc.add(a, b));
}

@ParameterizedTest
@MethodSource("provideData")
void testWithMethodSource(int input, String expected) {
    // Test logic
}

private static Stream<Arguments> provideData() {
    return Stream.of(
        Arguments.of(1, "one"),
        Arguments.of(2, "two"),
        Arguments.of(3, "three")
    );
}

@ParameterizedTest
@CsvFileSource(resources = "/data.csv")
void testFromCsvFile(String input, String expected) {
    // Test logic
}
```

**When to Use:**
- Testing multiple scenarios of same logic
- Boundary value testing
- Equivalence partitioning
- Data-driven testing
- Reducing test code duplication

**Benefits:**
- Less repetitive code
- Clear data/logic separation
- Better coverage documentation
- Easier maintenance

---

### Q8: What are test suites and how do you organize them?

**Answer:**

**Test Suites** are collections of test classes grouped together for organized execution.

**JUnit 4 Test Suite:**
```java
@RunWith(Suite.class)
@Suite.SuiteClasses({
    CalculatorTest.class,
    StringUtilTest.class,
    DateUtilTest.class
})
public class UtilsTestSuite {
    // Empty class, just container
}

// Run all tests in suite
junit.textui.TestRunner.run(UtilsTestSuite.class);
```

**JUnit 5 Nested Tests:**
```java
@DisplayName("String Utils Tests")
class StringUtilsTest {
    
    @Nested
    @DisplayName("length() method")
    class LengthTests {
        @Test
        void testEmptyString() {
            assertEquals(0, StringUtils.length(""));
        }
        
        @Test
        void testNonEmptyString() {
            assertEquals(5, StringUtils.length("hello"));
        }
    }
    
    @Nested
    @DisplayName("reverse() method")
    class ReverseTests {
        @Test
        void testBasicReverse() {
            assertEquals("olleh", StringUtils.reverse("hello"));
        }
    }
}
```

**Maven Test Execution (Grouping by Pattern):**
```bash
# Run all tests
mvn test

# Run specific test class
mvn test -Dtest=CalculatorTest

# Run tests matching pattern
mvn test -Dtest=*Test

# Run specific test method
mvn test -Dtest=CalculatorTest#testAdd
```

**Test Categorization with Tags (JUnit 5):**
```java
@Test
@Tag("unit")
void quickTest() { }

@Test
@Tag("integration")
void databaseTest() { }

// Run only specific tags
@RunWith(JUnitPlatform.class)
@SelectTags("unit")
class UnitTestSuite { }

// Maven command
mvn test -Dgroups="unit"
```

**Best Practices:**
- Organize by functionality, not test type
- Use meaningful suite names
- Keep suites focused and manageable
- Tag tests for filtering (smoke, integration, slow, etc.)

---

### Q9: What is the difference between @Before and @BeforeEach?

**Answer:**

There is NO functional difference - they are the same annotation with different names:

**JUnit 4:**
```java
@Before  // Old name
public void setUp() {
    // Runs before each @Test
}
```

**JUnit 5:**
```java
@BeforeEach  // New name (more descriptive)
void setUp() {
    // Runs before each @Test
}
```

**Why the rename:**
- JUnit 5 clarified naming: "Each" = before each test, "All" = all tests
- More consistent with `@BeforeAll`, `@AfterEach`, `@AfterAll`
- Clearer intent

**Complete Mapping:**
| JUnit 4 | JUnit 5 | Meaning |
|---------|---------|---------|
| @Before | @BeforeEach | Before each test |
| @After | @AfterEach | After each test |
| @BeforeClass | @BeforeAll | Before all tests (static) |
| @AfterClass | @AfterAll | After all tests (static) |
| @Ignore | @Disabled | Skip test |

**JUnit 5 Code Example:**
```java
public class TestLifecycleExample {
    
    @BeforeAll
    static void initializeOnce() {
        System.out.println("Run once before all tests");
    }
    
    @BeforeEach
    void initializeBeforeEach() {
        System.out.println("Run before each test");
    }
    
    @Test
    void test1() {
        System.out.println("Test 1");
    }
    
    @Test
    void test2() {
        System.out.println("Test 2");
    }
    
    @AfterEach
    void cleanupAfterEach() {
        System.out.println("Run after each test");
    }
    
    @AfterAll
    static void cleanupOnce() {
        System.out.println("Run once after all tests");
    }
}

// Output:
// Run once before all tests
// Run before each test
// Test 1
// Run after each test
// Run before each test
// Test 2
// Run after each test
// Run once after all tests
```

---

### Q10: How do you test exceptions in JUnit?

**Answer:**

**JUnit 4 Approach:**
```java
// Method 1: @Test(expected=...)
@Test(expected = IllegalArgumentException.class)
public void testDivideByZero() {
    Calculator calc = new Calculator();
    calc.divide(10, 0);  // Should throw exception
}

// Method 2: try-catch with fail()
@Test
public void testDivideByZero() {
    Calculator calc = new Calculator();
    try {
        calc.divide(10, 0);
        fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException e) {
        assertEquals("Cannot divide by zero", e.getMessage());
    }
}

// Method 3: ExpectedException Rule
@Rule
public ExpectedException thrown = ExpectedException.none();

@Test
public void testDivideByZero() {
    thrown.expect(IllegalArgumentException.class);
    thrown.expectMessage("Cannot divide by zero");
    
    Calculator calc = new Calculator();
    calc.divide(10, 0);
}
```

**JUnit 5 Approach (Preferred):**
```java
@Test
void testDivideByZero() {
    Calculator calc = new Calculator();
    
    IllegalArgumentException exception = assertThrows(
        IllegalArgumentException.class,
        () -> calc.divide(10, 0)
    );
    
    assertEquals("Cannot divide by zero", exception.getMessage());
}

// Multiple assertions on exception
@Test
void testComplexException() {
    CustomException exception = assertThrows(
        CustomException.class,
        () -> riskyOperation()
    );
    
    assertEquals(500, exception.getErrorCode());
    assertTrue(exception.getMessage().contains("timeout"));
}

// Asserting NO exception
@Test
void testNoException() {
    assertDoesNotThrow(() -> {
        int result = calculator.add(2, 3);
        assertEquals(5, result);
    });
}
```

**Testing Custom Exceptions:**
```java
public class InvalidUserException extends Exception {
    private int errorCode;
    
    public InvalidUserException(String message, int errorCode) {
        super(message);
        this.errorCode = errorCode;
    }
    
    public int getErrorCode() {
        return errorCode;
    }
}

@Test
void testCustomException() {
    InvalidUserException exception = assertThrows(
        InvalidUserException.class,
        () -> userService.createUser(null)
    );
    
    assertEquals("User cannot be null", exception.getMessage());
    assertEquals(400, exception.getErrorCode());
}
```

**Best Practices:**
- Test both exception type AND message
- Verify exception is thrown at right time
- Use specific exception types, not generic Exception
- In JUnit 5, prefer `assertThrows` over `@Test(expected=...)`

---

## Advanced Level Questions

### Q11: What is Test-Driven Development (TDD) and its cycle?

**Answer:**

**Test-Driven Development (TDD)** is a development practice where tests are written BEFORE the implementation code.

**TDD Cycle (Red-Green-Refactor):**

```
1. RED PHASE
   ├─ Write a failing test
   ├─ Test describes desired behavior
   └─ Code doesn't exist yet

2. GREEN PHASE
   ├─ Write minimal code to make test pass
   ├─ Focus: make test green, not perfect code
   └─ No concerns about optimization

3. REFACTOR PHASE
   ├─ Improve code quality
   ├─ Maintain green test status
   ├─ Apply design patterns
   └─ DRY (Don't Repeat Yourself)

Repeat for next feature...
```

**Example:**

```java
// PHASE 1: RED - Write failing test
@Test
void testBankAccountWithdrawal() {
    BankAccount account = new BankAccount(1000);
    account.withdraw(200);
    
    assertEquals(800, account.getBalance());
}
// Test fails - BankAccount class doesn't exist

// PHASE 2: GREEN - Minimal implementation
public class BankAccount {
    private double balance;
    
    public BankAccount(double initialBalance) {
        this.balance = initialBalance;
    }
    
    public void withdraw(double amount) {
        balance -= amount;
    }
    
    public double getBalance() {
        return balance;
    }
}
// Test passes

// PHASE 3: REFACTOR - Improve implementation
public class BankAccount {
    private double balance;
    
    public BankAccount(double initialBalance) {
        if (initialBalance < 0) {
            throw new IllegalArgumentException("Initial balance cannot be negative");
        }
        this.balance = initialBalance;
    }
    
    public void withdraw(double amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("Withdrawal amount must be positive");
        }
        if (amount > balance) {
            throw new IllegalArgumentException("Insufficient funds");
        }
        balance -= amount;
    }
    
    public double getBalance() {
        return balance;
    }
}
// Test still passes, code is better
```

**TDD Benefits:**
- Better design: Forces you to think about interfaces first
- Fewer bugs: More comprehensive testing
- Confidence: Comprehensive test coverage from start
- Documentation: Tests show how code should be used
- Refactoring safety: Can improve code without fear
- Reduced debugging: Catch issues early

**TDD Challenges:**
- Requires discipline and practice
- Initial slower development (but pays off)
- Tests must be well-designed too
- Not suitable for exploratory prototyping

**When to Use TDD:**
- ✅ Complex business logic
- ✅ Critical systems requiring reliability
- ✅ Long-term projects with maintenance
- ✅ Team environments with code reviews
- ❌ Quick prototypes/exploration
- ❌ Extremely simple scripts
- ❌ When requirements are very unclear

---

### Q12: What are best practices for writing maintainable tests?

**Answer:**

**1. Clear, Descriptive Test Names**
```java
// Bad
@Test
void test1() { }

@Test
void testUser() { }

// Good
@Test
void testWithdrawalReducesBalanceCorrectly() { }

@Test
void testTransactionFailsWhenInsufficientFunds() { }

@Test
@DisplayName("Should reject withdrawal when balance is insufficient")
void testInsufficientFundsRejection() { }
```

**2. Arrange-Act-Assert (AAA) Pattern**
```java
@Test
void testDepositIncreasesBalance() {
    // ARRANGE - Setup
    BankAccount account = new BankAccount(100);
    double depositAmount = 50;
    
    // ACT - Execute
    account.deposit(depositAmount);
    
    // ASSERT - Verify
    assertEquals(150, account.getBalance());
}
```

**3. One Assertion Per Test (or Related Assertions)**
```java
// Bad - Too many things tested
@Test
void testUserOperations() {
    User user = new User("John", 30);
    assertEquals("John", user.getName());
    assertEquals(30, user.getAge());
    assertTrue(user.isActive());
    assertNotNull(user.getId());
}

// Good - Focused tests
@Test
void testUserNameIsSet() {
    User user = new User("John", 30);
    assertEquals("John", user.getName());
}

@Test
void testUserIsActiveByDefault() {
    User user = new User("John", 30);
    assertTrue(user.isActive());
}
```

**4. Use Test Fixtures Properly**
```java
public class OrderServiceTest {
    private OrderService orderService;
    private OrderRepository mockRepository;
    
    @BeforeEach
    void setUp() {
        mockRepository = mock(OrderRepository.class);
        orderService = new OrderService(mockRepository);
    }
    
    @Test
    void testCreateOrder() {
        // Test uses fresh fixtures from setUp()
    }
}
```

**5. Avoid Test Interdependence**
```java
// Bad - Tests depend on each other
@Test
void testCreateUser() {
    userId = userService.createUser("John");  // Sets static variable
}

@Test
void testUpdateUser() {
    userService.updateUser(userId, "Jane");   // Depends on testCreateUser
}

// Good - Tests are independent
@Test
void testCreateUser() {
    long userId = userService.createUser("John");
    assertNotNull(userId);
}

@Test
void testUpdateUser() {
    long userId = userService.createUser("John");  // Create fresh data
    userService.updateUser(userId, "Jane");
    User updated = userService.getUser(userId);
    assertEquals("Jane", updated.getName());
}
```

**6. Use Meaningful Test Data**
```java
// Bad
@Test
void testValidation() {
    assertEquals(1, 1);  // Meaningless
}

// Good
@Test
void testEmailValidation() {
    String validEmail = "user@example.com";
    assertTrue(emailValidator.isValid(validEmail));
    
    String invalidEmail = "notanemail";
    assertFalse(emailValidator.isValid(invalidEmail));
}
```

**7. Don't Test Private Methods**
```java
// Bad - Testing implementation details
private int calculateTax() { }

@Test
void testCalculateTax() {
    // Can't call private method
}

// Good - Test public interface
public int getTotal() {
    return amount + calculateTax();  // Private method tested indirectly
}

@Test
void testTotalIncludesTax() {
    Item item = new Item(100);  // Amount
    assertEquals(110, item.getTotal());  // Includes tax
}
```

**8. Keep Tests Focused and Fast**
```java
// Bad - Tests database, file, and API
@Test
void testCompleteProcess() {
    database.connect();
    fileSystem.read("/data.json");
    apiClient.callExternalService();
    // ... many seconds
}

// Good - Isolated with mocks
@Test
void testProcessing() {
    OrderRepository mockRepo = mock(OrderRepository.class);
    ExternalAPI mockAPI = mock(ExternalAPI.class);
    
    when(mockRepo.findOrder(1)).thenReturn(order);
    when(mockAPI.validate(order)).thenReturn(true);
    
    OrderService service = new OrderService(mockRepo, mockAPI);
    assertTrue(service.processOrder(1));  // Fast, isolated
}
```

**9. Use Parameterized Tests for Multiple Scenarios**
```java
// Bad - Repetitive
@Test
void testValidEmail1() { }

@Test
void testValidEmail2() { }

@Test
void testValidEmail3() { }

// Good - Parameterized
@ParameterizedTest
@ValueSource(strings = {"user@example.com", "admin@test.org"})
void testValidEmails(String email) {
    assertTrue(emailValidator.isValid(email));
}
```

**10. Clear Test Documentation**
```java
/**
 * Tests that order processing fails gracefully when inventory is insufficient.
 *
 * Given: Order for 100 units, but only 50 available
 * When: processOrder() is called
 * Then: Should throw InsufficientInventoryException
 */
@Test
void testInsufficientInventory() {
    // Arrange
    Order order = new Order(100);
    Inventory inventory = new Inventory(50);
    
    // Act & Assert
    assertThrows(InsufficientInventoryException.class, 
        () -> orderService.processOrder(order, inventory));
}
```

---

### Q13: What is code coverage and how do you measure it?

**Answer:**

**Code Coverage** is a metric measuring what percentage of your source code is executed during testing.

**Types of Coverage:**

```
1. Line Coverage
   └─ Percentage of code lines executed

2. Branch Coverage
   └─ Percentage of if/else branches taken

3. Path Coverage
   └─ Percentage of execution paths taken

4. Method Coverage
   └─ Percentage of methods called

5. Class Coverage
   └─ Percentage of classes tested
```

**Example:**
```java
public class PaymentProcessor {
    public boolean processPayment(double amount, String cardType) {
        // Line 1
        if (amount <= 0) {  // Branch 1
            return false;   // Line 2
        }
        
        if ("CREDIT".equals(cardType)) {  // Branch 2
            chargeCredit(amount);         // Line 3
            return true;                  // Line 4
        } else if ("DEBIT".equals(cardType)) {  // Branch 3
            chargeDebit(amount);          // Line 5
            return true;                  // Line 6
        } else {
            return false;                 // Line 7
        }
    }
}

// Coverage scenarios:
// Test 1: amount=-10, cardType="CREDIT"
// - Covers: Lines 1-2, Branch 1
// - Coverage: 28%

// Test 2: amount=100, cardType="CREDIT"
// - Covers: Lines 1-4, Branches 1-2
// - Coverage: 57%

// Test 3: amount=100, cardType="DEBIT"
// - Covers: Lines 1-6, Branches 1-3
// - Coverage: 85%

// Test 4: amount=100, cardType="INVALID"
// - Covers: All lines and branches
// - Coverage: 100%
```

**Measuring Coverage with JaCoCo (Maven):**

```xml
<!-- pom.xml -->
<dependency>
    <groupId>org.jacoco</groupId>
    <artifactId>jacoco-maven-plugin</artifactId>
    <version>0.8.8</version>
</dependency>

<!-- Add to build plugins -->
<plugin>
    <groupId>org.jacoco</groupId>
    <artifactId>jacoco-maven-plugin</artifactId>
    <version>0.8.8</version>
    <executions>
        <execution>
            <goals>
                <goal>prepare-agent</goal>
            </goals>
        </execution>
        <execution>
            <id>report</id>
            <phase>test</phase>
            <goals>
                <goal>report</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

**Run coverage analysis:**
```bash
mvn clean test jacoco:report

# Report generated at: target/site/jacoco/index.html
```

**Coverage Guidelines:**
```
95%+ : Excellent (usually unnecessary)
85-95%: Good (realistic target)
75-85%: Acceptable (aim higher)
50-75%: Poor (improve)
<50% : Very poor (major gaps)
```

**Important Coverage Principles:**
```java
// ✅ Good: Test critical paths
// High coverage + realistic targets = Quality

// ❌ Bad: Chase 100% coverage
// Diminishing returns on time investment

// ❌ Bad: Test implementation details
// Tests break on refactoring

// ✅ Good: Focus on business logic
// Coverage enables refactoring confidence
```

**Coverage is a Tool, Not a Goal:**
- 100% coverage ≠ bug-free code
- Coverage measures quantity, not quality
- Focus on meaningful tests of important code
- Ignore coverage of getters/setters/generated code

---

### Q14: How do you handle asynchronous code in tests?

**Answer:**

**Timeout Testing (JUnit 4):**
```java
@Test(timeout = 2000)  // Test must complete in 2 seconds
public void testAsynchronousOperation() throws InterruptedException {
    Thread.sleep(1000);
    assertTrue(true);
}
// If test takes longer than 2 seconds, it fails
```

**JUnit 5 assertTimeout:**
```java
@Test
void testAsyncWithTimeout() {
    assertTimeout(Duration.ofSeconds(2), () -> {
        Thread.sleep(1000);
        assertTrue(true);
    });
}

// With result
@Test
void testAsyncWithResult() {
    String result = assertTimeout(Duration.ofSeconds(2), () -> {
        Thread.sleep(500);
        return "Success";
    });
    assertEquals("Success", result);
}
```

**Testing with Callbacks (Mockito):**
```java
public interface ApiCallback {
    void onSuccess(String response);
    void onError(Exception e);
}

public class ApiClient {
    public void fetchData(ApiCallback callback) {
        new Thread(() -> {
            try {
                String response = callServer();
                callback.onSuccess(response);
            } catch (Exception e) {
                callback.onError(e);
            }
        }).start();
    }
}

@Test
void testAsyncApiCall() throws Exception {
    ApiClient client = new ApiClient();
    ApiCallback mockCallback = mock(ApiCallback.class);
    
    client.fetchData(mockCallback);
    
    // Wait for callback
    Thread.sleep(2000);
    
    verify(mockCallback).onSuccess("data");
}
```

**Testing with CompletableFuture:**
```java
public CompletableFuture<String> fetchUserAsync(int id) {
    return CompletableFuture.supplyAsync(() -> {
        // Simulate async operation
        try {
            Thread.sleep(1000);
            return "User " + id;
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    });
}

@Test
void testCompletableFuture() throws Exception {
    CompletableFuture<String> future = fetchUserAsync(1);
    
    // Method 1: Block and wait
    String result = future.get(5, TimeUnit.SECONDS);
    assertEquals("User 1", result);
    
    // Method 2: CompleteableFuture callback
    future.thenAccept(result2 -> {
        assertEquals("User 1", result2);
    });
    
    // Wait for callback
    future.get();
}
```

**Testing with Awaitility (Best Practice):**
```java
// Add dependency
// <dependency>
//     <groupId>org.awaitility</groupId>
//     <artifactId>awaitility</artifactId>
//     <version>4.1.1</version>
// </dependency>

import static org.awaitility.Awaitility.await;

@Test
void testAsyncWithAwaitility() {
    AtomicBoolean flag = new AtomicBoolean(false);
    
    new Thread(() -> {
        try {
            Thread.sleep(1000);
            flag.set(true);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }).start();
    
    // Cleaner than Thread.sleep()
    await()
        .atMost(Duration.ofSeconds(5))
        .pollInterval(Duration.ofMillis(100))
        .until(() -> flag.get());
    
    assertTrue(flag.get());
}

// Polling conditions
await()
    .atMost(2, SECONDS)
    .untilAsserted(() -> {
        assertThat(status).isEqualTo("COMPLETE");
    });
```

**Best Practices:**
- Use `CompletableFuture` or similar for async code
- Prefer Awaitility over Thread.sleep()
- Always set timeout limits
- Test both success and timeout scenarios
- Mock external async dependencies

---

### Q15: How do you organize and structure a large test suite?

**Answer:**

**Package Structure:**
```
src/
├─ main/java/
│  └─ com/example/
│     ├─ controller/
│     ├─ service/
│     ├─ repository/
│     └─ model/
└─ test/java/
   └─ com/example/
      ├─ controller/
      │  ├─ UserControllerTest.java
      │  └─ ProductControllerTest.java
      ├─ service/
      │  ├─ UserServiceTest.java
      │  └─ ProductServiceTest.java
      ├─ repository/
      │  ├─ UserRepositoryTest.java
      │  └─ ProductRepositoryTest.java
      └─ fixture/
         ├─ UserFixture.java
         └─ ProductFixture.java
```

**Test Organization with Nested Classes:**
```java
@DisplayName("UserService Tests")
class UserServiceTest {
    private UserService userService;
    private UserRepository mockRepository;
    
    @BeforeEach
    void setUp() {
        mockRepository = mock(UserRepository.class);
        userService = new UserService(mockRepository);
    }
    
    @Nested
    @DisplayName("Creating Users")
    class CreateUserTests {
        @Test
        @DisplayName("Should create user with valid data")
        void testCreateValidUser() {
            // Test
        }
        
        @Test
        @DisplayName("Should throw exception with null name")
        void testCreateWithNullName() {
            // Test
        }
    }
    
    @Nested
    @DisplayName("Finding Users")
    class FindUserTests {
        @Test
        @DisplayName("Should find user by ID")
        void testFindById() {
            // Test
        }
        
        @Test
        @DisplayName("Should return empty when user not found")
        void testUserNotFound() {
            // Test
        }
    }
    
    @Nested
    @DisplayName("Deleting Users")
    class DeleteUserTests {
        @Test
        void testDeleteUser() {
            // Test
        }
    }
}
```

**Test Categorization with Tags:**
```java
@Tag("unit")
@Tag("fast")
@Test
void testUnitLogic() { }

@Tag("integration")
@Tag("slow")
@Test
void testDatabaseInteraction() { }

// Maven execution
mvn test -Dgroups="unit"  // Only unit tests
mvn test -Dgroups="unit & fast"  // Unit and fast
```

**Base Test Classes for Reuse:**
```java
public abstract class BaseServiceTest {
    protected MockitoAnnotations mockitoAnnotations;
    
    @BeforeEach
    void setUp() {
        mockitoAnnotations = MockitoAnnotations.openMocks(this);
    }
}

@DisplayName("User Service Tests")
class UserServiceTest extends BaseServiceTest {
    @Mock
    private UserRepository userRepository;
    
    private UserService userService;
    
    @Override
    @BeforeEach
    void setUp() {
        super.setUp();
        userService = new UserService(userRepository);
    }
    
    @Test
    void test() { }
}
```

**Test Fixtures and Builders:**
```java
// UserFixture.java
public class UserFixture {
    public static User.Builder validUser() {
        return new User.Builder()
            .id(1L)
            .name("John Doe")
            .email("john@example.com")
            .active(true);
    }
    
    public static User.Builder inactiveUser() {
        return validUser().active(false);
    }
}

// Usage in tests
@Test
void testActiveUserLogin() {
    User user = UserFixture.validUser().build();
    assertTrue(authService.canLogin(user));
}

@Test
void testInactiveUserCannotLogin() {
    User user = UserFixture.inactiveUser().build();
    assertFalse(authService.canLogin(user));
}
```

**Suite Organization:**
```java
// UnitTestSuite.java
@Suite
@SelectClasses({
    UserServiceTest.class,
    ProductServiceTest.class,
    OrderServiceTest.class
})
@IncludeTags("unit")
class UnitTestSuite { }

// IntegrationTestSuite.java
@Suite
@SelectClasses({
    UserRepositoryTest.class,
    OrderRepositoryTest.class
})
@IncludeTags("integration")
class IntegrationTestSuite { }
```

**CI/CD Integration:**
```bash
# Run only fast tests
mvn test -Dgroups="fast"

# Run all except slow tests
mvn test -Dgroups="!slow"

# Coverage report
mvn test jacoco:report

# Parallel execution
mvn test -DparallelTestClasses -Dparallel=methods -DthreadCount=4
```

**Test Summary:**
- Mirror main package structure
- Use nested classes for logical grouping
- Tag tests for categorization
- Share fixtures via builders
- Organize by behavior, not test type

---

## Summary

This comprehensive guide covers JUnit testing from absolute beginner concepts through advanced enterprise patterns and real-world scenarios. Master these concepts to write effective, maintainable, and reliable tests for Java applications.



