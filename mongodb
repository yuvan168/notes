# MongoDB Complete Guide

## Table of Contents
1. [Introduction](#introduction)
2. [Why MongoDB](#why-mongodb)
3. [Core Concepts](#core-concepts)
4. [Database Operations](#database-operations)
5. [Document Structure](#document-structure)
6. [Queries](#queries)
7. [Indexing](#indexing)
8. [Aggregation](#aggregation)
9. [Transactions](#transactions)
10. [Performance Optimization](#performance-optimization)
11. [Mongoose ODM](#mongoose-odm)
12. [Best Practices](#best-practices)

---

## Introduction

MongoDB is a NoSQL (Not Only SQL) database that stores data in flexible, JSON-like documents instead of rigid tables. It's one of the most popular document databases and powers many modern web applications.

### What Makes MongoDB Different?

**Traditional SQL Database (Relational):**
```
Table: users
┌─────┬──────────┬──────────────────┐
│ id  │ name     │ email            │
├─────┼──────────┼──────────────────┤
│ 1   │ John     │ john@example.com │
│ 2   │ Jane     │ jane@example.com │
└─────┴──────────┴──────────────────┘

Fixed schema - all rows have same columns
```

**MongoDB Database (Document):**
```javascript
{
  _id: ObjectId("507f1f77bcf86cd799439011"),
  name: "John",
  email: "john@example.com",
  age: 30,
  tags: ["developer", "nodejs"]  // Can have arrays
}

{
  _id: ObjectId("507f1f77bcf86cd799439012"),
  name: "Jane",
  email: "jane@example.com",
  verified: true,
  metadata: {                      // Can have nested objects
    lastLogin: "2025-01-15",
    preferences: { theme: "dark" }
  }
}

Flexible schema - documents can have different fields
```

### Key Characteristics

- **Document-Oriented** - Data stored as JSON-like documents
- **Flexible Schema** - No predefined structure
- **Scalability** - Horizontal scaling through sharding
- **Indexing** - Fast queries with proper indexes
- **Replication** - Data redundancy and high availability

---

## Why MongoDB

### Problem with SQL Databases (Relational Model)

**Scenario:** Storing user with multiple addresses

```sql
-- SQL Approach - Requires multiple tables and joins
Table: users
┌─────┬──────┐
│ id  │ name │
├─────┼──────┤
│ 1   │ John │
└─────┴──────┘

Table: addresses
┌────┬─────────┬──────────────┬─────────┐
│ id │ user_id │ street       │ city    │
├────┼─────────┼──────────────┼─────────┤
│ 1  │ 1       │ 123 Main St  │ NYC     │
│ 2  │ 1       │ 456 Oak Ave  │ LA      │
└────┴─────────┴──────────────┴─────────┘

-- Need to JOIN tables to get complete user data
SELECT users.*, addresses.* 
FROM users 
JOIN addresses ON users.id = addresses.user_id 
WHERE users.id = 1;
```

**Problems:**
- Schema must be defined upfront
- Adding fields requires ALTER TABLE
- JOINs are complex and slow for large datasets
- Schema changes are risky in production

### Solution with MongoDB

```javascript
// MongoDB Approach - Single document
db.users.findOne({ _id: 1 })
// Returns:
{
  _id: 1,
  name: "John",
  addresses: [
    { street: "123 Main St", city: "NYC" },
    { street: "456 Oak Ave", city: "LA" }
  ]
}

// No JOINs needed - all data in one document
```

**Advantages:**
- Schema evolves with application
- No migrations needed
- No JOINs required
- Nested data is natural
- Faster for denormalized data

### When to Use MongoDB

✅ **Perfect for:**
- Mobile apps (flexible data)
- Content management systems (varied content types)
- Real-time analytics
- Big data applications
- Rapid prototyping

❌ **Not ideal for:**
- Complex transactions across many tables
- Highly normalized data
- Applications needing strict ACID guarantees
- Heavy reporting/analytics (use data warehouse)

---

## Core Concepts

### 1. Database

A MongoDB database is a container for collections.

```javascript
// Create/use database
use myapp_db

// List databases
show dbs

// Delete database
db.dropDatabase()
```

**Theory:** MongoDB automatically creates databases when you first write data to them. No explicit creation needed.

### 2. Collection

A collection is a group of documents (like a table in SQL).

```javascript
// Create collection
db.createCollection('users')

// List collections
show collections

// Drop collection
db.users.drop()
```

**Theory:** Collections are schemaless - documents in the same collection can have different fields. MongoDB creates collections automatically on first insert.

### 3. Document

A document is a single record in BSON format (Binary JSON).

```javascript
{
  _id: ObjectId("507f1f77bcf86cd799439011"),
  name: "John Doe",
  email: "john@example.com",
  age: 30,
  active: true,
  tags: ["developer", "nodejs"],
  address: {
    street: "123 Main St",
    city: "New York",
    zip: "10001"
  },
  createdAt: ISODate("2025-01-15T10:30:00Z")
}
```

**BSON (Binary JSON):**
```
JSON:  String stored as text
BSON:  Binary serialized format (more efficient for storage/transfer)

BSON supports additional types:
- ObjectId (unique identifier)
- Date (ISODate)
- Binary Data
- Regular Expressions
- Code
- Timestamps
```

### 4. ObjectId

MongoDB's unique identifier for every document.

```javascript
// ObjectId structure (12 bytes)
ObjectId("507f1f77bcf86cd799439011")
  └─ 507f1f77  - Timestamp (creation time)
  └─ bcf86c    - Machine identifier
  └─ d7        - Process ID
  └─ 9439011   - Counter (increments)

// ObjectId features:
- Unique across the system
- Sortable (contains timestamp)
- Generated client-side or server-side
- 12 bytes = 24 hex characters
```

**Why ObjectId instead of auto-increment?**
- Distributed systems can't share counters
- ObjectId embeds timestamp info
- Can be generated without database call

### 5. Field Types

```javascript
{
  // String
  name: "John",
  
  // Number
  age: 30,                    // Integer
  price: 19.99,              // Float
  
  // Boolean
  isActive: true,
  
  // Date
  createdAt: new Date(),
  
  // Array
  tags: ["node", "mongodb", "javascript"],
  
  // Object (nested document)
  address: {
    street: "123 Main St",
    city: "NYC"
  },
  
  // Null
  middleName: null,
  
  // ObjectId
  userId: ObjectId("507f1f77bcf86cd799439011"),
  
  // Binary data
  profileImage: BinData(0, "..."),
  
  // Regular expression
  pattern: /^john/i,
  
  // Code
  script: Code("function() { return 42; }")
}
```

### 6. Collections as Schemas

While MongoDB is schemaless, you can define a schema using Mongoose (a Node.js ODM).

```javascript
// MongoDB - no schema
db.users.insertOne({ name: "John" })  // Works fine

// With Mongoose - enforced schema
const userSchema = new Schema({
  name: {
    type: String,
    required: true
  },
  age: {
    type: Number,
    min: 0,
    max: 150
  }
})
```

**Theory:** MongoDB gives you flexibility, but using schemas (via Mongoose) is best practice for:
- Data consistency
- Type validation
- Documentation
- Error catching

---

## Database Operations

### CRUD Operations (Create, Read, Update, Delete)

#### CREATE - Insert Documents

```javascript
// Insert single document
db.users.insertOne({
  name: "John",
  email: "john@example.com",
  age: 30
})

// Insert multiple documents
db.users.insertMany([
  { name: "John", email: "john@example.com" },
  { name: "Jane", email: "jane@example.com" },
  { name: "Bob", email: "bob@example.com" }
])

// Returns: { "acknowledged": true, "insertedIds": [...] }
```

**Theory:**
- Documents are written immediately to disk (by default)
- Each document gets an `_id` if not provided
- Insert returns inserted IDs for reference

#### READ - Query Documents

```javascript
// Find all
db.users.find()

// Find one
db.users.findOne({ name: "John" })

// Find with conditions
db.users.find({ age: { $gt: 25 } })  // age > 25

// Project specific fields
db.users.find({}, { name: 1, email: 1 })  // Only show name and email

// Returns: cursor (iterable list of documents)
```

**Theory:**
- `find()` returns a cursor (doesn't load all data)
- You can chain operations: `find().sort().limit().skip()`
- `findOne()` returns single document or null

#### UPDATE - Modify Documents

```javascript
// Update one document
db.users.updateOne(
  { name: "John" },                    // Filter
  { $set: { age: 31 } }               // Update
)

// Update multiple documents
db.users.updateMany(
  { status: "inactive" },
  { $set: { active: false } }
)

// Replace entire document (rarely used)
db.users.replaceOne(
  { _id: ObjectId("...") },
  { name: "Jane", email: "jane@example.com" }
)

// Returns: { "matchedCount": 1, "modifiedCount": 1 }
```

**Update Operators:**
```javascript
{ $set: { field: value } }           // Set field value
{ $unset: { field: "" } }            // Remove field
{ $inc: { counter: 1 } }             // Increment by value
{ $push: { tags: "new-tag" } }       // Add to array
{ $pull: { tags: "old-tag" } }       // Remove from array
{ $addToSet: { tags: "tag" } }       // Add if not exists
{ $rename: { oldField: "newField" } } // Rename field
```

**Theory:**
- Always use update operators (`$set`, `$inc`, etc.)
- Directly assigning values can delete other fields
- Atomic operations - safe for concurrent updates

#### DELETE - Remove Documents

```javascript
// Delete one document
db.users.deleteOne({ name: "John" })

// Delete multiple documents
db.users.deleteMany({ status: "inactive" })

// Delete all (be careful!)
db.users.deleteMany({})

// Returns: { "deletedCount": 1 }
```

**Theory:**
- Deletion is permanent
- No soft delete by default (design your own if needed)
- deleteMany({}) deletes all documents in collection

---

## Document Structure

### Denormalization vs Normalization

**SQL Normalization (Normalized):**
```javascript
// Separate tables
Table: users
{ id: 1, name: "John" }

Table: orders
{ id: 101, userId: 1, total: 99.99 }

// Must JOIN to get user + orders
```

**MongoDB Denormalization (Denormalized):**
```javascript
// Everything in one document
{
  _id: 1,
  name: "John",
  orders: [
    { id: 101, total: 99.99, date: "2025-01-15" },
    { id: 102, total: 149.99, date: "2025-01-16" }
  ]
}

// No JOIN - faster read, duplicates data
```

**Tradeoff:**
```
Normalized:
  ✓ No data duplication
  ✓ Easier updates (change once, affects all)
  ✗ Requires JOINs (slower)
  ✗ More complex queries

Denormalized:
  ✓ Faster reads (no JOINs)
  ✓ Simpler queries
  ✗ Data duplication
  ✗ Harder updates
```

**When to use each:**
- **Denormalized** - Read-heavy apps, related data changes rarely
- **Normalized** - Write-heavy apps, frequent updates

### Embedding vs Referencing

#### 1. Embedding (One-to-One or One-to-Few)

```javascript
// Store address directly in user
db.users.insertOne({
  _id: 1,
  name: "John",
  address: {                  // Embedded
    street: "123 Main St",
    city: "NYC",
    zip: "10001"
  }
})

// Query embedded data
db.users.find({ "address.city": "NYC" })
```

**Use when:**
- Related data is accessed together
- Few related items (not 100s)
- Related data rarely updates independently

#### 2. Referencing (One-to-Many or Many-to-Many)

```javascript
// Store reference to address
db.users.insertOne({
  _id: 1,
  name: "John",
  addressIds: [ObjectId("..."), ObjectId("...")]  // References
})

db.addresses.insertOne({
  _id: ObjectId("..."),
  userId: 1,
  street: "123 Main St",
  city: "NYC"
})

// Query requires lookup
db.users.aggregate([
  { $match: { _id: 1 } },
  { $lookup: {
      from: "addresses",
      localField: "_id",
      foreignField: "userId",
      as: "addresses"
    }
  }
])
```

**Use when:**
- Many related items (100s or 1000s)
- Related data updates frequently
- Data is shared (many-to-many)

### Array Operations

```javascript
// Add element to array
db.users.updateOne(
  { _id: 1 },
  { $push: { tags: "new-tag" } }
)

// Add multiple elements
db.users.updateOne(
  { _id: 1 },
  { $push: { tags: { $each: ["tag1", "tag2"] } } }
)

// Remove element from array
db.users.updateOne(
  { _id: 1 },
  { $pull: { tags: "old-tag" } }
)

// Remove by index
db.users.updateOne(
  { _id: 1 },
  { $unset: { "tags.0": 1 } }  // Delete element 0
)

// Query array elements
db.users.find({ tags: "nodejs" })           // Has tag
db.users.find({ tags: { $all: ["a", "b"] } })  // Has both tags
db.users.find({ tags: { $size: 3 } })      // Array has 3 elements
```

---

## Queries

### Query Operators

```javascript
// Comparison
{ age: { $eq: 30 } }          // Equal
{ age: { $ne: 30 } }          // Not equal
{ age: { $gt: 25 } }          // Greater than
{ age: { $gte: 25 } }         // Greater than or equal
{ age: { $lt: 35 } }          // Less than
{ age: { $lte: 35 } }         // Less than or equal
{ age: { $in: [25, 30, 35] } } // In array
{ age: { $nin: [25, 30] } }   // Not in array

// Logical
{ $and: [{ age: 25 }, { name: "John" }] }
{ $or: [{ age: 25 }, { age: 30 }] }
{ $nor: [{ age: 25 }, { age: 30 }] }
{ $not: { age: { $gt: 25 } } }

// Element
{ email: { $exists: true } }   // Field exists
{ email: { $type: "string" } } // Field is string type

// Regex
{ name: { $regex: "^john", $options: "i" } }  // Case-insensitive regex

// Text search
db.users.find({ $text: { $search: "john doe" } })

// Array
{ tags: { $size: 3 } }         // Array has 3 elements
{ tags: { $all: ["a", "b"] } } // Has both elements
{ hobbies: { $elemMatch: { name: "reading", years: 5 } } }
```

### Query Examples

```javascript
// Find users older than 25
db.users.find({ age: { $gt: 25 } })

// Find users from NYC or LA
db.users.find({
  $or: [
    { city: "NYC" },
    { city: "LA" }
  ]
})

// Find users named John OR older than 30
db.users.find({
  $or: [
    { name: "John" },
    { age: { $gt: 30 } }
  ]
})

// Find with AND (multiple conditions)
db.users.find({
  age: { $gt: 25 },
  status: "active",
  "address.city": "NYC"
})

// Complex nested query
db.users.find({
  $and: [
    { age: { $gte: 25, $lte: 35 } },
    { tags: { $in: ["developer", "designer"] } },
    { verified: true }
  ]
})
```

### Sorting, Limiting, Skipping

```javascript
// Sort ascending (1) or descending (-1)
db.users.find().sort({ age: 1 })         // Youngest first
db.users.find().sort({ age: -1 })        // Oldest first
db.users.find().sort({ age: -1, name: 1 }) // Multiple sorts

// Limit results
db.users.find().limit(10)                // First 10 documents

// Skip documents (for pagination)
db.users.find().skip(20).limit(10)       // Documents 21-30

// Common pagination pattern
let page = 2;
let pageSize = 10;
db.users.find()
  .sort({ _id: -1 })
  .skip((page - 1) * pageSize)
  .limit(pageSize)
```

**Theory:** 
- Sorting without index is slow (O(n log n))
- Skip is inefficient for large offsets (scans all skipped docs)
- Recommendation: Use indexed fields for sort

---

## Indexing

### What is an Index?

An index is a data structure that speeds up queries by storing a sorted copy of selected fields.

```javascript
// Without index
db.users.find({ email: "john@example.com" })
// Scans ALL 1 million documents (full collection scan)
// O(n) - Linear time

// With index
db.users.createIndex({ email: 1 })
db.users.find({ email: "john@example.com" })
// Uses index to find matching document instantly
// O(log n) - Logarithmic time
// 1000x faster!
```

**Index Structure (B-Tree):**
```
Index on email field:
                 [m-p]
              /        \
         [a-l]          [r-z]
        /      \        /     \
    [a-c]  [d-l]  [r-s]  [t-z]
    
# Searching for "john@example.com"
# Start at root, traverse left/right
# Find in ~7 steps instead of 1,000,000
```

### Types of Indexes

#### 1. Single Field Index
```javascript
// Index on one field
db.users.createIndex({ email: 1 })

// Find queries benefit
db.users.find({ email: "john@example.com" })
```

#### 2. Compound Index
```javascript
// Index on multiple fields
db.users.createIndex({ status: 1, age: -1 })

// Helps queries using both fields
db.users.find({ status: "active", age: { $gt: 25 } })

// Also helps with prefix
db.users.find({ status: "active" })

// But NOT with just age (index not used)
db.users.find({ age: { $gt: 25 } })
```

**Index Order Matters:**
```javascript
// Create index: status ascending, age descending
db.users.createIndex({ status: 1, age: -1 })

// Query order doesn't matter
db.users.find({ age: { $gt: 25 }, status: "active" })  // Uses index

// But field order in index matters for queries
db.users.find({ age: { $gt: 25 } })  // Doesn't use this index
// Solution: Need separate index on age or make it first
```

#### 3. Text Index
```javascript
// Full-text search index
db.articles.createIndex({ title: "text", content: "text" })

// Query with text search
db.articles.find({ $text: { $search: "mongodb tutorial" } })
```

#### 4. Unique Index
```javascript
// Enforce unique values
db.users.createIndex({ email: 1 }, { unique: true })

// Prevents duplicate emails
db.users.insertOne({ email: "john@example.com" })  // OK
db.users.insertOne({ email: "john@example.com" })  // Error!
```

#### 5. Sparse Index
```javascript
// Only index documents where field exists
db.users.createIndex({ phone: 1 }, { sparse: true })

// Documents without phone field are not indexed
// Useful for optional fields
```

### Index Management

```javascript
// List indexes
db.users.getIndexes()

// Get index stats
db.users.aggregate([{ $indexStats: {} }])

// Drop index
db.users.dropIndex({ email: 1 })

// Drop all indexes (except _id)
db.users.dropIndexes()

// Background index creation (doesn't block writes)
db.users.createIndex({ email: 1 }, { background: true })
```

### Index Best Practices

```javascript
// ✓ Good - Index frequently searched fields
db.users.createIndex({ email: 1 })
db.users.createIndex({ userId: 1, createdAt: -1 })

// ❌ Bad - Index every field
// Uses too much memory
// Slows down writes (must update all indexes)

// ✓ Good - Analyze slow queries
db.setProfilingLevel(1, { slowms: 100 })  // Log queries > 100ms

// ❌ Bad - Index without understanding queries
// Wastes resources
```

---

## Aggregation

### What is Aggregation?

Aggregation is a framework for processing documents through multiple stages to transform and analyze data. Like SQL GROUP BY on steroids.

```javascript
// SQL vs MongoDB

-- SQL
SELECT status, COUNT(*) as count, AVG(age) as avgAge
FROM users
GROUP BY status
HAVING COUNT(*) > 5
ORDER BY count DESC

// MongoDB
db.users.aggregate([
  { $match: { age: { $gt: 18 } } },
  { $group: { 
      _id: "$status",
      count: { $sum: 1 },
      avgAge: { $avg: "$age" }
    }
  },
  { $match: { count: { $gt: 5 } } },
  { $sort: { count: -1 } }
])
```

### Aggregation Pipeline Stages

#### 1. $match - Filter documents
```javascript
db.users.aggregate([
  { $match: { age: { $gt: 25 }, status: "active" } }
])
// Keep only documents matching criteria
// Most efficient - put early to reduce documents
```

#### 2. $project - Select/rename fields
```javascript
db.users.aggregate([
  { $project: {
      name: 1,                    // Include field
      email: 1,
      age: 1,
      _id: 0,                     // Exclude _id
      fullName: { $toUpper: "$name" }  // Transform field
    }
  }
])
// Output: { name, email, age, fullName }
```

#### 3. $group - Group and aggregate
```javascript
db.users.aggregate([
  { $group: {
      _id: "$status",            // Group by status field
      count: { $sum: 1 },        // Count documents
      avgAge: { $avg: "$age" },  // Average age
      emails: { $push: "$email" }, // Array of emails
      maxAge: { $max: "$age" }
    }
  }
])
// Groups documents, calculates aggregations per group
```

**Aggregation Functions:**
```javascript
{ $sum: 1 }                    // Count
{ $sum: "$price" }             // Sum field value
{ $avg: "$age" }               // Average
{ $min: "$date" }              // Minimum
{ $max: "$date" }              // Maximum
{ $first: "$name" }            // First value
{ $last: "$name" }             // Last value
{ $push: "$email" }            // Array of values
{ $addToSet: "$category" }     // Unique values
{ $stdDevPop: "$age" }         // Standard deviation
```

#### 4. $sort - Order documents
```javascript
db.users.aggregate([
  { $sort: { age: -1 } }  // Newest/oldest first
])
```

#### 5. $limit and $skip - Pagination
```javascript
db.users.aggregate([
  { $skip: 20 },
  { $limit: 10 }
])
```

#### 6. $lookup - Join collections
```javascript
db.users.aggregate([
  { $lookup: {
      from: "orders",           // Join with orders
      localField: "_id",        // User._id
      foreignField: "userId",   // Order.userId
      as: "orders"              // Result field name
    }
  }
])
// Similar to SQL LEFT JOIN
```

#### 7. $unwind - Explode arrays
```javascript
db.users.aggregate([
  { $unwind: "$tags" }  // One document per tag
])

// Before: { _id: 1, tags: ["a", "b", "c"] }
// After:
// { _id: 1, tags: "a" }
// { _id: 1, tags: "b" }
// { _id: 1, tags: "c" }
```

#### 8. $facet - Multiple aggregations
```javascript
db.products.aggregate([
  { $facet: {
      byCategory: [
        { $group: { _id: "$category", count: { $sum: 1 } } }
      ],
      byPrice: [
        { $bucket: { groupBy: "$price", boundaries: [0, 50, 100, 500] } }
      ]
    }
  }
])
// Get multiple aggregations in one query
```

### Aggregation Examples

```javascript
// 1. Total sales per month
db.orders.aggregate([
  { $group: {
      _id: { $dateToString: { format: "%Y-%m", date: "$orderDate" } },
      totalRevenue: { $sum: "$amount" },
      orderCount: { $sum: 1 }
    }
  },
  { $sort: { _id: 1 } }
])

// 2. Top 5 customers by total spent
db.orders.aggregate([
  { $group: {
      _id: "$customerId",
      totalSpent: { $sum: "$amount" },
      orderCount: { $sum: 1 }
    }
  },
  { $sort: { totalSpent: -1 } },
  { $limit: 5 },
  { $lookup: {
      from: "customers",
      localField: "_id",
      foreignField: "_id",
      as: "customer"
    }
  }
])

// 3. Average rating per product
db.reviews.aggregate([
  { $group: {
      _id: "$productId",
      avgRating: { $avg: "$rating" },
      reviewCount: { $sum: 1 }
    }
  },
  { $match: { reviewCount: { $gte: 10 } } },
  { $sort: { avgRating: -1 } }
])
```

---

## Transactions

### What are Transactions?

Transactions ensure multiple operations succeed or all fail together (ACID properties).

```javascript
// Without transaction
db.users.updateOne({ _id: 1 }, { $inc: { balance: -100 } })
// User's money deducted
db.orders.insertOne({ userId: 1, amount: 100 })
// Order created
// What if insertOne fails? User loses $100!

// With transaction
session = db.getMongo().startSession()
session.startTransaction()
try {
  db.users.updateOne({ _id: 1 }, { $inc: { balance: -100 } }, { session })
  db.orders.insertOne({ userId: 1, amount: 100 }, { session })
  session.commitTransaction()
  // Both succeed or both roll back
} catch (error) {
  session.abortTransaction()
  // Everything reverted
}
```

**Theory:**
- MongoDB 4.0+ supports multi-document transactions
- Transactions can span multiple documents or collections
- Slightly slower (safety cost)
- Use only when necessary

### ACID Properties

```
Atomicity:     All operations succeed or all fail
               (no partial success)

Consistency:   Database moves from valid state to valid state
               (rules enforced)

Isolation:     Transactions don't interfere with each other
               (can't read partial changes)

Durability:    Committed data survives failures
               (written to disk)
```

---

## Performance Optimization

### 1. Indexes

```javascript
// Always index frequently queried fields
db.users.createIndex({ email: 1 })
db.users.createIndex({ status: 1, createdAt: -1 })

// Explain plan shows index usage
db.users.find({ email: "john@example.com" }).explain("executionStats")
// Look for "COLLSCAN" (bad - no index) vs "IXSCAN" (good - used index)
```

### 2. Query Optimization

```javascript
// ✓ Good - Use projection
db.users.find({ status: "active" }, { name: 1, email: 1 })
// Only fetches needed fields

// ❌ Bad - Fetch all fields
db.users.find({ status: "active" })

// ✓ Good - Match early in aggregation
db.users.aggregate([
  { $match: { status: "active" } },  // Filter first
  { $group: { _id: "$city", count: { $sum: 1 } } }
])

// ❌ Bad - Group first, then filter
db.users.aggregate([
  { $group: { _id: "$city", count: { $sum: 1 } } },
  { $match: { count: { $gt: 100 } } }  // Filters groups created
])
```

### 3. Denormalization for Reads

```javascript
// ✓ Good - Denormalize for read-heavy operations
db.posts.insertOne({
  _id: 1,
  title: "MongoDB Tips",
  authorId: ObjectId("..."),
  authorName: "John",        // Denormalized (duplicate)
  authorEmail: "john@example.com"  // Denormalized (duplicate)
})
// Single document fetch, no JOINs

// Update is slightly harder (update author in all posts)
// But reads are much faster
```

### 4. Batch Operations

```javascript
// ✓ Good - Batch multiple writes
db.users.insertMany([
  { name: "John", ... },
  { name: "Jane", ... },
  { name: "Bob", ... }
])  // Single round trip

// ❌ Bad - Multiple separate writes
db.users.insertOne({ name: "John", ... })
db.users.insertOne({ name: "Jane", ... })
db.users.insertOne({ name: "Bob", ... })  // Three round trips
```

### 5. Connection Pooling

```javascript
// In Node.js (Mongoose)
const mongoose = require('mongoose');
mongoose.connect('mongodb://localhost:27017/db', {
  maxPoolSize: 10,        // Connection pool size
  minPoolSize: 5
})
// Reuse connections instead of creating new ones
```

### 6. Profiling Slow Queries

```javascript
// Enable profiling
db.setProfilingLevel(1, { slowms: 100 })
// Log queries taking > 100ms

// View slow query log
db.system.profile.find({ millis: { $gt: 100 } }).pretty()

// Analyze query plan
db.users.find({ email: "..." }).explain("executionStats")
// Check executionStages.stage:
// - "COLLSCAN" = full collection scan (bad)
// - "IXSCAN" = index scan (good)
```

---

## Mongoose ODM

Mongoose is an Object Data Mapper (ODM) for MongoDB in Node.js. It adds schema validation and methods.

### Schema Definition

```javascript
const mongoose = require('mongoose');
const { Schema } = mongoose;

const userSchema = new Schema({
  // Basic field definition
  name: String,
  email: String,
  
  // With validation
  name: {
    type: String,
    required: [true, "Name is required"],
    minlength: 3,
    maxlength: 50,
    trim: true
  },
  
  email: {
    type: String,
    required: true,
    unique: true,
    match: /.+\@.+\..+/
  },
  
  age: {
    type: Number,
    min: 0,
    max: 150
  },
  
  // Nested object
  address: {
    street: String,
    city: String,
    zip: String
  },
  
  // Array
  tags: [String],
  
  // Array of objects
  hobbies: [{
    name: String,
    years: Number
  }],
  
  // Enum
  status: {
    type: String,
    enum: ['active', 'inactive', 'pending'],
    default: 'pending'
  },
  
  // Date
  createdAt: {
    type: Date,
    default: Date.now
  },
  
  // Reference to another collection
  companyId: {
    type: Schema.Types.ObjectId,
    ref: 'Company'
  }
})

const User = mongoose.model('User', userSchema)
```

### CRUD Operations

```javascript
// CREATE
const user = new User({ name: "John", email: "john@example.com" })
await user.save()

// Or
await User.create({ name: "Jane", email: "jane@example.com" })

// READ
const user = await User.findById(userId)
const users = await User.find({ status: "active" })
const user = await User.findOne({ email: "john@example.com" })

// UPDATE
await User.updateOne({ _id: userId }, { $set: { age: 30 } })
const user = await User.findByIdAndUpdate(
  userId,
  { age: 30 },
  { new: true }  // Return updated document
)

// DELETE
await User.deleteOne({ _id: userId })
await User.deleteMany({ status: "inactive" })
```

### Methods and Hooks

```javascript
// Instance methods
userSchema.methods.getFullName = function() {
  return `${this.firstName} ${this.lastName}`
}
user.getFullName()

// Static methods
userSchema.statics.findByEmail = function(email) {
  return this.findOne({ email })
}
User.findByEmail("john@example.com")

// Hooks (middleware)
userSchema.pre('save', async function(next) {
  // Hash password before saving
  if (this.isModified('password')) {
    this.password = await bcrypt.hash(this.password, 10)
  }
  next()
})

userSchema.post('save', function(doc) {
  console.log(`User ${doc._id} saved`)
})
```

### Population (Joins)

```javascript
// Define reference in schema
const postSchema = new Schema({
  title: String,
  userId: {
    type: Schema.Types.ObjectId,
    ref: 'User'  // Reference to User model
  }
})

// Query without population
const post = await Post.findById(postId)
// post.userId = ObjectId("...")

// Query with population (fetch referenced data)
const post = await Post.findById(postId).populate('userId')
// post.userId = { _id: "...", name: "John", email: "..." }

// Nested population
const post = await Post.findById(postId)
  .populate({
    path: 'userId',
    populate: { path: 'companyId' }  // Populate user's company too
  })
```

---

## Best Practices

### 1. Design Schema Carefully

```javascript
// ✓ Good - Consider queries when designing
const userSchema = new Schema({
  name: String,
  email: String,
  status: String,
  companyId: { type: Schema.Types.ObjectId, ref: 'Company' }
})

// If you frequently query users by company, consider denormalizing:
const userSchema = new Schema({
  name: String,
  email: String,
  status: String,
  companyId: { type: Schema.Types.ObjectId, ref: 'Company' },
  companyName: String  // Denormalized for speed
})
```

### 2. Use Proper Indexing

```javascript
// Index frequently searched fields
userSchema.index({ email: 1 }, { unique: true })
userSchema.index({ status: 1, createdAt: -1 })
userSchema.index({ companyId: 1 })
```

### 3. Validate Data

```javascript
// ✓ Good - Use schema validation
const userSchema = new Schema({
  email: {
    type: String,
    required: true,
    unique: true,
    match: /.+\@.+\..+/
  },
  age: {
    type: Number,
    min: 0,
    max: 150
  }
})

// ❌ Bad - No validation
const userSchema = new Schema({
  email: String,
  age: Number
})
// Accepts invalid data
```

### 4. Use Transactions for Multi-Document Operations

```javascript
// ✓ Good - Transfer money safely
const session = await mongoose.startSession()
session.startTransaction()
try {
  await User.updateOne({ _id: fromId }, { $inc: { balance: -100 } }, { session })
  await User.updateOne({ _id: toId }, { $inc: { balance: 100 } }, { session })
  await session.commitTransaction()
} catch (error) {
  await session.abortTransaction()
}
```

### 5. Handle Errors Properly

```javascript
// ✓ Good - Handle validation errors
try {
  const user = new User({ name: "", email: "invalid" })
  await user.save()
} catch (error) {
  if (error.name === 'ValidationError') {
    console.log('Validation failed:', error.message)
  } else if (error.code === 11000) {
    console.log('Duplicate key error (unique violation)')
  }
}
```

### 6. Monitor Performance

```javascript
// Enable MongoDB profiling
mongoose.connection.on('open', () => {
  mongoose.connection.db.setProfilingLevel(1, { slowms: 100 })
})

// Check explain plan
const explainResult = await User.find({ email: "..." }).explain("executionStats")
console.log(explainResult.executionStats)
```

### 7. Use Lean Queries for Read-Only

```javascript
// ✓ Good - Lean returns plain objects (faster)
const users = await User.find({ status: "active" }).lean()
// Can't call user.save() but faster

// Regular query returns Mongoose documents
const users = await User.find({ status: "active" })
// Can call user.save() but slightly slower
```

### 8. Limit Query Results

```javascript
// ✓ Good - Don't fetch all data
const users = await User.find({ status: "active" })
  .select('name email')      // Only needed fields
  .limit(50)                 // Limit results
  .lean()                    // Lean query
  .exec()

// ❌ Bad - Fetch everything
const users = await User.find()  // All documents, all fields!
```

---

## Common Patterns

### Pagination

```javascript
async function getUsers(page = 1, pageSize = 20) {
  const skip = (page - 1) * pageSize
  
  const users = await User.find()
    .skip(skip)
    .limit(pageSize)
    .lean()
  
  const total = await User.countDocuments()
  const totalPages = Math.ceil(total / pageSize)
  
  return {
    data: users,
    pagination: {
      current: page,
      pageSize,
      total,
      totalPages
    }
  }
}
```

### Full-Text Search

```javascript
// Create text index
userSchema.index({ name: 'text', email: 'text' })

// Search
const results = await User.find(
  { $text: { $search: "john doe" } },
  { score: { $meta: "textScore" } }
).sort({ score: { $meta: "textScore" } })
```

### Auto-Increment Field

```javascript
const counterSchema = new Schema({
  _id: String,
  seq: Number
})

// Update sequence
async function getNextSequence(name) {
  const counter = await Counter.findByIdAndUpdate(
    name,
    { $inc: { seq: 1 } },
    { new: true, upsert: true }
  )
  return counter.seq
}

// Use in schema
const userSchema = new Schema({
  userId: Number,
  // ... other fields
})

userSchema.pre('save', async function(next) {
  if (!this.userId) {
    this.userId = await getNextSequence('user')
  }
  next()
})
```

### Soft Delete

```javascript
const userSchema = new Schema({
  // ... fields
  deleted: {
    type: Boolean,
    default: false
  }
})

// Query only non-deleted
userSchema.query.active = function() {
  return this.find({ deleted: false })
}

// Usage
const users = await User.find().active()

// Soft delete
await User.updateOne({ _id: userId }, { deleted: true })
```

---

## Useful Resources

- [Official MongoDB Documentation](https://docs.mongodb.com/)
- [Mongoose ODM Documentation](https://mongoosejs.com/)
- [MongoDB Best Practices](https://docs.mongodb.com/manual/administration/analyzing-mongodb-performance/)
- [MongoDB Query Performance](https://docs.mongodb.com/manual/tutorial/analyze-query-performance/)
- [MongoDB University - Free Courses](https://university.mongodb.com/)

