# PL/SQL Comprehensive Notes

## Table of Contents
1. [Introduction to PL/SQL](#introduction)
2. [Basic Structure](#basic-structure)
3. [Variables and Data Types](#variables-and-data-types)
4. [Control Structures](#control-structures)
5. [Cursors](#cursors)
6. [Exception Handling](#exception-handling)
7. [Procedures](#procedures)
8. [Functions](#functions)
9. [Packages](#packages)
10. [Triggers](#triggers)
11. [Collections](#collections)
12. [Advanced Topics](#advanced-topics)
13. [Interview Questions & Answers](#interview-questions)

---

## Introduction to PL/SQL {#introduction}

**PL/SQL** (Procedural Language/Structured Query Language) is Oracle's procedural extension to SQL. It combines the data manipulation power of SQL with the processing power of procedural languages.

### What is PL/SQL?

PL/SQL is a **block-structured language** that enables developers to combine SQL's data manipulation capabilities with procedural programming constructs like loops, conditions, and exception handling. It was developed by Oracle Corporation in the late 1980s.

### Why PL/SQL?

**SQL Limitations:**
- SQL is a non-procedural language (declarative)
- No support for loops, conditional logic, or error handling
- Cannot create reusable code modules
- Each SQL statement executes individually (network overhead)

**PL/SQL Solutions:**
- Adds procedural constructs (IF-THEN-ELSE, LOOPS, etc.)
- Built-in exception handling mechanism
- Supports modular programming (procedures, functions, packages)
- Reduces network traffic by bundling SQL statements
- Improved performance through server-side execution

### Key Features:

1. **Block Structure**: Code organized into logical blocks for better organization and maintenance
2. **Error Handling**: Robust exception handling mechanism for graceful error management
3. **Performance**: Reduces network traffic by sending entire blocks to the database in one call
4. **Portability**: Can run on any Oracle database without modification
5. **Integration**: Seamlessly integrates with SQL - can use SQL statements anywhere
6. **Modularity**: Supports procedures, functions, packages for code reusability
7. **Security**: Fine-grained access control and privilege management
8. **Maintainability**: Easy to maintain and debug complex business logic

### Architecture:

```
┌─────────────────────────────────────┐
│     Client Application              │
│  (SQL*Plus, Application, etc.)      │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│        PL/SQL Engine                │
│  ┌─────────────────────────────┐   │
│  │  Procedural Statement       │   │
│  │  Executor                   │   │
│  └──────────┬──────────────────┘   │
│             │                       │
│  ┌──────────▼──────────────────┐   │
│  │  SQL Statement Executor     │   │
│  │  (sends to SQL Engine)      │   │
│  └─────────────────────────────┘   │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│        SQL Engine                   │
│  (Parses and Executes SQL)          │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│          Database                   │
└─────────────────────────────────────┘
```

### How PL/SQL Works:

1. **Client** sends PL/SQL block to database
2. **PL/SQL Engine** separates procedural and SQL statements
3. **Procedural statements** are processed by PL/SQL engine
4. **SQL statements** are sent to SQL engine for execution
5. Results are returned to PL/SQL engine
6. Final output is sent back to client

### Advantages:

✓ **Tight Integration with SQL**: Use SQL directly without API calls
✓ **Better Performance**: Reduced network traffic, optimized execution
✓ **High Productivity**: Write less code, achieve more functionality
✓ **Full Portability**: Works across all Oracle platforms
✓ **Tight Security**: Execute with definer's or invoker's rights
✓ **Support for Object-Oriented Programming**: Object types, inheritance
✓ **Support for Web Applications**: Can generate HTML, interact with web services

---

## Basic Structure {#basic-structure}

### Theory: Block Structure

PL/SQL is a **block-structured language**. The basic unit in PL/SQL is a **block**. All PL/SQL programs are made up of blocks, which can be nested within one another.

### Types of PL/SQL Blocks:

1. **Anonymous Blocks**: Unnamed blocks that are not stored in the database
2. **Named Blocks**: Procedures, functions, packages (stored in database)
3. **Trigger Blocks**: Special blocks that execute automatically on events

### Anonymous Block Structure

```sql
DECLARE
    -- Declaration section (OPTIONAL)
    -- Variables, constants, cursors, user-defined exceptions
    -- This section is used to declare all identifiers used in the block
BEGIN
    -- Execution section (MANDATORY)
    -- SQL statements and PL/SQL statements
    -- This is where the actual logic is written
EXCEPTION
    -- Exception handling section (OPTIONAL)
    -- Error handling code
    -- Handles runtime errors gracefully
END;
/
```

### Block Structure Explained:

| Section | Description | Required? | Purpose |
|---------|-------------|-----------|---------|
| **DECLARE** | Declaration section | Optional | Declare variables, constants, cursors, exceptions |
| **BEGIN** | Execution section | Mandatory | Contains executable SQL and PL/SQL statements |
| **EXCEPTION** | Exception handling | Optional | Handle runtime errors and exceptions |
| **END;** | Block terminator | Mandatory | Marks the end of the block |
| **/** | Execution command | Required in SQL*Plus | Tells SQL*Plus to execute the block |

### Block Execution Flow:

```
START
  ↓
DECLARE (if present)
  ↓
BEGIN
  ↓
Execute statements sequentially
  ↓
Error occurs? → YES → EXCEPTION section → Handle error
  ↓ NO
END
  ↓
FINISH
```

### Example 1: Simple Anonymous Block

```sql
-- Display a message
DECLARE
    v_message VARCHAR2(50) := 'Hello, PL/SQL!';
BEGIN
    DBMS_OUTPUT.PUT_LINE(v_message);
END;
/
```

### Example 2: Basic Calculation

```sql
DECLARE
    v_num1 NUMBER := 10;
    v_num2 NUMBER := 20;
    v_sum NUMBER;
BEGIN
    v_sum := v_num1 + v_num2;
    DBMS_OUTPUT.PUT_LINE('Sum: ' || v_sum);
END;
/
```

---

## Variables and Data Types {#variables-and-data-types}

### Declaration Syntax

```sql
variable_name [CONSTANT] datatype [NOT NULL] [:= initial_value];
```

### Scalar Data Types

```sql
DECLARE
    -- Number types
    v_number NUMBER(10,2) := 100.50;
    v_integer INTEGER := 42;
    v_pls_integer PLS_INTEGER := 100;
    
    -- Character types
    v_varchar VARCHAR2(100) := 'Text data';
    v_char CHAR(10) := 'Fixed';
    
    -- Date types
    v_date DATE := SYSDATE;
    v_timestamp TIMESTAMP := SYSTIMESTAMP;
    
    -- Boolean type
    v_boolean BOOLEAN := TRUE;
    
    -- Constants
    c_pi CONSTANT NUMBER := 3.14159;
    c_company CONSTANT VARCHAR2(50) := 'Oracle Corp';
BEGIN
    DBMS_OUTPUT.PUT_LINE('Number: ' || v_number);
    DBMS_OUTPUT.PUT_LINE('Text: ' || v_varchar);
    DBMS_OUTPUT.PUT_LINE('Date: ' || TO_CHAR(v_date, 'DD-MON-YYYY'));
    DBMS_OUTPUT.PUT_LINE('PI: ' || c_pi);
END;
/
```

### %TYPE Attribute

```sql
DECLARE
    v_employee_id employees.employee_id%TYPE;
    v_first_name employees.first_name%TYPE;
    v_salary employees.salary%TYPE;
BEGIN
    SELECT employee_id, first_name, salary
    INTO v_employee_id, v_first_name, v_salary
    FROM employees
    WHERE employee_id = 100;
    
    DBMS_OUTPUT.PUT_LINE('Employee: ' || v_first_name);
    DBMS_OUTPUT.PUT_LINE('Salary: ' || v_salary);
END;
/
```

### %ROWTYPE Attribute

```sql
DECLARE
    v_employee employees%ROWTYPE;
BEGIN
    SELECT * INTO v_employee
    FROM employees
    WHERE employee_id = 100;
    
    DBMS_OUTPUT.PUT_LINE('ID: ' || v_employee.employee_id);
    DBMS_OUTPUT.PUT_LINE('Name: ' || v_employee.first_name || ' ' || v_employee.last_name);
    DBMS_OUTPUT.PUT_LINE('Email: ' || v_employee.email);
    DBMS_OUTPUT.PUT_LINE('Salary: ' || v_employee.salary);
END;
/
```

---

## Control Structures {#control-structures}

### IF-THEN-ELSE Statement

```sql
-- Example 1: Simple IF
DECLARE
    v_salary NUMBER := 5000;
BEGIN
    IF v_salary > 4000 THEN
        DBMS_OUTPUT.PUT_LINE('High salary');
    END IF;
END;
/

-- Example 2: IF-THEN-ELSE
DECLARE
    v_grade CHAR(1) := 'B';
BEGIN
    IF v_grade = 'A' THEN
        DBMS_OUTPUT.PUT_LINE('Excellent');
    ELSIF v_grade = 'B' THEN
        DBMS_OUTPUT.PUT_LINE('Very Good');
    ELSIF v_grade = 'C' THEN
        DBMS_OUTPUT.PUT_LINE('Good');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Need Improvement');
    END IF;
END;
/
```

### CASE Statement

```sql
-- Example 1: Simple CASE
DECLARE
    v_grade CHAR(1) := 'A';
    v_result VARCHAR2(20);
BEGIN
    v_result := CASE v_grade
        WHEN 'A' THEN 'Excellent'
        WHEN 'B' THEN 'Very Good'
        WHEN 'C' THEN 'Good'
        ELSE 'Need Improvement'
    END;
    
    DBMS_OUTPUT.PUT_LINE('Result: ' || v_result);
END;
/

-- Example 2: Searched CASE
DECLARE
    v_salary NUMBER := 5500;
    v_category VARCHAR2(20);
BEGIN
    v_category := CASE
        WHEN v_salary < 3000 THEN 'Low'
        WHEN v_salary BETWEEN 3000 AND 6000 THEN 'Medium'
        ELSE 'High'
    END;
    
    DBMS_OUTPUT.PUT_LINE('Salary Category: ' || v_category);
END;
/
```

### LOOP Statements

```sql
-- Example 1: Basic LOOP
DECLARE
    v_counter NUMBER := 1;
BEGIN
    LOOP
        DBMS_OUTPUT.PUT_LINE('Counter: ' || v_counter);
        v_counter := v_counter + 1;
        EXIT WHEN v_counter > 5;
    END LOOP;
END;
/

-- Example 2: WHILE LOOP
DECLARE
    v_counter NUMBER := 1;
BEGIN
    WHILE v_counter <= 5 LOOP
        DBMS_OUTPUT.PUT_LINE('Counter: ' || v_counter);
        v_counter := v_counter + 1;
    END LOOP;
END;
/

-- Example 3: FOR LOOP
BEGIN
    FOR i IN 1..5 LOOP
        DBMS_OUTPUT.PUT_LINE('Number: ' || i);
    END LOOP;
    
    -- Reverse FOR LOOP
    FOR i IN REVERSE 1..5 LOOP
        DBMS_OUTPUT.PUT_LINE('Reverse: ' || i);
    END LOOP;
END;
/
```

### CONTINUE Statement

```sql
BEGIN
    FOR i IN 1..10 LOOP
        IF MOD(i, 2) = 0 THEN
            CONTINUE; -- Skip even numbers
        END IF;
        DBMS_OUTPUT.PUT_LINE('Odd Number: ' || i);
    END LOOP;
END;
/
```

---

## Cursors {#cursors}

### Theory: What is a Cursor?

A **cursor** is a pointer to a **private SQL area** in memory where Oracle stores information about processing a SQL statement. Think of it as a pointer to the result set of a query.

### Why Cursors?

- SQL returns a **result set** (multiple rows)
- PL/SQL processes data **row by row**
- Cursors provide a mechanism to fetch and process rows one at a time

### Types of Cursors:

1. **Implicit Cursors**:
   - Automatically created by Oracle
   - Used for single-row SELECT, INSERT, UPDATE, DELETE
   - Managed automatically by Oracle

2. **Explicit Cursors**:
   - Declared and controlled by programmer
   - Used for multi-row SELECT statements
   - Provides more control over query processing

### Cursor Lifecycle:

```
1. DECLARE cursor    → Define the query
2. OPEN cursor       → Execute query, identify result set
3. FETCH cursor      → Retrieve one row at a time
4. CLOSE cursor      → Release resources
```

### Cursor Attributes:

| Attribute | Description | Returns |
|-----------|-------------|---------|
| **%FOUND** | Was a row fetched successfully? | TRUE/FALSE |
| **%NOTFOUND** | No row fetched? | TRUE/FALSE |
| **%ROWCOUNT** | Number of rows fetched so far | NUMBER |
| **%ISOPEN** | Is cursor open? | TRUE/FALSE |

### Implicit Cursors

Automatically created by Oracle for single-row SELECT statements and all DML statements.

```sql
DECLARE
    v_employee_name VARCHAR2(100);
    v_salary NUMBER;
BEGIN
    SELECT first_name || ' ' || last_name, salary
    INTO v_employee_name, v_salary
    FROM employees
    WHERE employee_id = 100;
    
    DBMS_OUTPUT.PUT_LINE('Employee: ' || v_employee_name);
    DBMS_OUTPUT.PUT_LINE('Salary: ' || v_salary);
    
    -- Implicit cursor attributes
    IF SQL%FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Row found and processed');
    END IF;
END;
/
```

### Explicit Cursors

Used for multi-row SELECT statements.

```sql
-- Example 1: Basic Cursor
DECLARE
    CURSOR emp_cursor IS
        SELECT employee_id, first_name, last_name, salary
        FROM employees
        WHERE department_id = 50;
    
    v_emp_id employees.employee_id%TYPE;
    v_first_name employees.first_name%TYPE;
    v_last_name employees.last_name%TYPE;
    v_salary employees.salary%TYPE;
BEGIN
    OPEN emp_cursor;
    
    LOOP
        FETCH emp_cursor INTO v_emp_id, v_first_name, v_last_name, v_salary;
        EXIT WHEN emp_cursor%NOTFOUND;
        
        DBMS_OUTPUT.PUT_LINE(v_emp_id || ' - ' || v_first_name || ' ' || 
                           v_last_name || ' - $' || v_salary);
    END LOOP;
    
    CLOSE emp_cursor;
END;
/

-- Example 2: Cursor with %ROWTYPE
DECLARE
    CURSOR emp_cursor IS
        SELECT * FROM employees WHERE department_id = 50;
    
    v_employee emp_cursor%ROWTYPE;
BEGIN
    OPEN emp_cursor;
    
    LOOP
        FETCH emp_cursor INTO v_employee;
        EXIT WHEN emp_cursor%NOTFOUND;
        
        DBMS_OUTPUT.PUT_LINE(v_employee.employee_id || ' - ' || 
                           v_employee.first_name || ' ' || v_employee.last_name);
    END LOOP;
    
    CLOSE emp_cursor;
END;
/
```

### Cursor FOR Loop

Simplifies cursor processing - automatically opens, fetches, and closes.

```sql
DECLARE
    CURSOR emp_cursor IS
        SELECT employee_id, first_name, last_name, salary
        FROM employees
        WHERE department_id = 50;
BEGIN
    FOR emp_rec IN emp_cursor LOOP
        DBMS_OUTPUT.PUT_LINE(emp_rec.employee_id || ' - ' || 
                           emp_rec.first_name || ' ' || emp_rec.last_name || 
                           ' - $' || emp_rec.salary);
    END LOOP;
END;
/

-- Inline cursor
BEGIN
    FOR emp_rec IN (SELECT employee_id, first_name, salary 
                    FROM employees 
                    WHERE salary > 10000) LOOP
        DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || ' earns $' || emp_rec.salary);
    END LOOP;
END;
/
```

### Parameterized Cursors

```sql
DECLARE
    CURSOR emp_cursor(p_dept_id NUMBER, p_min_salary NUMBER) IS
        SELECT employee_id, first_name, last_name, salary
        FROM employees
        WHERE department_id = p_dept_id AND salary >= p_min_salary;
BEGIN
    DBMS_OUTPUT.PUT_LINE('Department 50, Salary >= 5000:');
    FOR emp_rec IN emp_cursor(50, 5000) LOOP
        DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || ' - $' || emp_rec.salary);
    END LOOP;
    
    DBMS_OUTPUT.PUT_LINE(CHR(10) || 'Department 60, Salary >= 7000:');
    FOR emp_rec IN emp_cursor(60, 7000) LOOP
        DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || ' - $' || emp_rec.salary);
    END LOOP;
END;
/
```

### Cursor with UPDATE/DELETE

```sql
DECLARE
    CURSOR emp_cursor IS
        SELECT employee_id, salary
        FROM employees
        WHERE department_id = 50
        FOR UPDATE OF salary NOWAIT;
BEGIN
    FOR emp_rec IN emp_cursor LOOP
        -- Give 10% raise
        UPDATE employees
        SET salary = salary * 1.10
        WHERE CURRENT OF emp_cursor;
        
        DBMS_OUTPUT.PUT_LINE('Updated employee: ' || emp_rec.employee_id);
    END LOOP;
    
    COMMIT;
END;
/
```

---

## Exception Handling {#exception-handling}

### Predefined Exceptions

```sql
-- Example 1: NO_DATA_FOUND
DECLARE
    v_employee_name VARCHAR2(100);
BEGIN
    SELECT first_name INTO v_employee_name
    FROM employees
    WHERE employee_id = 99999; -- Non-existent ID
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('No employee found with that ID');
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;
/

-- Example 2: TOO_MANY_ROWS
DECLARE
    v_employee_name VARCHAR2(100);
BEGIN
    SELECT first_name INTO v_employee_name
    FROM employees
    WHERE department_id = 50; -- Multiple rows
    
EXCEPTION
    WHEN TOO_MANY_ROWS THEN
        DBMS_OUTPUT.PUT_LINE('Query returned more than one row');
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('No data found');
END;
/

-- Example 3: ZERO_DIVIDE
DECLARE
    v_result NUMBER;
BEGIN
    v_result := 100 / 0;
    
EXCEPTION
    WHEN ZERO_DIVIDE THEN
        DBMS_OUTPUT.PUT_LINE('Cannot divide by zero');
END;
/
```

### Common Predefined Exceptions

```sql
/*
NO_DATA_FOUND          - SELECT INTO returns no rows
TOO_MANY_ROWS          - SELECT INTO returns multiple rows
ZERO_DIVIDE            - Division by zero
VALUE_ERROR            - Arithmetic, conversion, truncation error
INVALID_CURSOR         - Invalid cursor operation
CURSOR_ALREADY_OPEN    - Cursor already open
DUP_VAL_ON_INDEX       - Duplicate value in unique index
INVALID_NUMBER         - Conversion to number fails
LOGIN_DENIED           - Invalid username/password
PROGRAM_ERROR          - PL/SQL internal problem
STORAGE_ERROR          - Out of memory
TIMEOUT_ON_RESOURCE    - Timeout while waiting for resource
*/
```

### User-Defined Exceptions

```sql
DECLARE
    e_invalid_salary EXCEPTION;
    v_salary NUMBER := -5000;
BEGIN
    IF v_salary < 0 THEN
        RAISE e_invalid_salary;
    END IF;
    
    DBMS_OUTPUT.PUT_LINE('Salary is valid: $' || v_salary);
    
EXCEPTION
    WHEN e_invalid_salary THEN
        DBMS_OUTPUT.PUT_LINE('Error: Salary cannot be negative');
END;
/
```

### RAISE_APPLICATION_ERROR

```sql
DECLARE
    v_age NUMBER := 15;
BEGIN
    IF v_age < 18 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Age must be 18 or older');
    END IF;
    
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error Code: ' || SQLCODE);
        DBMS_OUTPUT.PUT_LINE('Error Message: ' || SQLERRM);
END;
/
```

### Exception Propagation

```sql
DECLARE
    v_value NUMBER;
    e_custom_error EXCEPTION;
BEGIN
    BEGIN
        -- Inner block
        SELECT salary INTO v_value
        FROM employees
        WHERE employee_id = 99999;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('Inner: No data found');
            RAISE e_custom_error; -- Propagate to outer block
    END;
    
EXCEPTION
    WHEN e_custom_error THEN
        DBMS_OUTPUT.PUT_LINE('Outer: Custom error caught');
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Outer: Other error');
END;
/
```

---

## Procedures {#procedures}

### Basic Procedure

```sql
-- Create procedure
CREATE OR REPLACE PROCEDURE greet_user(p_name IN VARCHAR2) IS
BEGIN
    DBMS_OUTPUT.PUT_LINE('Hello, ' || p_name || '!');
END greet_user;
/

-- Call procedure
BEGIN
    greet_user('John');
END;
/
```

### Procedure with IN, OUT, IN OUT Parameters

```sql
CREATE OR REPLACE PROCEDURE calculate_bonus(
    p_employee_id IN NUMBER,
    p_bonus_pct IN NUMBER DEFAULT 10,
    p_bonus_amount OUT NUMBER,
    p_new_salary OUT NUMBER
) IS
    v_salary NUMBER;
BEGIN
    SELECT salary INTO v_salary
    FROM employees
    WHERE employee_id = p_employee_id;
    
    p_bonus_amount := v_salary * (p_bonus_pct / 100);
    p_new_salary := v_salary + p_bonus_amount;
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Employee not found');
        p_bonus_amount := 0;
        p_new_salary := 0;
END calculate_bonus;
/

-- Call procedure
DECLARE
    v_bonus NUMBER;
    v_new_sal NUMBER;
BEGIN
    calculate_bonus(100, 15, v_bonus, v_new_sal);
    DBMS_OUTPUT.PUT_LINE('Bonus: $' || v_bonus);
    DBMS_OUTPUT.PUT_LINE('New Salary: $' || v_new_sal);
END;
/
```

### Procedure with IN OUT Parameter

```sql
CREATE OR REPLACE PROCEDURE format_phone(p_phone IN OUT VARCHAR2) IS
BEGIN
    -- Remove all non-digit characters
    p_phone := REGEXP_REPLACE(p_phone, '[^0-9]', '');
    
    -- Format as (XXX) XXX-XXXX
    IF LENGTH(p_phone) = 10 THEN
        p_phone := '(' || SUBSTR(p_phone, 1, 3) || ') ' ||
                   SUBSTR(p_phone, 4, 3) || '-' ||
                   SUBSTR(p_phone, 7, 4);
    END IF;
END format_phone;
/

-- Call procedure
DECLARE
    v_phone VARCHAR2(20) := '1234567890';
BEGIN
    DBMS_OUTPUT.PUT_LINE('Before: ' || v_phone);
    format_phone(v_phone);
    DBMS_OUTPUT.PUT_LINE('After: ' || v_phone);
END;
/
```

### Complex Procedure Example

```sql
CREATE OR REPLACE PROCEDURE manage_employee_salary(
    p_employee_id IN NUMBER,
    p_action IN VARCHAR2,
    p_amount IN NUMBER DEFAULT 0,
    p_status OUT VARCHAR2,
    p_message OUT VARCHAR2
) IS
    v_current_salary NUMBER;
    v_new_salary NUMBER;
    e_invalid_action EXCEPTION;
BEGIN
    -- Get current salary
    SELECT salary INTO v_current_salary
    FROM employees
    WHERE employee_id = p_employee_id;
    
    -- Perform action
    CASE UPPER(p_action)
        WHEN 'INCREASE' THEN
            v_new_salary := v_current_salary + p_amount;
        WHEN 'DECREASE' THEN
            v_new_salary := v_current_salary - p_amount;
        WHEN 'PERCENTAGE' THEN
            v_new_salary := v_current_salary * (1 + p_amount/100);
        ELSE
            RAISE e_invalid_action;
    END CASE;
    
    -- Update salary
    UPDATE employees
    SET salary = v_new_salary
    WHERE employee_id = p_employee_id;
    
    COMMIT;
    
    p_status := 'SUCCESS';
    p_message := 'Salary updated from $' || v_current_salary || 
                 ' to $' || v_new_salary;
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        p_status := 'ERROR';
        p_message := 'Employee not found';
    WHEN e_invalid_action THEN
        p_status := 'ERROR';
        p_message := 'Invalid action. Use: INCREASE, DECREASE, or PERCENTAGE';
    WHEN OTHERS THEN
        ROLLBACK;
        p_status := 'ERROR';
        p_message := 'Error: ' || SQLERRM;
END manage_employee_salary;
/
```

---

## Functions {#functions}

### Basic Function

```sql
CREATE OR REPLACE FUNCTION get_employee_salary(p_employee_id NUMBER)
RETURN NUMBER
IS
    v_salary NUMBER;
BEGIN
    SELECT salary INTO v_salary
    FROM employees
    WHERE employee_id = p_employee_id;
    
    RETURN v_salary;
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN NULL;
END get_employee_salary;
/

-- Call function
DECLARE
    v_sal NUMBER;
BEGIN
    v_sal := get_employee_salary(100);
    DBMS_OUTPUT.PUT_LINE('Salary: $' || v_sal);
END;
/

-- Use in SQL
SELECT employee_id, first_name, get_employee_salary(employee_id) AS salary
FROM employees
WHERE department_id = 50;
```

### Function with Multiple Parameters

```sql
CREATE OR REPLACE FUNCTION calculate_annual_comp(
    p_employee_id NUMBER,
    p_bonus_pct NUMBER DEFAULT 10
) RETURN NUMBER
IS
    v_salary NUMBER;
    v_commission NUMBER;
    v_annual_comp NUMBER;
BEGIN
    SELECT salary, NVL(commission_pct, 0) INTO v_salary, v_commission
    FROM employees
    WHERE employee_id = p_employee_id;
    
    v_annual_comp := (v_salary * 12) + 
                     (v_salary * v_commission) + 
                     (v_salary * p_bonus_pct / 100);
    
    RETURN ROUND(v_annual_comp, 2);
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 0;
END calculate_annual_comp;
/

-- Usage
SELECT employee_id, first_name,
       calculate_annual_comp(employee_id, 15) AS total_compensation
FROM employees
WHERE department_id = 80;
```

### Function Returning VARCHAR2

```sql
CREATE OR REPLACE FUNCTION get_employee_grade(p_salary NUMBER)
RETURN VARCHAR2
IS
    v_grade VARCHAR2(1);
BEGIN
    v_grade := CASE
        WHEN p_salary < 3000 THEN 'C'
        WHEN p_salary BETWEEN 3000 AND 6000 THEN 'B'
        WHEN p_salary > 6000 THEN 'A'
        ELSE 'N/A'
    END;
    
    RETURN v_grade;
END get_employee_grade;
/

-- Usage
SELECT employee_id, first_name, salary,
       get_employee_grade(salary) AS grade
FROM employees
ORDER BY salary DESC;
```

### Deterministic Function

```sql
CREATE OR REPLACE FUNCTION tax_calculation(p_amount NUMBER)
RETURN NUMBER
DETERMINISTIC  -- Indicates same input always returns same output
IS
    c_tax_rate CONSTANT NUMBER := 0.20;
BEGIN
    RETURN p_amount * c_tax_rate;
END tax_calculation;
/
```

---

## Packages {#packages}

### Package Specification

```sql
CREATE OR REPLACE PACKAGE employee_pkg IS
    -- Public type declarations
    TYPE emp_record IS RECORD (
        emp_id NUMBER,
        emp_name VARCHAR2(100),
        emp_salary NUMBER
    );
    
    -- Public constant declarations
    c_max_salary CONSTANT NUMBER := 100000;
    
    -- Public variable declarations
    g_department_id NUMBER := 50;
    
    -- Public procedure and function declarations
    PROCEDURE hire_employee(
        p_first_name IN VARCHAR2,
        p_last_name IN VARCHAR2,
        p_email IN VARCHAR2,
        p_salary IN NUMBER,
        p_employee_id OUT NUMBER
    );
    
    PROCEDURE fire_employee(p_employee_id IN NUMBER);
    
    FUNCTION get_employee_count(p_department_id NUMBER) RETURN NUMBER;
    
    FUNCTION get_avg_salary(p_department_id NUMBER) RETURN NUMBER;
    
    PROCEDURE raise_salary(
        p_employee_id IN NUMBER,
        p_percentage IN NUMBER
    );
END employee_pkg;
/
```

### Package Body

```sql
CREATE OR REPLACE PACKAGE BODY employee_pkg IS
    
    -- Private procedure (not in specification)
    PROCEDURE validate_salary(p_salary NUMBER) IS
    BEGIN
        IF p_salary < 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'Salary cannot be negative');
        END IF;
        
        IF p_salary > c_max_salary THEN
            RAISE_APPLICATION_ERROR(-20002, 'Salary exceeds maximum allowed');
        END IF;
    END validate_salary;
    
    -- Public procedures and functions
    PROCEDURE hire_employee(
        p_first_name IN VARCHAR2,
        p_last_name IN VARCHAR2,
        p_email IN VARCHAR2,
        p_salary IN NUMBER,
        p_employee_id OUT NUMBER
    ) IS
    BEGIN
        validate_salary(p_salary);
        
        SELECT employees_seq.NEXTVAL INTO p_employee_id FROM DUAL;
        
        INSERT INTO employees (
            employee_id, first_name, last_name, email, 
            hire_date, salary, department_id
        ) VALUES (
            p_employee_id, p_first_name, p_last_name, p_email,
            SYSDATE, p_salary, g_department_id
        );
        
        COMMIT;
        DBMS_OUTPUT.PUT_LINE('Employee hired: ' || p_employee_id);
        
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END hire_employee;
    
    PROCEDURE fire_employee(p_employee_id IN NUMBER) IS
    BEGIN
        DELETE FROM employees
        WHERE employee_id = p_employee_id;
        
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-20003, 'Employee not found');
        END IF;
        
        COMMIT;
        DBMS_OUTPUT.PUT_LINE('Employee removed: ' || p_employee_id);
        
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END fire_employee;
    
    FUNCTION get_employee_count(p_department_id NUMBER) 
    RETURN NUMBER IS
        v_count NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_count
        FROM employees
        WHERE department_id = p_department_id;
        
        RETURN v_count;
    END get_employee_count;
    
    FUNCTION get_avg_salary(p_department_id NUMBER) 
    RETURN NUMBER IS
        v_avg_salary NUMBER;
    BEGIN
        SELECT AVG(salary) INTO v_avg_salary
        FROM employees
        WHERE department_id = p_department_id;
        
        RETURN ROUND(v_avg_salary, 2);
    END get_avg_salary;
    
    PROCEDURE raise_salary(
        p_employee_id IN NUMBER,
        p_percentage IN NUMBER
    ) IS
        v_current_salary NUMBER;
        v_new_salary NUMBER;
    BEGIN
        SELECT salary INTO v_current_salary
        FROM employees
        WHERE employee_id = p_employee_id;
        
        v_new_salary := v_current_salary * (1 + p_percentage/100);
        
        validate_salary(v_new_salary);
        
        UPDATE employees
        SET salary = v_new_salary
        WHERE employee_id = p_employee_id;
        
        COMMIT;
        DBMS_OUTPUT.PUT_LINE('Salary raised from $' || v_current_salary || 
                           ' to $' || v_new_salary);
    END raise_salary;
    
END employee_pkg;
/
```

### Using the Package

```sql
-- Use package procedures
DECLARE
    v_new_emp_id NUMBER;
BEGIN
    -- Hire employee
    employee_pkg.hire_employee('John', 'Doe', 'jdoe@email.com', 5000, v_new_emp_id);
    DBMS_OUTPUT.PUT_LINE('New employee ID: ' || v_new_emp_id);
    
    -- Get employee count
    DBMS_OUTPUT.PUT_LINE('Employee count: ' || 
                        employee_pkg.get_employee_count(50));
    
    -- Get average salary
    DBMS_OUTPUT.PUT_LINE('Average salary: $' || 
                        employee_pkg.get_avg_salary(50));
    
    -- Raise salary
    employee_pkg.raise_salary(v_new_emp_id, 10);
END;
/
```

---

## Triggers {#triggers}

### DML Triggers

#### Row-Level Trigger (BEFORE INSERT)

```sql
CREATE OR REPLACE TRIGGER emp_before_insert
BEFORE INSERT ON employees
FOR EACH ROW
BEGIN
    -- Auto-generate employee_id if not provided
    IF :NEW.employee_id IS NULL THEN
        SELECT employees_seq.NEXTVAL INTO :NEW.employee_id FROM DUAL;
    END IF;
    
    -- Set hire_date to current date
    :NEW.hire_date := SYSDATE;
    
    -- Convert email to uppercase
    :NEW.email := UPPER(:NEW.email);
    
    -- Validate salary
    IF :NEW.salary < 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Salary cannot be negative');
    END IF;
END;
/
```

#### AFTER INSERT Trigger

```sql
CREATE TABLE emp_audit (
    audit_id NUMBER PRIMARY KEY,
    employee_id NUMBER,
    action VARCHAR2(50),
    action_date DATE,
    username VARCHAR2(30)
);

CREATE SEQUENCE emp_audit_seq;

CREATE OR REPLACE TRIGGER emp_after_insert
AFTER INSERT ON employees
FOR EACH ROW
BEGIN
    INSERT INTO emp_audit (
        audit_id, employee_id, action, action_date, username
    ) VALUES (
        emp_audit_seq.NEXTVAL, :NEW.employee_id, 'INSERT', SYSDATE, USER
    );
END;
/
```

#### BEFORE UPDATE Trigger

```sql
CREATE OR REPLACE TRIGGER emp_before_update
BEFORE UPDATE ON employees
FOR EACH ROW
BEGIN
    -- Prevent salary decrease
    IF :NEW.salary < :OLD.salary THEN
        RAISE_APPLICATION_ERROR(-20002, 
            'Salary cannot be decreased. Old: ' || :OLD.salary || 
            ', New: ' || :NEW.salary);
    END IF;
    
    -- Log salary changes
    IF :NEW.salary != :OLD.salary THEN
        DBMS_OUTPUT.PUT_LINE('Salary changed for employee ' || :NEW.employee_id ||
                           ' from $' || :OLD.salary || ' to $' || :NEW.salary);
    END IF;
END;
/
```

#### AFTER UPDATE Trigger

```sql
CREATE OR REPLACE TRIGGER emp_after_update
AFTER UPDATE ON employees
FOR EACH ROW
BEGIN
    INSERT INTO emp_audit (
        audit_id, employee_id, action, action_date, username
    ) VALUES (
        emp_audit_seq.NEXTVAL, :NEW.employee_id, 
        'UPDATE - Salary: ' || :OLD.salary || ' -> ' || :NEW.salary,
        SYSDATE, USER
    );
END;
/
```

#### BEFORE DELETE Trigger

```sql
CREATE OR REPLACE TRIGGER emp_before_delete
BEFORE DELETE ON employees
FOR EACH ROW
BEGIN
    -- Prevent deletion of high-earning employees
    IF :OLD.salary > 10000 THEN
        RAISE_APPLICATION_ERROR(-20003, 
            'Cannot delete employee with salary > $10,000');
    END IF;
END;
/
```

#### Compound Trigger

```sql
CREATE OR REPLACE TRIGGER emp_compound_trigger
FOR INSERT OR UPDATE OR DELETE ON employees
COMPOUND TRIGGER
    
    -- Variables
    TYPE emp_ids_type IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
    v_emp_ids emp_ids_type;
    v_index PLS_INTEGER := 0;
    
    -- BEFORE STATEMENT
    BEFORE STATEMENT IS
    BEGIN
        DBMS_OUTPUT.PUT_LINE('=== Operation Starting ===');
    END BEFORE STATEMENT;
    
    -- BEFORE EACH ROW
    BEFORE EACH ROW IS
    BEGIN
        IF INSERTING THEN
            DBMS_OUTPUT.PUT_LINE('Before Insert Row: ' || :NEW.employee_id);
        ELSIF UPDATING THEN
            DBMS_OUTPUT.PUT_LINE('Before Update Row: ' || :NEW.employee_id);
        ELSIF DELETING THEN
            DBMS_OUTPUT.PUT_LINE('Before Delete Row: ' || :OLD.employee_id);
        END IF;
    END BEFORE EACH ROW;
    
    -- AFTER EACH ROW
    AFTER EACH ROW IS
    BEGIN
        v_index := v_index + 1;
        IF INSERTING OR UPDATING THEN
            v_emp_ids(v_index) := :NEW.employee_id;
        ELSE
            v_emp_ids(v_index) := :OLD.employee_id;
        END IF;
    END AFTER EACH ROW;
    
    -- AFTER STATEMENT
    AFTER STATEMENT IS
    BEGIN
        DBMS_OUTPUT.PUT_LINE('Total rows affected: ' || v_index);
        DBMS_OUTPUT.PUT_LINE('=== Operation Complete ===');
    END AFTER STATEMENT;
    
END emp_compound_trigger;
/
```

### DDL Triggers

```sql
CREATE TABLE ddl_audit (
    audit_id NUMBER PRIMARY KEY,
    event_type VARCHAR2(30),
    object_type VARCHAR2(30),
    object_name VARCHAR2(128),
    event_date DATE,
    username VARCHAR2(30)
);

CREATE OR REPLACE TRIGGER ddl_audit_trigger
AFTER CREATE OR ALTER OR DROP ON SCHEMA
BEGIN
    INSERT INTO ddl_audit VALUES (
        ddl_audit_seq.NEXTVAL,
        ORA_SYSEVENT,
        ORA_DICT_OBJ_TYPE,
        ORA_DICT_OBJ_NAME,
        SYSDATE,
        USER
    );
END;
/
```

### INSTEAD OF Trigger (for Views)

```sql
-- Create a view
CREATE OR REPLACE VIEW emp_dept_view AS
SELECT e.employee_id, e.first_name, e.last_name, 
       d.department_name
FROM employees e
JOIN departments d ON e.department_id = d.department_id;

-- Create INSTEAD OF trigger
CREATE OR REPLACE TRIGGER emp_dept_insert
INSTEAD OF INSERT ON emp_dept_view
FOR EACH ROW
DECLARE
    v_dept_id NUMBER;
BEGIN
    -- Find department_id from department_name
    SELECT department_id INTO v_dept_id
    FROM departments
    WHERE department_name = :NEW.department_name;
    
    -- Insert into employees table
    INSERT INTO employees (employee_id, first_name, last_name, department_id)
    VALUES (:NEW.employee_id, :NEW.first_name, :NEW.last_name, v_dept_id);
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20004, 'Department not found');
END;
/
```

---

## Collections {#collections}

### Associative Arrays (Index-By Tables)

```sql
DECLARE
    -- Declaration
    TYPE emp_names_type IS TABLE OF VARCHAR2(100) INDEX BY PLS_INTEGER;
    v_emp_names emp_names_type;
    
    -- String-indexed associative array
    TYPE salary_type IS TABLE OF NUMBER INDEX BY VARCHAR2(50);
    v_salaries salary_type;
BEGIN
    -- Populate numeric-indexed array
    v_emp_names(1) := 'John Doe';
    v_emp_names(2) := 'Jane Smith';
    v_emp_names(3) := 'Bob Johnson';
    
    -- Populate string-indexed array
    v_salaries('John Doe') := 5000;
    v_salaries('Jane Smith') := 6000;
    v_salaries('Bob Johnson') := 5500;
    
    -- Access elements
    DBMS_OUTPUT.PUT_LINE('Employee 1: ' || v_emp_names(1));
    DBMS_OUTPUT.PUT_LINE('Salary for John: $' || v_salaries('John Doe'));
    
    -- Iterate
    FOR i IN 1..v_emp_names.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE(i || ': ' || v_emp_names(i));
    END LOOP;
    
    -- Collection methods
    DBMS_OUTPUT.PUT_LINE('Count: ' || v_emp_names.COUNT);
    DBMS_OUTPUT.PUT_LINE('First: ' || v_emp_names.FIRST);
    DBMS_OUTPUT.PUT_LINE('Last: ' || v_emp_names.LAST);
    
    -- Delete element
    v_emp_names.DELETE(2);
    DBMS_OUTPUT.PUT_LINE('Count after delete: ' || v_emp_names.COUNT);
END;
/
```

### Nested Tables

```sql
DECLARE
    -- Declaration
    TYPE num_table IS TABLE OF NUMBER;
    v_numbers num_table;
BEGIN
    -- Initialize
    v_numbers := num_table(10, 20, 30, 40, 50);
    
    -- Add element
    v_numbers.EXTEND;
    v_numbers(6) := 60;
    
    -- Display
    FOR i IN 1..v_numbers.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE('Number ' || i || ': ' || v_numbers(i));
    END LOOP;
    
    -- Delete element
    v_numbers.DELETE(3);
    
    -- Trim last element
    v_numbers.TRIM;
    
    DBMS_OUTPUT.PUT_LINE('Count: ' || v_numbers.COUNT);
END;
/
```

### VARRAYs (Variable-Size Arrays)

```sql
DECLARE
    -- Declaration with max size
    TYPE names_array IS VARRAY(5) OF VARCHAR2(50);
    v_names names_array;
BEGIN
    -- Initialize
    v_names := names_array('Alice', 'Bob', 'Charlie');
    
    -- Add elements
    v_names.EXTEND;
    v_names(4) := 'David';
    
    -- Display
    FOR i IN 1..v_names.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE('Name ' || i || ': ' || v_names(i));
    END LOOP;
    
    -- Limit check
    DBMS_OUTPUT.PUT_LINE('Max size: ' || v_names.LIMIT);
    DBMS_OUTPUT.PUT_LINE('Current size: ' || v_names.COUNT);
END;
/
```

### Collection of Records

```sql
DECLARE
    TYPE emp_record IS RECORD (
        emp_id NUMBER,
        emp_name VARCHAR2(100),
        emp_salary NUMBER
    );
    
    TYPE emp_table IS TABLE OF emp_record INDEX BY PLS_INTEGER;
    v_employees emp_table;
BEGIN
    -- Populate
    v_employees(1).emp_id := 100;
    v_employees(1).emp_name := 'John Doe';
    v_employees(1).emp_salary := 5000;
    
    v_employees(2).emp_id := 101;
    v_employees(2).emp_name := 'Jane Smith';
    v_employees(2).emp_salary := 6000;
    
    -- Display
    FOR i IN 1..v_employees.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE('ID: ' || v_employees(i).emp_id ||
                           ', Name: ' || v_employees(i).emp_name ||
                           ', Salary: $' || v_employees(i).emp_salary);
    END LOOP;
END;
/
```

### BULK COLLECT

```sql
DECLARE
    TYPE emp_ids_type IS TABLE OF employees.employee_id%TYPE;
    TYPE emp_names_type IS TABLE OF employees.first_name%TYPE;
    
    v_emp_ids emp_ids_type;
    v_emp_names emp_names_type;
BEGIN
    -- Fetch all at once
    SELECT employee_id, first_name
    BULK COLLECT INTO v_emp_ids, v_emp_names
    FROM employees
    WHERE department_id = 50;
    
    -- Display
    FOR i IN 1..v_emp_ids.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE('ID: ' || v_emp_ids(i) || 
                           ', Name: ' || v_emp_names(i));
    END LOOP;
    
    DBMS_OUTPUT.PUT_LINE('Total records: ' || v_emp_ids.COUNT);
END;
/
```

### FORALL Statement

```sql
DECLARE
    TYPE emp_ids_type IS TABLE OF NUMBER;
    v_emp_ids emp_ids_type := emp_ids_type(100, 101, 102, 103);
BEGIN
    -- Bulk update
    FORALL i IN v_emp_ids.FIRST..v_emp_ids.LAST
        UPDATE employees
        SET salary = salary * 1.10
        WHERE employee_id = v_emp_ids(i);
    
    DBMS_OUTPUT.PUT_LINE('Updated ' || SQL%ROWCOUNT || ' employees');
    COMMIT;
END;
/
```

---

## Advanced Topics {#advanced-topics}

### Dynamic SQL

```sql
-- Example 1: Simple Dynamic SQL
DECLARE
    v_sql VARCHAR2(1000);
    v_count NUMBER;
BEGIN
    v_sql := 'SELECT COUNT(*) FROM employees WHERE department_id = 50';
    EXECUTE IMMEDIATE v_sql INTO v_count;
    DBMS_OUTPUT.PUT_LINE('Count: ' || v_count);
END;
/

-- Example 2: Dynamic SQL with Bind Variables
DECLARE
    v_sql VARCHAR2(1000);
    v_dept_id NUMBER := 50;
    v_min_salary NUMBER := 5000;
    v_count NUMBER;
BEGIN
    v_sql := 'SELECT COUNT(*) FROM employees ' ||
             'WHERE department_id = :dept AND salary >= :sal';
    
    EXECUTE IMMEDIATE v_sql 
        INTO v_count 
        USING v_dept_id, v_min_salary;
    
    DBMS_OUTPUT.PUT_LINE('Count: ' || v_count);
END;
/

-- Example 3: Dynamic DML
DECLARE
    v_table_name VARCHAR2(30) := 'employees';
    v_column_name VARCHAR2(30) := 'salary';
    v_emp_id NUMBER := 100;
    v_new_value NUMBER := 10000;
BEGIN
    EXECUTE IMMEDIATE 
        'UPDATE ' || v_table_name || 
        ' SET ' || v_column_name || ' = :1 ' ||
        ' WHERE employee_id = :2'
    USING v_new_value, v_emp_id;
    
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('Updated successfully');
END;
/
```

### Autonomous Transactions

```sql
CREATE OR REPLACE PROCEDURE log_activity(
    p_message VARCHAR2
) IS
    PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
    INSERT INTO activity_log (log_id, message, log_date)
    VALUES (log_seq.NEXTVAL, p_message, SYSDATE);
    
    COMMIT; -- Independent commit
END;
/

-- Usage
DECLARE
BEGIN
    -- This will be logged even if main transaction rolls back
    log_activity('Starting process');
    
    UPDATE employees SET salary = salary * 1.10;
    
    -- Some error occurs
    ROLLBACK; -- Main transaction rolled back
    
    -- But log entry remains
END;
/
```

### Pipelined Functions

```sql
-- Create type
CREATE OR REPLACE TYPE emp_obj IS OBJECT (
    employee_id NUMBER,
    full_name VARCHAR2(100),
    salary NUMBER
);

CREATE OR REPLACE TYPE emp_table IS TABLE OF emp_obj;

-- Pipelined function
CREATE OR REPLACE FUNCTION get_employees_pipelined(p_dept_id NUMBER)
RETURN emp_table PIPELINED
IS
BEGIN
    FOR emp_rec IN (SELECT employee_id, first_name || ' ' || last_name AS full_name, salary
                    FROM employees
                    WHERE department_id = p_dept_id) LOOP
        PIPE ROW(emp_obj(emp_rec.employee_id, emp_rec.full_name, emp_rec.salary));
    END LOOP;
    
    RETURN;
END;
/

-- Usage
SELECT * FROM TABLE(get_employees_pipelined(50));
```

### Hierarchical Queries in PL/SQL

```sql
DECLARE
    CURSOR emp_hierarchy IS
        SELECT employee_id, first_name, manager_id, LEVEL AS emp_level
        FROM employees
        START WITH manager_id IS NULL
        CONNECT BY PRIOR employee_id = manager_id
        ORDER SIBLINGS BY first_name;
BEGIN
    FOR emp IN emp_hierarchy LOOP
        DBMS_OUTPUT.PUT_LINE(LPAD(' ', (emp.emp_level - 1) * 2) || 
                           emp.first_name || ' (Level ' || emp.emp_level || ')');
    END LOOP;
END;
/
```

### Object Types

```sql
-- Create object type
CREATE OR REPLACE TYPE address_type AS OBJECT (
    street VARCHAR2(100),
    city VARCHAR2(50),
    state VARCHAR2(2),
    zip VARCHAR2(10)
);
/

CREATE OR REPLACE TYPE person_type AS OBJECT (
    person_id NUMBER,
    first_name VARCHAR2(50),
    last_name VARCHAR2(50),
    address address_type,
    
    MEMBER FUNCTION get_full_name RETURN VARCHAR2,
    MEMBER FUNCTION get_full_address RETURN VARCHAR2
);
/

-- Create type body
CREATE OR REPLACE TYPE BODY person_type AS
    MEMBER FUNCTION get_full_name RETURN VARCHAR2 IS
    BEGIN
        RETURN first_name || ' ' || last_name;
    END;
    
    MEMBER FUNCTION get_full_address RETURN VARCHAR2 IS
    BEGIN
        RETURN address.street || ', ' || address.city || ', ' || 
               address.state || ' ' || address.zip;
    END;
END;
/

-- Usage
DECLARE
    v_person person_type;
BEGIN
    v_person := person_type(
        1, 
        'John', 
        'Doe',
        address_type('123 Main St', 'New York', 'NY', '10001')
    );
    
    DBMS_OUTPUT.PUT_LINE('Name: ' || v_person.get_full_name());
    DBMS_OUTPUT.PUT_LINE('Address: ' || v_person.get_full_address());
END;
/
```

### Ref Cursors

```sql
-- Create package with ref cursor
CREATE OR REPLACE PACKAGE ref_cursor_pkg IS
    TYPE emp_cursor_type IS REF CURSOR RETURN employees%ROWTYPE;
    
    PROCEDURE get_employees(
        p_dept_id IN NUMBER,
        p_cursor OUT emp_cursor_type
    );
END;
/

CREATE OR REPLACE PACKAGE BODY ref_cursor_pkg IS
    PROCEDURE get_employees(
        p_dept_id IN NUMBER,
        p_cursor OUT emp_cursor_type
    ) IS
    BEGIN
        OPEN p_cursor FOR
            SELECT * FROM employees
            WHERE department_id = p_dept_id;
    END;
END;
/

-- Usage
DECLARE
    v_cursor ref_cursor_pkg.emp_cursor_type;
    v_employee employees%ROWTYPE;
BEGIN
    ref_cursor_pkg.get_employees(50, v_cursor);
    
    LOOP
        FETCH v_cursor INTO v_employee;
        EXIT WHEN v_cursor%NOTFOUND;
        
        DBMS_OUTPUT.PUT_LINE(v_employee.first_name || ' ' || v_employee.last_name);
    END LOOP;
    
    CLOSE v_cursor;
END;
/
```

---

## Best Practices

1. **Naming Conventions**
   - Variables: `v_variable_name`
   - Constants: `c_constant_name`
   - Parameters: `p_parameter_name`
   - Cursors: `cursor_name_cursor`
   - Exceptions: `e_exception_name`

2. **Error Handling**
   - Always include exception handlers
   - Use meaningful error messages
   - Log errors for debugging

3. **Performance**
   - Use BULK COLLECT for large datasets
   - Use FORALL for bulk DML operations
   - Minimize context switches between PL/SQL and SQL

4. **Code Organization**
   - Use packages to group related procedures and functions
   - Keep procedures and functions focused (single responsibility)
   - Document code with comments

5. **Security**
   - Use bind variables to prevent SQL injection
   - Grant minimal necessary privileges
   - Validate all input parameters

---

## Common PL/SQL Built-in Packages

```sql
-- DBMS_OUTPUT: Display messages
DBMS_OUTPUT.PUT_LINE('Message');

-- DBMS_UTILITY: Utility functions
DBMS_UTILITY.FORMAT_ERROR_STACK;

-- DBMS_SQL: Dynamic SQL
-- DBMS_JOB: Job scheduling
-- DBMS_SCHEDULER: Advanced scheduling
-- UTL_FILE: File I/O operations
-- UTL_MAIL: Email functionality
-- DBMS_LOB: Large object manipulation
-- DBMS_CRYPTO: Cryptographic functions
```

---

## Summary

PL/SQL extends SQL with procedural capabilities, providing:
- **Block structure** for organizing code
- **Variables and data types** for data manipulation
- **Control structures** for program flow
- **Cursors** for multi-row processing
- **Exception handling** for error management
- **Stored procedures and functions** for code reusability
- **Packages** for modular design
- **Triggers** for automatic actions
- **Collections** for complex data structures
- **Advanced features** for sophisticated applications

This makes PL/SQL a powerful language for database programming in Oracle environments.

---

## Interview Questions & Answers {#interview-questions}

### Section 1: Basic Concepts

#### Q1: What is PL/SQL? How is it different from SQL?

**Answer:**

PL/SQL (Procedural Language/Structured Query Language) is Oracle's procedural extension to SQL.

**Key Differences:**

| Aspect | SQL | PL/SQL |
|--------|-----|--------|
| **Type** | Non-procedural (declarative) | Procedural |
| **Execution** | Statement by statement | Block execution |
| **Control Flow** | No loops, conditions | Supports IF, LOOP, CASE |
| **Error Handling** | No built-in mechanism | Exception handling |
| **Variables** | Not supported | Fully supported |
| **Modularity** | Limited | Procedures, functions, packages |
| **Network Traffic** | High (one statement at a time) | Low (block at once) |

**Example:**
```sql
-- SQL: Multiple trips to database
SELECT * FROM employees WHERE employee_id = 100;
UPDATE employees SET salary = 5000 WHERE employee_id = 100;
SELECT * FROM employees WHERE employee_id = 100;

-- PL/SQL: Single trip to database
DECLARE
    v_emp employees%ROWTYPE;
BEGIN
    SELECT * INTO v_emp FROM employees WHERE employee_id = 100;
    UPDATE employees SET salary = 5000 WHERE employee_id = 100;
    SELECT * INTO v_emp FROM employees WHERE employee_id = 100;
    DBMS_OUTPUT.PUT_LINE('Salary updated to: ' || v_emp.salary);
END;
/
```

---

#### Q2: Explain the PL/SQL block structure.

**Answer:**

PL/SQL uses a block structure with three sections:

```sql
DECLARE
    -- Optional: Declare variables, constants, cursors, exceptions
    v_salary NUMBER;
    c_bonus CONSTANT NUMBER := 1000;
BEGIN
    -- Mandatory: Executable statements
    SELECT salary INTO v_salary FROM employees WHERE employee_id = 100;
    v_salary := v_salary + c_bonus;
    DBMS_OUTPUT.PUT_LINE('New Salary: ' || v_salary);
EXCEPTION
    -- Optional: Handle errors
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Employee not found');
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;
/
```

**Sections:**
1. **DECLARE**: Variable declarations (optional)
2. **BEGIN**: Executable statements (mandatory)
3. **EXCEPTION**: Error handling (optional)

---

#### Q3: What is the difference between %TYPE and %ROWTYPE?

**Answer:**

**%TYPE**: Declares a variable with the same datatype as a table column or another variable.

**%ROWTYPE**: Declares a record variable with the same structure as a table row.

```sql
DECLARE
    -- %TYPE examples
    v_emp_name employees.first_name%TYPE;  -- Same type as first_name column
    v_salary employees.salary%TYPE;         -- Same type as salary column
    v_another_salary v_salary%TYPE;         -- Same type as v_salary
    
    -- %ROWTYPE example
    v_employee employees%ROWTYPE;           -- Record with all columns
    
BEGIN
    -- Fetch into individual variables
    SELECT first_name, salary 
    INTO v_emp_name, v_salary
    FROM employees WHERE employee_id = 100;
    
    -- Fetch entire row
    SELECT * INTO v_employee
    FROM employees WHERE employee_id = 100;
    
    DBMS_OUTPUT.PUT_LINE('Name: ' || v_emp_name);
    DBMS_OUTPUT.PUT_LINE('Full Info: ' || v_employee.first_name || 
                        ' earns $' || v_employee.salary);
END;
/
```

**Benefits:**
- ✓ Maintains data type consistency
- ✓ Reduces maintenance (changes to table structure auto-reflected)
- ✓ Improves code readability

---

#### Q4: What are the different types of cursors in PL/SQL?

**Answer:**

**1. Implicit Cursors:**
```sql
-- Automatically created for DML and single-row SELECT
DECLARE
    v_count NUMBER;
BEGIN
    UPDATE employees SET salary = salary * 1.1 WHERE department_id = 50;
    
    -- Implicit cursor attributes
    DBMS_OUTPUT.PUT_LINE('Rows updated: ' || SQL%ROWCOUNT);
    
    IF SQL%FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Update successful');
    END IF;
END;
/
```

**2. Explicit Cursors:**
```sql
-- Programmer-defined for multi-row SELECT
DECLARE
    CURSOR emp_cursor IS
        SELECT employee_id, first_name, salary FROM employees;
    v_emp_id NUMBER;
    v_name VARCHAR2(50);
    v_sal NUMBER;
BEGIN
    OPEN emp_cursor;
    LOOP
        FETCH emp_cursor INTO v_emp_id, v_name, v_sal;
        EXIT WHEN emp_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(v_name || ': $' || v_sal);
    END LOOP;
    CLOSE emp_cursor;
END;
/
```

**3. Cursor FOR Loop:**
```sql
-- Simplifies cursor processing
BEGIN
    FOR emp_rec IN (SELECT first_name, salary FROM employees) LOOP
        DBMS_OUTPUT.PUT_LINE(emp_rec.first_name || ': $' || emp_rec.salary);
    END LOOP;
END;
/
```

**4. REF Cursors (Cursor Variables):**
```sql
-- Dynamic cursors that can be opened for different queries
DECLARE
    TYPE emp_cursor_type IS REF CURSOR;
    emp_cursor emp_cursor_type;
    v_name VARCHAR2(50);
    v_sal NUMBER;
BEGIN
    OPEN emp_cursor FOR SELECT first_name, salary FROM employees WHERE department_id = 50;
    -- Process...
    CLOSE emp_cursor;
END;
/
```

---

### Section 2: Procedures and Functions

#### Q5: What is the difference between Procedure and Function?

**Answer:**

| Feature | Procedure | Function |
|---------|-----------|----------|
| **RETURN** | No return value (use OUT parameters) | Must return a value |
| **Keyword** | No RETURN clause | RETURN datatype required |
| **Calling** | Called as standalone statement | Called in expressions |
| **SQL Usage** | Cannot be used in SQL | Can be used in SQL |
| **Purpose** | Performs actions | Computes and returns value |
| **OUT Parameters** | Can have multiple OUT | Typically one RETURN |

**Procedure Example:**
```sql
CREATE OR REPLACE PROCEDURE update_salary(
    p_emp_id IN NUMBER,
    p_new_salary IN NUMBER,
    p_status OUT VARCHAR2
) IS
BEGIN
    UPDATE employees SET salary = p_new_salary WHERE employee_id = p_emp_id;
    
    IF SQL%ROWCOUNT > 0 THEN
        p_status := 'SUCCESS';
        COMMIT;
    ELSE
        p_status := 'FAILED';
    END IF;
END;
/

-- Call procedure
DECLARE
    v_status VARCHAR2(20);
BEGIN
    update_salary(100, 10000, v_status);
    DBMS_OUTPUT.PUT_LINE('Status: ' || v_status);
END;
/
```

**Function Example:**
```sql
CREATE OR REPLACE FUNCTION get_annual_salary(p_emp_id NUMBER)
RETURN NUMBER
IS
    v_monthly_salary NUMBER;
BEGIN
    SELECT salary INTO v_monthly_salary
    FROM employees WHERE employee_id = p_emp_id;
    
    RETURN v_monthly_salary * 12;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 0;
END;
/

-- Call in SQL
SELECT employee_id, first_name, get_annual_salary(employee_id) AS annual_salary
FROM employees;

-- Call in PL/SQL
DECLARE
    v_annual NUMBER;
BEGIN
    v_annual := get_annual_salary(100);
    DBMS_OUTPUT.PUT_LINE('Annual Salary: $' || v_annual);
END;
/
```

---

#### Q6: What are IN, OUT, and IN OUT parameters?

**Answer:**

**IN Parameter (Default):**
- Passes value TO the procedure/function
- Read-only (cannot be modified)
- Can be literal, variable, or expression

**OUT Parameter:**
- Returns value FROM the procedure
- Write-only (acts as uninitialized)
- Must be a variable

**IN OUT Parameter:**
- Both passes value in AND returns value out
- Can be read and modified
- Must be a variable

```sql
CREATE OR REPLACE PROCEDURE demo_parameters(
    p_in IN NUMBER,              -- Input only
    p_out OUT NUMBER,            -- Output only
    p_inout IN OUT NUMBER        -- Both input and output
) IS
BEGIN
    DBMS_OUTPUT.PUT_LINE('IN parameter: ' || p_in);
    -- p_in := p_in + 1;  -- ERROR: Cannot modify IN parameter
    
    p_out := p_in * 2;           -- Assign value to OUT
    
    DBMS_OUTPUT.PUT_LINE('IN OUT before: ' || p_inout);
    p_inout := p_inout + p_in;   -- Modify IN OUT parameter
    DBMS_OUTPUT.PUT_LINE('IN OUT after: ' || p_inout);
END;
/

-- Test the procedure
DECLARE
    v_in NUMBER := 10;
    v_out NUMBER;
    v_inout NUMBER := 5;
BEGIN
    DBMS_OUTPUT.PUT_LINE('=== Before Call ===');
    DBMS_OUTPUT.PUT_LINE('v_in: ' || v_in);
    DBMS_OUTPUT.PUT_LINE('v_inout: ' || v_inout);
    
    demo_parameters(v_in, v_out, v_inout);
    
    DBMS_OUTPUT.PUT_LINE('=== After Call ===');
    DBMS_OUTPUT.PUT_LINE('v_in: ' || v_in);      -- Still 10 (unchanged)
    DBMS_OUTPUT.PUT_LINE('v_out: ' || v_out);    -- Now 20
    DBMS_OUTPUT.PUT_LINE('v_inout: ' || v_inout); -- Now 15
END;
/
```

---

### Section 3: Exception Handling

#### Q7: Explain Exception Handling in PL/SQL with examples.

**Answer:**

**Exception** is a runtime error that disrupts normal program flow. PL/SQL provides a robust exception handling mechanism.

**Types of Exceptions:**

**1. Predefined Oracle Exceptions:**
```sql
DECLARE
    v_name VARCHAR2(50);
    v_salary NUMBER;
BEGIN
    -- NO_DATA_FOUND
    SELECT first_name INTO v_name 
    FROM employees WHERE employee_id = 9999;
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('No employee found');
    WHEN TOO_MANY_ROWS THEN
        DBMS_OUTPUT.PUT_LINE('Multiple rows returned');
    WHEN ZERO_DIVIDE THEN
        DBMS_OUTPUT.PUT_LINE('Division by zero');
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;
/
```

**2. User-Defined Exceptions:**
```sql
DECLARE
    e_invalid_salary EXCEPTION;
    e_invalid_department EXCEPTION;
    v_salary NUMBER := -1000;
    v_dept_id NUMBER := 999;
BEGIN
    -- Validate salary
    IF v_salary < 0 THEN
        RAISE e_invalid_salary;
    END IF;
    
    -- Validate department
    IF v_dept_id > 100 THEN
        RAISE e_invalid_department;
    END IF;
    
EXCEPTION
    WHEN e_invalid_salary THEN
        DBMS_OUTPUT.PUT_LINE('Error: Salary cannot be negative');
    WHEN e_invalid_department THEN
        DBMS_OUTPUT.PUT_LINE('Error: Invalid department ID');
END;
/
```

**3. RAISE_APPLICATION_ERROR:**
```sql
CREATE OR REPLACE PROCEDURE hire_employee(
    p_salary NUMBER,
    p_dept_id NUMBER
) IS
BEGIN
    IF p_salary < 2000 THEN
        RAISE_APPLICATION_ERROR(-20001, 
            'Salary must be at least $2000. Provided: $' || p_salary);
    END IF;
    
    IF p_dept_id NOT IN (10, 20, 30, 40, 50) THEN
        RAISE_APPLICATION_ERROR(-20002,
            'Invalid department ID: ' || p_dept_id);
    END IF;
    
    -- Insert employee...
    DBMS_OUTPUT.PUT_LINE('Employee hired successfully');
END;
/

-- Test
BEGIN
    hire_employee(1500, 10);  -- Will raise exception
END;
/
```

**Common Predefined Exceptions:**
- `NO_DATA_FOUND`: SELECT INTO returns no rows
- `TOO_MANY_ROWS`: SELECT INTO returns multiple rows
- `ZERO_DIVIDE`: Division by zero
- `VALUE_ERROR`: Conversion or arithmetic error
- `INVALID_CURSOR`: Invalid cursor operation
- `DUP_VAL_ON_INDEX`: Duplicate value in unique index

---

#### Q8: What is the difference between RAISE and RAISE_APPLICATION_ERROR?

**Answer:**

**RAISE:**
- Used for predefined or user-defined exceptions
- No custom error message or code
- Only within exception handling

**RAISE_APPLICATION_ERROR:**
- Creates custom error with specific error number and message
- Error number: -20000 to -20999
- Can be used anywhere in the code

```sql
DECLARE
    e_custom_error EXCEPTION;
    v_option NUMBER := 2;
BEGIN
    IF v_option = 1 THEN
        -- Using RAISE
        RAISE e_custom_error;
        
    ELSIF v_option = 2 THEN
        -- Using RAISE_APPLICATION_ERROR
        RAISE_APPLICATION_ERROR(-20001, 
            'Custom error with code and message');
    END IF;
    
EXCEPTION
    WHEN e_custom_error THEN
        DBMS_OUTPUT.PUT_LINE('Caught custom exception');
        DBMS_OUTPUT.PUT_LINE('Error Code: ' || SQLCODE);
        DBMS_OUTPUT.PUT_LINE('Error Message: ' || SQLERRM);
END;
/
```

---

### Section 4: Triggers

#### Q9: What are Triggers? Explain different types with examples.

**Answer:**

A **trigger** is a stored PL/SQL block that automatically executes when a specific event occurs on a table or view.

**Types of Triggers:**

**1. DML Triggers (Row-Level and Statement-Level):**

```sql
-- Create audit table
CREATE TABLE emp_audit (
    audit_id NUMBER PRIMARY KEY,
    employee_id NUMBER,
    old_salary NUMBER,
    new_salary NUMBER,
    change_date DATE,
    changed_by VARCHAR2(30)
);

-- Row-level BEFORE trigger
CREATE OR REPLACE TRIGGER emp_before_update
BEFORE UPDATE OF salary ON employees
FOR EACH ROW
BEGIN
    -- Validate salary increase
    IF :NEW.salary < :OLD.salary THEN
        RAISE_APPLICATION_ERROR(-20001, 
            'Salary cannot be decreased');
    END IF;
    
    -- Maximum 50% increase
    IF :NEW.salary > :OLD.salary * 1.5 THEN
        RAISE_APPLICATION_ERROR(-20002,
            'Salary increase cannot exceed 50%');
    END IF;
END;
/

-- Row-level AFTER trigger
CREATE OR REPLACE TRIGGER emp_after_update
AFTER UPDATE OF salary ON employees
FOR EACH ROW
BEGIN
    INSERT INTO emp_audit VALUES (
        emp_audit_seq.NEXTVAL,
        :NEW.employee_id,
        :OLD.salary,
        :NEW.salary,
        SYSDATE,
        USER
    );
END;
/

-- Test the triggers
UPDATE employees 
SET salary = salary * 1.2 
WHERE employee_id = 100;
```

**2. INSTEAD OF Triggers (for Views):**

```sql
-- Create view
CREATE OR REPLACE VIEW emp_dept_view AS
SELECT e.employee_id, e.first_name, e.salary, d.department_name
FROM employees e JOIN departments d ON e.department_id = d.department_id;

-- INSTEAD OF trigger
CREATE OR REPLACE TRIGGER emp_dept_insert
INSTEAD OF INSERT ON emp_dept_view
FOR EACH ROW
DECLARE
    v_dept_id NUMBER;
BEGIN
    -- Get department_id
    SELECT department_id INTO v_dept_id
    FROM departments WHERE department_name = :NEW.department_name;
    
    -- Insert into base table
    INSERT INTO employees (employee_id, first_name, salary, department_id)
    VALUES (:NEW.employee_id, :NEW.first_name, :NEW.salary, v_dept_id);
END;
/

-- Now can insert into view
INSERT INTO emp_dept_view VALUES (999, 'John', 5000, 'IT');
```

**3. DDL Triggers:**

```sql
CREATE TABLE ddl_log (
    log_id NUMBER PRIMARY KEY,
    event_type VARCHAR2(30),
    object_type VARCHAR2(30),
    object_name VARCHAR2(128),
    event_date DATE,
    username VARCHAR2(30)
);

CREATE OR REPLACE TRIGGER schema_ddl_trigger
AFTER CREATE OR ALTER OR DROP ON SCHEMA
BEGIN
    INSERT INTO ddl_log VALUES (
        ddl_log_seq.NEXTVAL,
        ORA_SYSEVENT,
        ORA_DICT_OBJ_TYPE,
        ORA_DICT_OBJ_NAME,
        SYSDATE,
        USER
    );
END;
/
```

**4. System Event Triggers:**

```sql
CREATE OR REPLACE TRIGGER logon_trigger
AFTER LOGON ON SCHEMA
BEGIN
    INSERT INTO login_audit VALUES (USER, SYSDATE, 'LOGIN');
END;
/
```

---

#### Q10: What is the difference between BEFORE and AFTER triggers?

**Answer:**

| Aspect | BEFORE Trigger | AFTER Trigger |
|--------|----------------|---------------|
| **Timing** | Executes before DML | Executes after DML |
| **:NEW/:OLD** | Can modify :NEW values | Cannot modify :NEW values |
| **Use Case** | Validation, derived values | Auditing, cascading changes |
| **Rollback** | Can prevent DML operation | DML already done |

```sql
-- BEFORE Trigger: Validation and derived values
CREATE OR REPLACE TRIGGER emp_before_insert
BEFORE INSERT ON employees
FOR EACH ROW
BEGIN
    -- Auto-generate ID
    IF :NEW.employee_id IS NULL THEN
        SELECT emp_seq.NEXTVAL INTO :NEW.employee_id FROM DUAL;
    END IF;
    
    -- Set hire date
    :NEW.hire_date := SYSDATE;
    
    -- Validate salary
    IF :NEW.salary < 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Invalid salary');
    END IF;
    
    -- Can modify :NEW
    :NEW.email := UPPER(:NEW.email);
END;
/

-- AFTER Trigger: Auditing
CREATE OR REPLACE TRIGGER emp_after_insert
AFTER INSERT ON employees
FOR EACH ROW
BEGIN
    -- Cannot modify :NEW here
    -- :NEW.email := 'test@email.com';  -- ERROR!
    
    -- Audit the insertion
    INSERT INTO emp_audit (employee_id, action, action_date)
    VALUES (:NEW.employee_id, 'INSERT', SYSDATE);
    
    -- Send notification
    DBMS_OUTPUT.PUT_LINE('New employee added: ' || :NEW.first_name);
END;
/
```

---

### Section 5: Packages

#### Q11: What is a Package? Why use packages?

**Answer:**

A **package** is a database object that groups logically related PL/SQL types, variables, procedures, and functions.

**Structure:**
- **Package Specification**: Public interface (declarations)
- **Package Body**: Implementation (definitions)

**Advantages:**
1. **Modularity**: Group related functionality
2. **Easier Maintenance**: Changes in body don't affect specification
3. **Information Hiding**: Public vs private components
4. **Performance**: Loaded into memory once
5. **Overloading**: Multiple subprograms with same name
6. **Global Variables**: Persist for session

```sql
-- Package Specification (Public Interface)
CREATE OR REPLACE PACKAGE employee_mgmt IS
    -- Public constants
    c_min_salary CONSTANT NUMBER := 2000;
    c_max_salary CONSTANT NUMBER := 100000;
    
    -- Public variable
    g_total_employees NUMBER := 0;
    
    -- Public procedures
    PROCEDURE add_employee(
        p_first_name VARCHAR2,
        p_last_name VARCHAR2,
        p_salary NUMBER
    );
    
    PROCEDURE remove_employee(p_emp_id NUMBER);
    
    PROCEDURE update_salary(
        p_emp_id NUMBER,
        p_new_salary NUMBER
    );
    
    -- Public functions
    FUNCTION get_employee_count RETURN NUMBER;
    FUNCTION get_avg_salary RETURN NUMBER;
    FUNCTION validate_salary(p_salary NUMBER) RETURN BOOLEAN;
END employee_mgmt;
/

-- Package Body (Implementation)
CREATE OR REPLACE PACKAGE BODY employee_mgmt IS
    
    -- Private procedure (not in specification)
    PROCEDURE log_activity(p_message VARCHAR2) IS
    BEGIN
        INSERT INTO activity_log VALUES (SYSDATE, p_message);
    END;
    
    -- Private function
    FUNCTION generate_email(p_first_name VARCHAR2, p_last_name VARCHAR2)
    RETURN VARCHAR2 IS
    BEGIN
        RETURN LOWER(p_first_name || '.' || p_last_name || '@company.com');
    END;
    
    -- Public procedure implementation
    PROCEDURE add_employee(
        p_first_name VARCHAR2,
        p_last_name VARCHAR2,
        p_salary NUMBER
    ) IS
        v_email VARCHAR2(100);
    BEGIN
        IF NOT validate_salary(p_salary) THEN
            RAISE_APPLICATION_ERROR(-20001, 'Invalid salary amount');
        END IF;
        
        v_email := generate_email(p_first_name, p_last_name);
        
        INSERT INTO employees (employee_id, first_name, last_name, email, salary)
        VALUES (emp_seq.NEXTVAL, p_first_name, p_last_name, v_email, p_salary);
        
        g_total_employees := g_total_employees + 1;
        log_activity('Added employee: ' || p_first_name || ' ' || p_last_name);
        
        COMMIT;
    END;
    
    PROCEDURE remove_employee(p_emp_id NUMBER) IS
    BEGIN
        DELETE FROM employees WHERE employee_id = p_emp_id;
        g_total_employees := g_total_employees - 1;
        log_activity('Removed employee ID: ' || p_emp_id);
        COMMIT;
    END;
    
    PROCEDURE update_salary(
        p_emp_id NUMBER,
        p_new_salary NUMBER
    ) IS
    BEGIN
        IF NOT validate_salary(p_new_salary) THEN
            RAISE_APPLICATION_ERROR(-20001, 'Invalid salary amount');
        END IF;
        
        UPDATE employees SET salary = p_new_salary WHERE employee_id = p_emp_id;
        log_activity('Updated salary for employee ID: ' || p_emp_id);
        COMMIT;
    END;
    
    FUNCTION get_employee_count RETURN NUMBER IS
        v_count NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_count FROM employees;
        RETURN v_count;
    END;
    
    FUNCTION get_avg_salary RETURN NUMBER IS
        v_avg NUMBER;
    BEGIN
        SELECT AVG(salary) INTO v_avg FROM employees;
        RETURN ROUND(v_avg, 2);
    END;
    
    FUNCTION validate_salary(p_salary NUMBER) RETURN BOOLEAN IS
    BEGIN
        RETURN (p_salary >= c_min_salary AND p_salary <= c_max_salary);
    END;
    
END employee_mgmt;
/

-- Using the package
BEGIN
    -- Call public procedures
    employee_mgmt.add_employee('John', 'Doe', 5000);
    employee_mgmt.update_salary(100, 6000);
    
    -- Access public variables
    DBMS_OUTPUT.PUT_LINE('Total employees: ' || employee_mgmt.g_total_employees);
    
    -- Call public functions
    DBMS_OUTPUT.PUT_LINE('Employee count: ' || employee_mgmt.get_employee_count);
    DBMS_OUTPUT.PUT_LINE('Average salary: $' || employee_mgmt.get_avg_salary);
    
    -- Cannot call private procedures
    -- employee_mgmt.log_activity('test');  -- ERROR: Not visible
END;
/
```

---

### Section 6: Coding Interview Questions

#### Q12: Write a PL/SQL block to find the second highest salary.

**Answer:**

```sql
-- Solution 1: Using subquery
DECLARE
    v_second_highest_salary NUMBER;
BEGIN
    SELECT MAX(salary) INTO v_second_highest_salary
    FROM employees
    WHERE salary < (SELECT MAX(salary) FROM employees);
    
    DBMS_OUTPUT.PUT_LINE('Second Highest Salary: $' || v_second_highest_salary);
END;
/

-- Solution 2: Using ROWNUM
DECLARE
    v_salary NUMBER;
BEGIN
    SELECT salary INTO v_salary
    FROM (
        SELECT DISTINCT salary
        FROM employees
        ORDER BY salary DESC
    )
    WHERE ROWNUM <= 2
    ORDER BY salary
    FETCH FIRST 1 ROW ONLY;
    
    DBMS_OUTPUT.PUT_LINE('Second Highest Salary: $' || v_salary);
END;
/

-- Solution 3: Using NTH_VALUE
DECLARE
    v_salary NUMBER;
BEGIN
    SELECT DISTINCT second_sal INTO v_salary
    FROM (
        SELECT salary,
               NTH_VALUE(salary, 2) OVER (ORDER BY salary DESC) AS second_sal
        FROM employees
    )
    WHERE second_sal IS NOT NULL
    AND ROWNUM = 1;
    
    DBMS_OUTPUT.PUT_LINE('Second Highest Salary: $' || v_salary);
END;
/
```

---

#### Q13: Write a PL/SQL program to find prime numbers between 1 and 100.

**Answer:**

```sql
DECLARE
    v_is_prime BOOLEAN;
    v_count NUMBER := 0;
BEGIN
    DBMS_OUTPUT.PUT_LINE('Prime numbers between 1 and 100:');
    DBMS_OUTPUT.PUT_LINE('==================================');
    
    FOR num IN 2..100 LOOP
        v_is_prime := TRUE;
        
        -- Check if number is divisible by any number from 2 to sqrt(num)
        FOR divisor IN 2..FLOOR(SQRT(num)) LOOP
            IF MOD(num, divisor) = 0 THEN
                v_is_prime := FALSE;
                EXIT;
            END IF;
        END LOOP;
        
        IF v_is_prime THEN
            DBMS_OUTPUT.PUT(num || ' ');
            v_count := v_count + 1;
            
            -- New line after every 10 numbers
            IF MOD(v_count, 10) = 0 THEN
                DBMS_OUTPUT.NEW_LINE;
            END IF;
        END IF;
    END LOOP;
    
    DBMS_OUTPUT.NEW_LINE;
    DBMS_OUTPUT.PUT_LINE('==================================');
    DBMS_OUTPUT.PUT_LINE('Total prime numbers: ' || v_count);
END;
/
```

---

#### Q14: Write a PL/SQL block to print the Fibonacci series up to N terms.

**Answer:**

```sql
DECLARE
    v_n NUMBER := 15;  -- Number of terms
    v_first NUMBER := 0;
    v_second NUMBER := 1;
    v_next NUMBER;
BEGIN
    DBMS_OUTPUT.PUT_LINE('Fibonacci Series (First ' || v_n || ' terms):');
    DBMS_OUTPUT.PUT_LINE('==========================================');
    
    IF v_n >= 1 THEN
        DBMS_OUTPUT.PUT(v_first || ' ');
    END IF;
    
    IF v_n >= 2 THEN
        DBMS_OUTPUT.PUT(v_second || ' ');
    END IF;
    
    FOR i IN 3..v_n LOOP
        v_next := v_first + v_second;
        DBMS_OUTPUT.PUT(v_next || ' ');
        
        v_first := v_second;
        v_second := v_next;
    END LOOP;
    
    DBMS_OUTPUT.NEW_LINE;
END;
/
```

---

#### Q15: Write a PL/SQL block to reverse a string.

**Answer:**

```sql
DECLARE
    v_input VARCHAR2(100) := 'Hello World';
    v_output VARCHAR2(100) := '';
    v_length NUMBER;
BEGIN
    v_length := LENGTH(v_input);
    
    -- Method 1: Using loop
    FOR i IN REVERSE 1..v_length LOOP
        v_output := v_output || SUBSTR(v_input, i, 1);
    END LOOP;
    
    DBMS_OUTPUT.PUT_LINE('Original: ' || v_input);
    DBMS_OUTPUT.PUT_LINE('Reversed: ' || v_output);
    
    -- Method 2: Using REVERSE built-in function (Oracle 10g+)
    DBMS_OUTPUT.PUT_LINE('Using REVERSE: ' || REVERSE(v_input));
END;
/
```

---

#### Q16: Write a PL/SQL program to check if a string is a palindrome.

**Answer:**

```sql
CREATE OR REPLACE FUNCTION is_palindrome(p_string VARCHAR2)
RETURN BOOLEAN
IS
    v_reversed VARCHAR2(1000);
    v_clean_string VARCHAR2(1000);
BEGIN
    -- Remove spaces and convert to uppercase
    v_clean_string := UPPER(REPLACE(p_string, ' ', ''));
    v_reversed := REVERSE(v_clean_string);
    
    RETURN (v_clean_string = v_reversed);
END;
/

-- Test the function
DECLARE
    TYPE string_array IS TABLE OF VARCHAR2(100);
    v_strings string_array := string_array('radar', 'hello', 'madam', 'racecar', 'world', 'A man a plan a canal Panama');
BEGIN
    DBMS_OUTPUT.PUT_LINE('Palindrome Checker:');
    DBMS_OUTPUT.PUT_LINE('===================');
    
    FOR i IN 1..v_strings.COUNT LOOP
        IF is_palindrome(v_strings(i)) THEN
            DBMS_OUTPUT.PUT_LINE('"' || v_strings(i) || '" - IS a palindrome');
        ELSE
            DBMS_OUTPUT.PUT_LINE('"' || v_strings(i) || '" - NOT a palindrome');
        END IF;
    END LOOP;
END;
/
```

---

#### Q17: Write a PL/SQL block to find factorial of a number (both iterative and recursive).

**Answer:**

```sql
-- Iterative approach
CREATE OR REPLACE FUNCTION factorial_iterative(p_num NUMBER)
RETURN NUMBER
IS
    v_result NUMBER := 1;
BEGIN
    IF p_num < 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Factorial not defined for negative numbers');
    END IF;
    
    FOR i IN 1..p_num LOOP
        v_result := v_result * i;
    END LOOP;
    
    RETURN v_result;
END;
/

-- Recursive approach
CREATE OR REPLACE FUNCTION factorial_recursive(p_num NUMBER)
RETURN NUMBER
IS
BEGIN
    IF p_num < 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Factorial not defined for negative numbers');
    ELSIF p_num = 0 OR p_num = 1 THEN
        RETURN 1;
    ELSE
        RETURN p_num * factorial_recursive(p_num - 1);
    END IF;
END;
/

-- Test both functions
DECLARE
    v_number NUMBER := 10;
BEGIN
    DBMS_OUTPUT.PUT_LINE('Factorial of ' || v_number || ':');
    DBMS_OUTPUT.PUT_LINE('Iterative: ' || factorial_iterative(v_number));
    DBMS_OUTPUT.PUT_LINE('Recursive: ' || factorial_recursive(v_number));
    
    -- Test multiple numbers
    DBMS_OUTPUT.NEW_LINE;
    DBMS_OUTPUT.PUT_LINE('Factorial Table:');
    FOR i IN 0..12 LOOP
        DBMS_OUTPUT.PUT_LINE(i || '! = ' || factorial_iterative(i));
    END LOOP;
END;
/
```

---

#### Q18: Write a PL/SQL procedure to remove duplicate rows from a table.

**Answer:**

```sql
-- Create test table
CREATE TABLE test_duplicates (
    id NUMBER,
    name VARCHAR2(50),
    email VARCHAR2(100)
);

-- Insert test data with duplicates
INSERT INTO test_duplicates VALUES (1, 'John', 'john@email.com');
INSERT INTO test_duplicates VALUES (1, 'John', 'john@email.com');
INSERT INTO test_duplicates VALUES (2, 'Jane', 'jane@email.com');
INSERT INTO test_duplicates VALUES (2, 'Jane', 'jane@email.com');
INSERT INTO test_duplicates VALUES (3, 'Bob', 'bob@email.com');
COMMIT;

-- Solution 1: Using ROWID
CREATE OR REPLACE PROCEDURE remove_duplicates_rowid IS
    v_deleted NUMBER;
BEGIN
    DELETE FROM test_duplicates
    WHERE ROWID NOT IN (
        SELECT MIN(ROWID)
        FROM test_duplicates
        GROUP BY id, name, email
    );
    
    v_deleted := SQL%ROWCOUNT;
    COMMIT;
    
    DBMS_OUTPUT.PUT_LINE('Deleted ' || v_deleted || ' duplicate rows');
END;
/

-- Solution 2: Using analytical function
CREATE OR REPLACE PROCEDURE remove_duplicates_analytic IS
    v_deleted NUMBER := 0;
BEGIN
    FOR rec IN (
        SELECT ROWID AS row_id,
               ROW_NUMBER() OVER (PARTITION BY id, name, email ORDER BY ROWID) AS rn
        FROM test_duplicates
    ) LOOP
        IF rec.rn > 1 THEN
            DELETE FROM test_duplicates WHERE ROWID = rec.row_id;
            v_deleted := v_deleted + 1;
        END IF;
    END LOOP;
    
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('Deleted ' || v_deleted || ' duplicate rows');
END;
/

-- Solution 3: Using temporary table
CREATE OR REPLACE PROCEDURE remove_duplicates_temp IS
BEGIN
    -- Create temp table with unique rows
    CREATE TABLE test_duplicates_temp AS
    SELECT DISTINCT * FROM test_duplicates;
    
    -- Truncate original table
    EXECUTE IMMEDIATE 'TRUNCATE TABLE test_duplicates';
    
    -- Insert unique rows back
    INSERT INTO test_duplicates SELECT * FROM test_duplicates_temp;
    
    -- Drop temp table
    DROP TABLE test_duplicates_temp;
    
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('Duplicates removed successfully');
END;
/

-- Test the procedure
BEGIN
    DBMS_OUTPUT.PUT_LINE('Before: ');
    FOR rec IN (SELECT * FROM test_duplicates) LOOP
        DBMS_OUTPUT.PUT_LINE(rec.id || ' - ' || rec.name);
    END LOOP;
    
    remove_duplicates_rowid;
    
    DBMS_OUTPUT.PUT_LINE('After: ');
    FOR rec IN (SELECT * FROM test_duplicates) LOOP
        DBMS_OUTPUT.PUT_LINE(rec.id || ' - ' || rec.name);
    END LOOP;
END;
/
```

---

#### Q19: Write a PL/SQL block to swap two numbers without using a third variable.

**Answer:**

```sql
DECLARE
    v_num1 NUMBER := 10;
    v_num2 NUMBER := 20;
BEGIN
    DBMS_OUTPUT.PUT_LINE('=== Swap Without Third Variable ===');
    DBMS_OUTPUT.PUT_LINE('Before Swap:');
    DBMS_OUTPUT.PUT_LINE('Num1: ' || v_num1);
    DBMS_OUTPUT.PUT_LINE('Num2: ' || v_num2);
    
    -- Method 1: Using arithmetic operations
    v_num1 := v_num1 + v_num2;  -- num1 = 30
    v_num2 := v_num1 - v_num2;  -- num2 = 30 - 20 = 10
    v_num1 := v_num1 - v_num2;  -- num1 = 30 - 10 = 20
    
    DBMS_OUTPUT.PUT_LINE('After Swap:');
    DBMS_OUTPUT.PUT_LINE('Num1: ' || v_num1);
    DBMS_OUTPUT.PUT_LINE('Num2: ' || v_num2);
END;
/

-- Alternative: Using XOR (bitwise) - More efficient
DECLARE
    v_num1 NUMBER := 15;
    v_num2 NUMBER := 25;
BEGIN
    DBMS_OUTPUT.PUT_LINE('=== Swap Using XOR ===');
    DBMS_OUTPUT.PUT_LINE('Before Swap:');
    DBMS_OUTPUT.PUT_LINE('Num1: ' || v_num1);
    DBMS_OUTPUT.PUT_LINE('Num2: ' || v_num2);
    
    v_num1 := v_num1 - v_num2;
    v_num2 := v_num2 + v_num1;
    v_num1 := v_num2 - v_num1;
    
    DBMS_OUTPUT.PUT_LINE('After Swap:');
    DBMS_OUTPUT.PUT_LINE('Num1: ' || v_num1);
    DBMS_OUTPUT.PUT_LINE('Num2: ' || v_num2);
END;
/
```

---

#### Q20: Write a PL/SQL program to display employee hierarchy using recursive query.

**Answer:**

```sql
CREATE OR REPLACE PROCEDURE display_employee_hierarchy(p_manager_id NUMBER DEFAULT NULL) IS
    CURSOR emp_hierarchy_cursor IS
        SELECT 
            employee_id,
            first_name || ' ' || last_name AS full_name,
            job_id,
            manager_id,
            salary,
            LEVEL AS emp_level,
            SYS_CONNECT_BY_PATH(first_name || ' ' || last_name, ' -> ') AS hierarchy_path
        FROM employees
        START WITH manager_id IS NULL
        CONNECT BY PRIOR employee_id = manager_id
        ORDER SIBLINGS BY first_name;
BEGIN
    DBMS_OUTPUT.PUT_LINE('=== EMPLOYEE HIERARCHY ===');
    DBMS_OUTPUT.PUT_LINE('');
    
    FOR emp_rec IN emp_hierarchy_cursor LOOP
        -- Indentation based on level
        DBMS_OUTPUT.PUT(LPAD(' ', (emp_rec.emp_level - 1) * 3));
        
        -- Display employee info
        DBMS_OUTPUT.PUT_LINE('├─ ' || emp_rec.full_name || 
                           ' (' || emp_rec.job_id || ')' ||
                           ' - $' || emp_rec.salary ||
                           ' [Level ' || emp_rec.emp_level || ']');
    END LOOP;
END;
/

-- Alternative: Show only specific branch
CREATE OR REPLACE PROCEDURE show_team_hierarchy(p_manager_id NUMBER) IS
BEGIN
    DBMS_OUTPUT.PUT_LINE('=== TEAM HIERARCHY ===');
    
    FOR emp_rec IN (
        SELECT 
            employee_id,
            first_name || ' ' || last_name AS full_name,
            LEVEL AS emp_level
        FROM employees
        START WITH employee_id = p_manager_id
        CONNECT BY PRIOR employee_id = manager_id
    ) LOOP
        DBMS_OUTPUT.PUT_LINE(
            LPAD('└──', emp_rec.emp_level * 4, '│   ') || ' ' || emp_rec.full_name
        );
    END LOOP;
END;
/

-- Test
BEGIN
    display_employee_hierarchy;
END;
/
```

---

### Section 7: Performance & Optimization Questions

#### Q21: What is BULK COLLECT? How does it improve performance?

**Answer:**

**BULK COLLECT** is a feature that fetches multiple rows at once instead of row-by-row, reducing context switches between PL/SQL and SQL engines.

**Performance Comparison:**

```sql
-- Without BULK COLLECT (Slow - row by row)
DECLARE
    CURSOR emp_cursor IS SELECT employee_id, salary FROM employees;
    v_emp_id NUMBER;
    v_salary NUMBER;
    v_start_time NUMBER;
    v_end_time NUMBER;
BEGIN
    v_start_time := DBMS_UTILITY.GET_TIME;
    
    OPEN emp_cursor;
    LOOP
        FETCH emp_cursor INTO v_emp_id, v_salary;
        EXIT WHEN emp_cursor%NOTFOUND;
        -- Process each row
    END LOOP;
    CLOSE emp_cursor;
    
    v_end_time := DBMS_UTILITY.GET_TIME;
    DBMS_OUTPUT.PUT_LINE('Time without BULK COLLECT: ' || 
                        (v_end_time - v_start_time) || ' centiseconds');
END;
/

-- With BULK COLLECT (Fast - all at once)
DECLARE
    TYPE emp_id_tab IS TABLE OF employees.employee_id%TYPE;
    TYPE salary_tab IS TABLE OF employees.salary%TYPE;
    
    v_emp_ids emp_id_tab;
    v_salaries salary_tab;
    v_start_time NUMBER;
    v_end_time NUMBER;
BEGIN
    v_start_time := DBMS_UTILITY.GET_TIME;
    
    SELECT employee_id, salary
    BULK COLLECT INTO v_emp_ids, v_salaries
    FROM employees;
    
    -- Process all rows
    FOR i IN 1..v_emp_ids.COUNT LOOP
        NULL; -- Process
    END LOOP;
    
    v_end_time := DBMS_UTILITY.GET_TIME;
    DBMS_OUTPUT.PUT_LINE('Time with BULK COLLECT: ' || 
                        (v_end_time - v_start_time) || ' centiseconds');
    DBMS_OUTPUT.PUT_LINE('Records processed: ' || v_emp_ids.COUNT);
END;
/

-- BULK COLLECT with LIMIT (for large datasets)
DECLARE
    TYPE emp_tab IS TABLE OF employees%ROWTYPE;
    v_employees emp_tab;
    
    CURSOR emp_cursor IS SELECT * FROM employees;
    c_limit CONSTANT PLS_INTEGER := 100; -- Fetch 100 rows at a time
BEGIN
    OPEN emp_cursor;
    
    LOOP
        FETCH emp_cursor BULK COLLECT INTO v_employees LIMIT c_limit;
        EXIT WHEN v_employees.COUNT = 0;
        
        -- Process batch
        FOR i IN 1..v_employees.COUNT LOOP
            DBMS_OUTPUT.PUT_LINE(v_employees(i).first_name);
        END LOOP;
    END LOOP;
    
    CLOSE emp_cursor;
END;
/
```

**FORALL with BULK COLLECT:**

```sql
-- Update multiple rows efficiently
DECLARE
    TYPE emp_id_tab IS TABLE OF NUMBER;
    v_emp_ids emp_id_tab := emp_id_tab(100, 101, 102, 103, 104);
    v_start_time NUMBER;
    v_end_time NUMBER;
BEGIN
    v_start_time := DBMS_UTILITY.GET_TIME;
    
    -- Bulk update using FORALL
    FORALL i IN v_emp_ids.FIRST..v_emp_ids.LAST
        UPDATE employees
        SET salary = salary * 1.10
        WHERE employee_id = v_emp_ids(i);
    
    v_end_time := DBMS_UTILITY.GET_TIME;
    
    DBMS_OUTPUT.PUT_LINE('Rows updated: ' || SQL%ROWCOUNT);
    DBMS_OUTPUT.PUT_LINE('Time taken: ' || (v_end_time - v_start_time) || ' cs');
    
    ROLLBACK; -- Undo changes for demo
END;
/
```

**Benefits:**
- ✓ Reduces context switches (10x-100x faster)
- ✓ Processes large datasets efficiently
- ✓ Lower memory usage with LIMIT clause
- ✓ Better performance for bulk DML operations

---

#### Q22: Explain the difference between COUNT(*) and COUNT(column_name).

**Answer:**

```sql
-- Create test table with NULL values
CREATE TABLE test_count (
    id NUMBER,
    name VARCHAR2(50)
);

INSERT INTO test_count VALUES (1, 'John');
INSERT INTO test_count VALUES (2, NULL);
INSERT INTO test_count VALUES (3, 'Jane');
INSERT INTO test_count VALUES (4, NULL);
INSERT INTO test_count VALUES (5, 'Bob');
COMMIT;

-- Demonstrate difference
DECLARE
    v_count_star NUMBER;
    v_count_name NUMBER;
    v_count_id NUMBER;
BEGIN
    -- COUNT(*) - counts all rows including NULLs
    SELECT COUNT(*) INTO v_count_star FROM test_count;
    
    -- COUNT(column) - counts non-NULL values only
    SELECT COUNT(name) INTO v_count_name FROM test_count;
    
    -- COUNT(column) - on NOT NULL column
    SELECT COUNT(id) INTO v_count_id FROM test_count;
    
    DBMS_OUTPUT.PUT_LINE('COUNT(*): ' || v_count_star);      -- 5
    DBMS_OUTPUT.PUT_LINE('COUNT(name): ' || v_count_name);  -- 3
    DBMS_OUTPUT.PUT_LINE('COUNT(id): ' || v_count_id);      -- 5
    
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('Explanation:');
    DBMS_OUTPUT.PUT_LINE('- COUNT(*) counts all rows (5 total)');
    DBMS_OUTPUT.PUT_LINE('- COUNT(name) counts non-NULL names (3 values)');
    DBMS_OUTPUT.PUT_LINE('- COUNT(id) counts all IDs (5 values, no NULLs)');
END;
/
```

**Key Differences:**

| Feature | COUNT(*) | COUNT(column) |
|---------|----------|---------------|
| **NULL handling** | Includes NULLs | Excludes NULLs |
| **Performance** | Faster (doesn't check values) | Slower (checks each value) |
| **Use case** | Total row count | Count of non-NULL values |

---

### Section 8: Scenario-Based Questions

#### Q23: A table has duplicate records. Write a query to find and display duplicates.

**Answer:**

```sql
-- Create test table with duplicates
CREATE TABLE employees_dup (
    employee_id NUMBER,
    first_name VARCHAR2(50),
    last_name VARCHAR2(50),
    email VARCHAR2(100),
    department_id NUMBER
);

-- Insert test data
INSERT INTO employees_dup VALUES (1, 'John', 'Doe', 'john@email.com', 10);
INSERT INTO employees_dup VALUES (1, 'John', 'Doe', 'john@email.com', 10);
INSERT INTO employees_dup VALUES (2, 'Jane', 'Smith', 'jane@email.com', 20);
INSERT INTO employees_dup VALUES (3, 'Bob', 'Johnson', 'bob@email.com', 10);
INSERT INTO employees_dup VALUES (3, 'Bob', 'Johnson', 'bob@email.com', 10);
INSERT INTO employees_dup VALUES (3, 'Bob', 'Johnson', 'bob@email.com', 10);
COMMIT;

-- Solution: Find and display duplicates
CREATE OR REPLACE PROCEDURE find_duplicates IS
BEGIN
    DBMS_OUTPUT.PUT_LINE('=== DUPLICATE RECORDS ===');
    DBMS_OUTPUT.PUT_LINE('');
    
    FOR rec IN (
        SELECT 
            employee_id,
            first_name,
            last_name,
            email,
            COUNT(*) AS duplicate_count
        FROM employees_dup
        GROUP BY employee_id, first_name, last_name, email
        HAVING COUNT(*) > 1
        ORDER BY duplicate_count DESC
    ) LOOP
        DBMS_OUTPUT.PUT_LINE(
            'ID: ' || rec.employee_id || 
            ', Name: ' || rec.first_name || ' ' || rec.last_name ||
            ', Count: ' || rec.duplicate_count
        );
    END LOOP;
    
    DBMS_OUTPUT.PUT_LINE('');
    
    -- Show detailed view with ROW_NUMBER
    DBMS_OUTPUT.PUT_LINE('=== DETAILED VIEW WITH ROW NUMBERS ===');
    FOR rec IN (
        SELECT 
            employee_id,
            first_name,
            last_name,
            ROWID,
            ROW_NUMBER() OVER (
                PARTITION BY employee_id, first_name, last_name 
                ORDER BY ROWID
            ) AS row_num
        FROM employees_dup
    ) LOOP
        IF rec.row_num > 1 THEN
            DBMS_OUTPUT.PUT_LINE(
                'Duplicate: ID=' || rec.employee_id ||
                ', Name=' || rec.first_name || ' ' || rec.last_name ||
                ', Row#=' || rec.row_num ||
                ', ROWID=' || rec.ROWID
            );
        END IF;
    END LOOP;
END;
/

-- Execute
BEGIN
    find_duplicates;
END;
/
```

---

This comprehensive guide covers PL/SQL from basics to advanced topics with detailed theory, practical examples, and interview questions with solutions!
