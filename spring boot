# Spring Boot Complete Guide: Interview Questions & Answers

## Comprehensive Theory Foundation

### Java Enterprise Application Development

**Evolution of Java Enterprise Development**:

**Phase 1: EJBs (Enterprise JavaBeans) - 1997**
- Heavy, complex, required application server
- Remote calls, distributed objects
- Difficult to test

**Phase 2: Spring Framework - 2004**
- Lightweight alternative to EJBs
- Introduced IoC and DI
- POJO (Plain Old Java Objects)

**Phase 3: Spring Boot - 2014**
- Simplified Spring configuration
- Convention over Configuration
- Embedded servers, auto-configuration
- Production-ready out of box

### Core Programming Paradigms in Spring

**1. Object-Oriented Programming (OOP)**
- Classes and Objects
- Inheritance
- Polymorphism
- Encapsulation

**2. Functional Programming (Java 8+)**
- Lambda expressions
- Streams API
- Immutability
- Function composition

**3. Reactive Programming (Spring WebFlux)**
- Non-blocking I/O
- Backpressure
- Event-driven
- Better resource utilization

### Design Principles in Spring Architecture

**SOLID Principles**:

1. **Single Responsibility Principle (SRP)**
   - Each class has one reason to change
   - Example: UserService handles user logic, UserRepository handles data access

2. **Open/Closed Principle (OCP)**
   - Open for extension, closed for modification
   - Use interfaces for extensibility
   ```java
   public interface PaymentProcessor {
       boolean process(Payment payment);
   }
   // New payment types: add new implementations, no changes to existing code
   ```

3. **Liskov Substitution Principle (LSP)**
   - Subclasses should be substitutable for parent classes
   - Derived classes follow parent contract
   ```java
   List<Vehicle> vehicles = Arrays.asList(
       new Car(), new Truck(), new Bus()
   );
   // All can be used interchangeably
   ```

4. **Interface Segregation Principle (ISP)**
   - Don't force clients to depend on interfaces they don't use
   ```java
   // Bad
   public interface Worker {
       void work();
       void eat();
   }
   
   // Good
   public interface Employee {
       void work();
   }
   public interface Eater {
       void eat();
   }
   ```

5. **Dependency Inversion Principle (DIP)**
   - Depend on abstractions, not concrete implementations
   - High-level modules shouldn't depend on low-level modules
   ```java
   // Bad: Depends on concrete UserRepositoryImpl
   UserService userService = new UserService(new UserRepositoryImpl());
   
   // Good: Depends on UserRepository interface
   @Autowired
   private UserRepository userRepository;
   ```

### Enterprise Application Architecture Patterns

**Common Architectural Patterns**:

**1. Layered Architecture (N-Tier)**
```
┌────────────────────────────┐
│  Presentation Layer        │
│ (Controllers, Views)       │
├────────────────────────────┤
│  Application Layer         │
│ (Services, DTOs)           │
├────────────────────────────┤
│  Business Logic Layer      │
│ (Entities, Validators)     │
├────────────────────────────┤
│  Persistence Layer         │
│ (Repositories, DAOs)       │
├────────────────────────────┤
│  Database Layer            │
│ (SQL, Transactions)        │
└────────────────────────────┘
```

**2. Hexagonal Architecture (Ports & Adapters)**
```
                External Systems
                     ↑ ↓
                  [Adapters]
                     ↑ ↓
            ╔════════════════════╗
            ║   Application Core ║
            ║  (Business Logic)  ║
            ║   [Ports/Interfaces]
            ╚════════════════════╝
                     ↑ ↓
                  [Adapters]
                     ↑ ↓
                External Systems
```

**3. Event-Driven Architecture**
```
Event Source → Event Channel → Event Processor → Event Sink

Example: User Registration
  Registration Event
       ↓
  Event Bus/Message Queue
       ↓
  Email Service (Listen)
  Notification Service (Listen)
  Analytics Service (Listen)
```

### Request Processing Lifecycle in Spring Boot

**Complete Request Flow**:
```
1. HTTP Request Arrives
   ↓
2. DispatcherServlet (Front Controller)
   ├─ Receives all requests
   ├─ Central routing point
   ↓
3. HandlerMapping
   ├─ Identifies matching controller method
   ├─ Uses @RequestMapping annotations
   ↓
4. Handler Interceptors (Pre-Processing)
   ├─ preHandle()
   ├─ Security checks
   ├─ Logging
   ↓
5. Method Parameter Resolution
   ├─ @PathVariable extraction
   ├─ @RequestParam binding
   ├─ @RequestBody deserialization
   ├─ Type conversion
   ↓
6. Validation
   ├─ @Valid annotation checking
   ├─ Bean Validation Constraints
   ├─ Custom validators
   ↓
7. Interceptors (Around)
   ├─ preHandle() after validation
   ↓
8. Controller Method Execution
   ├─ AOP Aspects applied
   ├─ Business logic executed
   ├─ Transactions managed
   ↓
9. Response Processing
   ├─ HttpMessageConverter selection
   ├─ JSON serialization
   ├─ Headers added
   ↓
10. Interceptors (Post-Processing)
    ├─ postHandle()
    ├─ afterCompletion()
    ↓
11. View Resolution (if needed)
    ├─ Template rendering
    ↓
12. HTTP Response Returned
```

### Spring Container & Bean Management

**Application Context Hierarchy**:
```
┌─────────────────────────────────────┐
│   ApplicationContext (Root)         │
│  (Global, Singleton beans)          │
│                                     │
│  ┌───────────────────────────────┐  │
│  │  WebApplicationContext        │  │
│  │  (Web layer specific)         │  │
│  │  (Servlet, Request scoped)    │  │
│  └───────────────────────────────┘  │
└─────────────────────────────────────┘
```

**Bean Creation Process**:
```
1. Instantiation
   ├─ Constructor called
   ↓
2. Property Population (Dependency Injection)
   ├─ Setter injection
   ├─ Field injection
   ↓
3. Bean Name Aware
   ├─ setBeanName() called
   ↓
4. Bean Factory Aware
   ├─ setBeanFactory() called
   ↓
5. Application Context Aware
   ├─ setApplicationContext() called
   ↓
6. BeanPostProcessor - PreInitialization
   ├─ postProcessBeforeInitialization()
   ↓
7. Initialization
   ├─ @PostConstruct method
   ├─ afterPropertiesSet()
   ├─ init-method
   ↓
8. BeanPostProcessor - PostInitialization
   ├─ postProcessAfterInitialization()
   ├─ Create proxy if needed (AOP)
   ↓
9. Bean Ready
   ├─ Available for injection
   ↓
10. Destruction (Container Shutdown)
    ├─ @PreDestroy
    ├─ destroy()
    ├─ destroy-method
```

### Concurrency & Thread Safety in Spring

**Thread Safety Considerations**:

**Singleton Scope Issues**:
```java
// Problem: Shared mutable state
@Service
public class UserService {
    private User currentUser;  // DANGER: Shared across threads
    
    public void process(User user) {
        this.currentUser = user;  // Thread A writes
        // Thread B reads different user!
    }
}

// Solution: Use constructor injection with immutable fields
@Service
public class UserService {
    private final UserRepository userRepository;  // Immutable
    
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

**Database Connection Pooling**:
- HikariCP (Default): Thread-safe, efficient
- Connection pool size important for throughput
- Connections reused across requests

### Performance Optimization Concepts

**Performance Considerations**:
```
Query Performance
├─ Database indexing
├─ Query optimization
├─ N+1 query problem
└─ Caching

Network Performance
├─ HTTP compression
├─ Caching headers
├─ Async operations
└─ Connection pooling

Memory Performance
├─ Object pooling
├─ Garbage collection tuning
├─ Heap size configuration
└─ Memory leaks prevention

Concurrency Performance
├─ Thread pool sizing
├─ Lock contention
├─ Reactive programming
└─ Load balancing
```

---

## Table of Contents
1. [Spring Boot Basics](#spring-boot-basics)
2. [Core Concepts](#core-concepts)
3. [Dependency Injection & IoC](#dependency-injection--ioc)
4. [REST APIs](#rest-apis)
5. [Database & JPA](#database--jpa)
6. [Security](#security)
7. [Testing](#testing)
8. [Microservices](#microservices)
9. [Advanced Topics](#advanced-topics)
10. [Common Interview Questions](#common-interview-questions)

---

## Concepts & Theory

### The Spring Ecosystem

The Spring Framework is a comprehensive enterprise application development framework built on several core principles:

**Layered Architecture**:
```
┌─────────────────────────────────────────┐
│      Presentation Layer (UI/Web)        │
│  Controllers, REST Endpoints, Views      │
├─────────────────────────────────────────┤
│       Business Logic Layer               │
│   Services, Validators, Transformers     │
├─────────────────────────────────────────┤
│       Persistence Layer (Database)       │
│   Repositories, DAOs, Entities           │
├─────────────────────────────────────────┤
│       Infrastructure Layer               │
│   Configuration, Security, Logging       │
└─────────────────────────────────────────┘
```

**Spring Framework Pillars**:
1. **Inversion of Control (IoC)**: Framework manages object creation
2. **Dependency Injection (DI)**: Objects receive dependencies from outside
3. **Aspect-Oriented Programming (AOP)**: Cross-cutting concerns separation
4. **Convention over Configuration**: Default behaviors reduce setup

### Spring vs Spring Boot

| Aspect | Spring Framework | Spring Boot |
|--------|------------------|------------|
| Configuration | XML/Annotations (verbose) | Auto-configuration (minimal) |
| Server | External (Tomcat, Jetty) | Embedded |
| Dependencies | Manual management | Starters (pre-configured) |
| Deployment | WAR file | JAR file |
| Development Speed | Slower (more setup) | Faster (conventions) |
| Learning Curve | Steep | Moderate |

### Key Architectural Patterns in Spring Boot

**1. MVC Pattern (Model-View-Controller)**:
- **Model**: Data objects (Entities, DTOs)
- **View**: HTTP Response (JSON, XML, HTML)
- **Controller**: Handles requests, coordinates business logic

**2. DAO Pattern (Data Access Object)**:
- Separates business logic from data access
- Simplifies testing through abstraction
- Example: Spring Data JPA repositories

**3. Service Locator Pattern**:
- Spring's registry of managed beans
- ApplicationContext acts as service locator

**4. Singleton Pattern**:
- Default bean scope
- One instance per container (thread-safe)
- Reduces memory overhead

---

## Spring Boot Basics

### Q1: What is Spring Boot?
**A:** Spring Boot is an opinionated framework that simplifies the development of standalone, production-ready Spring applications. It provides:
- Auto-configuration
- Embedded servers (Tomcat, Jetty)
- Starter dependencies
- Simplified configuration
- Actuators for monitoring

```java
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

### Q2: What are the advantages of Spring Boot?
**A:**
1. **Auto-Configuration**: Automatically configures Spring and third-party libraries
2. **Embedded Servers**: No need for external application server
3. **Production Ready**: Out-of-the-box features like metrics and health checks
4. **Starter Dependencies**: Simplified Maven/Gradle configuration
5. **Convention over Configuration**: Reduces boilerplate code
6. **Microservices Friendly**: Lightweight and fast startup
7. **CLI Tool**: Command-line tool for rapid development
8. **No XML Configuration**: Annotation-based configuration

### Q3: What is @SpringBootApplication?
**A:** `@SpringBootApplication` is a convenience annotation that combines:
- `@Configuration`: Marks the class as a configuration class
- `@EnableAutoConfiguration`: Enables Spring Boot's auto-configuration
- `@ComponentScan`: Scans for components in the package and sub-packages

```java
@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

### Q4: What are Spring Boot Starters?
**A:** Starters are dependency descriptors that simplify Maven/Gradle configuration. They provide all necessary dependencies for a feature.

Common starters:
- `spring-boot-starter-web`: Web and MVC support
- `spring-boot-starter-data-jpa`: JPA and database support
- `spring-boot-starter-security`: Spring Security
- `spring-boot-starter-test`: Testing support

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

---

## Core Concepts

### Understanding IoC & Dependency Injection

**Inversion of Control (IoC) - Theory**:

IoC inverts the flow of control. Instead of the application controlling object creation, a container (Spring) manages it.

**Without IoC (Tight Coupling)**:
```java
public class UserService {
    private UserRepository userRepository = new UserRepositoryImpl();
    
    // Problems:
    // - Hard to test (can't mock UserRepository)
    // - Tight coupling
    // - Can't switch implementations easily
}
```

**With IoC (Loose Coupling)**:
```java
public class UserService {
    private UserRepository userRepository;
    
    // Constructor injection - dependency provided externally
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    // Benefits:
    // - Easy to test (inject mock)
    // - Loose coupling
    // - Can switch implementations
}
```

**Dependency Injection Flow**:
```
1. Define Interface/Abstraction
2. Create Implementations
3. Annotate with @Component, @Service, etc.
4. Spring creates instances
5. Spring resolves dependencies
6. Injects via constructor/setter/field
7. Bean ready to use
```

**DI Containers Responsibility**:
- Creates objects (Beans)
- Manages object lifecycle
- Resolves dependencies
- Handles configuration
- Provides singleton management

### Q5: What is Auto-Configuration in Spring Boot?
**A:** Auto-configuration automatically configures the Spring application based on:
- Jar files present on the classpath
- Annotations present in the code
- Properties defined in `application.properties`/`application.yml`

It uses `@ConditionalOnClass`, `@ConditionalOnMissingBean`, etc.

```java
@Configuration
@ConditionalOnClass(DataSource.class)
public class DataSourceConfiguration {
    @Bean
    @ConditionalOnMissingBean
    public DataSource dataSource() {
        return new HikariDataSource();
    }
}
```

### Q6: How do you override Auto-Configuration?
**A:**
1. **Using @Configuration class**:
```java
@Configuration
public class CustomConfig {
    @Bean
    public DataSource dataSource() {
        // Custom DataSource
        return new CustomDataSource();
    }
}
```

2. **Using application.properties**:
```properties
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=password
```

3. **Using @SpringBootApplication exclude**:
```java
@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
public class Application {
}
```

### Q7: What is application.properties vs application.yml?
**A:** Both are configuration files but with different formats:

**application.properties**:
```properties
server.port=8080
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.jpa.hibernate.ddl-auto=update
```

**application.yml**:
```yaml
server:
  port: 8080
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mydb
  jpa:
    hibernate:
      ddl-auto: update
```

YAML is more readable for nested properties.

### Q8: What is Spring Boot Actuator?
**A:** Spring Boot Actuator provides production-ready features like monitoring and management endpoints.

Add dependency:
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

Common endpoints:
- `/actuator/health`: Application health
- `/actuator/metrics`: Application metrics
- `/actuator/env`: Environment properties
- `/actuator/beans`: All beans
- `/actuator/threaddump`: Thread information

Enable all endpoints:
```properties
management.endpoints.web.exposure.include=*
```

---

## Dependency Injection & IoC

### Q9: What is Dependency Injection (DI)?
**A:** DI is a design pattern where objects receive their dependencies from external sources instead of creating them.

**Types of DI:**
1. **Constructor Injection** (Recommended):
```java
@Service
public class UserService {
    private final UserRepository userRepository;
    
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

2. **Setter Injection**:
```java
@Service
public class UserService {
    private UserRepository userRepository;
    
    @Autowired
    public void setUserRepository(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

3. **Field Injection** (Not recommended):
```java
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;
}
```

### Q10: What is Inversion of Control (IoC) Container?
**A:** IoC Container manages object creation, configuration, and dependency resolution. In Spring, it's the ApplicationContext.

```java
ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
UserService userService = context.getBean(UserService.class);
```

**Features:**
- Bean creation and lifecycle management
- Dependency injection
- Configuration management
- Event handling

### Q11: What are Bean Scopes in Spring?
**A:** Bean scope defines the lifecycle and visibility of beans:

1. **Singleton** (Default): One instance per container
```java
@Bean
@Scope("singleton")
public UserService userService() {
    return new UserService();
}
```

2. **Prototype**: New instance every time
```java
@Bean
@Scope("prototype")
public UserService userService() {
    return new UserService();
}
```

3. **Request**: One instance per HTTP request (web)
```java
@Bean
@Scope("request")
public RequestData requestData() {
    return new RequestData();
}
```

4. **Session**: One instance per session (web)
```java
@Bean
@Scope("session")
public UserSession userSession() {
    return new UserSession();
}
```

### Q12: What is @Component, @Service, @Repository, @Controller?
**A:** These are stereotype annotations for different layers:

```java
// Generic component
@Component
public class UtilityClass {
}

// Business logic layer
@Service
public class UserService {
}

// Data access layer
@Repository
public class UserRepository {
}

// Presentation layer
@RestController
public class UserController {
}
```

All are specializations of `@Component` and enable component scanning.

---

## REST APIs - Concepts & Theory

### RESTful Architecture Principles

**REST (Representational State Transfer) - Key Principles**:

1. **Client-Server Architecture**: Separation of concerns
   - Client: Handles UI/UX
   - Server: Handles business logic

2. **Statelessness**: Each request contains all information
   - No session data stored on server
   - Improves scalability
   - Enables horizontal scaling

3. **Resource-Based**: Everything is a resource (identified by URI)
   ```
   /api/users        → User resource collection
   /api/users/123    → Specific user resource
   /api/users/123/posts → Nested resources
   ```

4. **HTTP Methods (Verbs)**: Standard operations
   ```
   GET    → Retrieve resource (Safe, Idempotent)
   POST   → Create resource (Not safe, Not idempotent)
   PUT    → Replace resource (Idempotent)
   PATCH  → Partial update (Not necessarily idempotent)
   DELETE → Remove resource (Idempotent)
   ```

5. **Representation**: Resources in different formats
   - JSON, XML, HTML

6. **HATEOAS** (Hypermedia As The Engine Of Application State):
   ```json
   {
     "id": 1,
     "name": "John",
     "links": [
       {"rel": "self", "href": "/api/users/1"},
       {"rel": "all-users", "href": "/api/users"}
     ]
   }
   ```

**HTTP Status Codes - Semantics**:
```
1xx Informational
  100 Continue
  101 Switching Protocols

2xx Success
  200 OK              - Request successful, return data
  201 Created         - Resource created successfully
  202 Accepted        - Request accepted for processing
  204 No Content      - Success but no content to return

3xx Redirection
  301 Moved Permanently
  302 Found
  304 Not Modified

4xx Client Error (Client's fault)
  400 Bad Request     - Malformed request
  401 Unauthorized    - No authentication
  403 Forbidden       - Authenticated but no permission
  404 Not Found       - Resource doesn't exist
  409 Conflict        - Request conflicts with current state

5xx Server Error (Server's fault)
  500 Internal Server Error
  502 Bad Gateway
  503 Service Unavailable
```

### Request/Response Cycle

```
Client Request:
┌─────────────────────┐
│ HTTP Method (GET)   │
│ URL (/api/users/1)  │
│ Headers             │
│ Body (optional)     │
└─────────────────────┘
         ↓
   Spring Routing
         ↓
   Parameter Binding
         ↓
   Validation
         ↓
   Business Logic
         ↓
   Response Creation
         ↓
Server Response:
┌──────────────────────┐
│ Status Code (200)    │
│ Headers              │
│ Body (JSON/XML)      │
└──────────────────────┘
```

### Q13: What is @RestController?
**A:** `@RestController` combines `@Controller` and `@ResponseBody`. It indicates the class handles REST requests and returns JSON by default.

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        return new User(id, "John");
    }
}
```

### Q14: What are HTTP Status Codes in REST?
**A:**
- **2xx Success**:
  - 200: OK
  - 201: Created
  - 204: No Content

- **4xx Client Error**:
  - 400: Bad Request
  - 401: Unauthorized
  - 403: Forbidden
  - 404: Not Found

- **5xx Server Error**:
  - 500: Internal Server Error
  - 502: Bad Gateway
  - 503: Service Unavailable

### Q15: How do you handle exceptions in Spring Boot?
**A:** Using `@ExceptionHandler`:

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException ex) {
        ErrorResponse error = new ErrorResponse(
            "User not found",
            ex.getMessage(),
            HttpStatus.NOT_FOUND.value()
        );
        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGlobalException(Exception ex) {
        ErrorResponse error = new ErrorResponse(
            "Internal Server Error",
            ex.getMessage(),
            HttpStatus.INTERNAL_SERVER_ERROR.value()
        );
        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
```

### Q16: What is ResponseEntity?
**A:** `ResponseEntity` is used to create HTTP responses with status code, headers, and body.

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody User user) {
        User savedUser = userService.save(user);
        return new ResponseEntity<>(savedUser, HttpStatus.CREATED);
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        User user = userService.findById(id);
        if (user != null) {
            return ResponseEntity.ok(user);
        }
        return ResponseEntity.notFound().build();
    }
}
```

### Q17: What are different HTTP methods and their meanings?
**A:**
- **GET**: Retrieve resource (Safe, Idempotent)
- **POST**: Create resource (Not safe, Not idempotent)
- **PUT**: Update resource completely (Idempotent)
- **PATCH**: Partial update (Not necessarily idempotent)
- **DELETE**: Remove resource (Idempotent)
- **HEAD**: Like GET but without response body
- **OPTIONS**: Describes communication options

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @GetMapping
    public List<User> getAllUsers() { }
    
    @PostMapping
    public User createUser(@RequestBody User user) { }
    
    @PutMapping("/{id}")
    public User updateUser(@PathVariable Long id, @RequestBody User user) { }
    
    @PatchMapping("/{id}")
    public User partialUpdate(@PathVariable Long id, @RequestBody Map<String, Object> updates) { }
    
    @DeleteMapping("/{id}")
    public void deleteUser(@PathVariable Long id) { }
}
```

---

## Database & JPA - Concepts & Theory

### Object-Relational Mapping (ORM) Concepts

**The Impedance Mismatch Problem**:

Object-oriented systems and relational databases have different paradigms:

| Object-Oriented | Relational |
|-----------------|-----------|
| Classes | Tables |
| Objects (instances) | Rows |
| Properties | Columns |
| Inheritance | Normalization |
| Composition | Foreign Keys |
| Methods | N/A |

**ORM Solution**: Bridge the gap between objects and relational data

**How ORM Works**:
```
Java Code (Object Domain)
     ↓
Mapping Configuration (Annotations)
     ↓
ORM Engine (Hibernate)
     ↓
SQL Generation
     ↓
Database Operations
     ↓
Result Set
     ↓
Object Mapping
     ↓
Java Objects
```

### Entity Lifecycle Management

**Entity States**:

```
┌─────────────┐
│ Transient   │  New object, not in DB, not managed by JPA
│             │  → No @Id value
└──────┬──────┘
       │ save()/persist()
       ↓
┌─────────────┐
│  Managed    │  In DB, tracked by Persistence Context
│             │  → Changes auto-reflected
└──────┬──────┘
       │
       │ detach()/close session
       ↓
┌─────────────┐
│ Detached    │  Was managed, now outside Persistence Context
│             │  → Changes not tracked
└──────┬──────┘
       │ merge()
       ↓
┌─────────────┐
│  Managed    │  Re-attached to Persistence Context
│             │
└─────────────┘
       │ remove()
       ↓
┌─────────────┐
│  Removed    │  Marked for deletion from DB
│             │
└─────────────┘
```

**Persistence Context** (aka Session):
- Container for managed entities
- Tracks changes to entities
- Implements Unit of Work pattern
- Flushes changes to database

### Database Transactions

**ACID Properties**:

1. **Atomicity**: Transaction all-or-nothing
   - Either all operations succeed or all rollback
   - Example: Money transfer (debit + credit both succeed)

2. **Consistency**: Data validity maintained
   - Database moves from valid state to valid state
   - Constraints enforced

3. **Isolation**: Concurrent transactions don't interfere
   - Levels: READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE
   
4. **Durability**: Committed data persists
   - Survives system failures

**Isolation Levels & Problems**:
```
Level                  Dirty Read  Non-Repeatable  Phantom
─────────────────────────────────────────────────────────
READ_UNCOMMITTED       Yes         Yes             Yes
READ_COMMITTED         No          Yes             Yes
REPEATABLE_READ        No          No              Yes
SERIALIZABLE           No          No              No
```

**Transaction Propagation in Spring**:
```java
@Transactional(propagation = Propagation.REQUIRED)
// Use existing or create new transaction

@Transactional(propagation = Propagation.REQUIRES_NEW)
// Always create new transaction, suspend existing

@Transactional(propagation = Propagation.SUPPORTS)
// Use existing if available, non-transactional if not

@Transactional(propagation = Propagation.NOT_SUPPORTED)
// Execute without transaction
```

### Q18: What is JPA (Java Persistence API)?
**A:** JPA is a specification for ORM (Object-Relational Mapping) that provides:
- Mapping Java objects to database tables
- CRUD operations
- Query language (JPQL)
- Transaction management

**Common Implementations:** Hibernate, EclipseLink

### Q19: What is Spring Data JPA?
**A:** Spring Data JPA is an abstraction layer over JPA that simplifies database operations.

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    User findByEmail(String email);
    List<User> findByAgeGreaterThan(int age);
    List<User> findByNameContainsIgnoreCase(String name);
}
```

### Q20: How do you define Entity in Spring Boot?
**A:** Using `@Entity` annotation:

```java
@Entity
@Table(name = "users")
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, unique = true)
    private String email;
    
    @Column(nullable = false)
    private String name;
    
    @Column(name = "created_at")
    @Temporal(TemporalType.TIMESTAMP)
    private LocalDateTime createdAt;
    
    @Transient
    private String temporaryField;
}
```

### Q21: What are relationships in JPA?
**A:**

**One-to-Many**:
```java
@Entity
public class Department {
    @Id
    private Long id;
    private String name;
    
    @OneToMany(mappedBy = "department", cascade = CascadeType.ALL)
    private List<Employee> employees;
}

@Entity
public class Employee {
    @Id
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "department_id")
    private Department department;
}
```

**Many-to-Many**:
```java
@Entity
public class Student {
    @Id
    private Long id;
    
    @ManyToMany
    @JoinTable(
        name = "student_course",
        joinColumns = @JoinColumn(name = "student_id"),
        inverseJoinColumns = @JoinColumn(name = "course_id")
    )
    private Set<Course> courses;
}
```

### Q22: What is @Transactional?
**A:** `@Transactional` manages database transactions:

```java
@Service
public class UserService {
    
    @Transactional
    public void transferMoney(Long fromId, Long toId, BigDecimal amount) {
        User from = userRepository.findById(fromId).orElseThrow();
        User to = userRepository.findById(toId).orElseThrow();
        
        from.deductBalance(amount);
        to.addBalance(amount);
        
        // Automatically commits if no exception
        // Rolls back if exception occurs
    }
}
```

**Propagation Types**:
- `REQUIRED`: Use existing or create new
- `REQUIRES_NEW`: Create new, suspend existing
- `SUPPORTS`: Join if exists
- `NOT_SUPPORTED`: Execute without transaction

```java
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void criticalOperation() {
}
```

### Q23: What is Pagination and Sorting in Spring Data JPA?
**A:**

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Page<User> findAll(Pageable pageable);
    List<User> findAll(Sort sort);
}

@Service
public class UserService {
    
    public Page<User> getUsers(int page, int size, String sortBy, String direction) {
        Sort sort = Sort.by(Sort.Direction.fromString(direction), sortBy);
        Pageable pageable = PageRequest.of(page, size, sort);
        return userRepository.findAll(pageable);
    }
}

@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @GetMapping
    public Page<User> getUsers(
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "10") int size,
        @RequestParam(defaultValue = "id") String sortBy,
        @RequestParam(defaultValue = "ASC") String direction
    ) {
        return userService.getUsers(page, size, sortBy, direction);
    }
}
```

---

## Security - Concepts & Theory

### Authentication vs Authorization

**Authentication**: "Who are you?"
- Verifying user identity
- Username/password verification
- Multi-factor authentication
- Result: Access token/session

**Authorization**: "What can you do?"
- Verifying user permissions
- Role-based access (RBAC)
- Attribute-based access (ABAC)
- Result: Allowed/Denied

**Flow**:
```
User Credentials
       ↓
   Authentication
       ↓
    ✓ Identity Verified
       ↓
  Request to Resource
       ↓
   Authorization Check
       ↓
✓ Has Permission? → Grant Access
✗ No Permission? → Deny Access
```

### Security Architecture in Spring Security

**Security Filter Chain**:
```
HTTP Request
     ↓
SecurityFilterChain
     ├── DisableHttpSessionCsrfFilter
     ├── SecurityContextPersistenceFilter
     ├── CsrfFilter
     ├── LogoutFilter
     ├── UsernamePasswordAuthenticationFilter
     ├── DefaultLoginPageGeneratingFilter
     ├── DefaultLogoutPageGeneratingFilter
     ├── BasicAuthenticationFilter
     ├── RequestCacheAwareFilter
     ├── SecurityContextHolderAwareRequestFilter
     ├── AnonymousAuthenticationFilter
     ├── SessionManagementFilter
     └── ExceptionTranslationFilter
     ↓
FilterSecurityInterceptor (Authorization)
     ↓
Servlet/Controller
```

**JWT vs Session-Based Authentication**:

| Aspect | JWT | Session |
|--------|-----|---------|
| Storage | Client (Token) | Server (Session Store) |
| Stateless | Yes | No |
| Scalability | Better | Requires sticky sessions |
| CSRF | Less susceptible | Susceptible |
| Payload Size | Larger | Small (just ID) |
| Token Expiry | Built-in | Configurable |
| Use Case | Microservices, Mobile | Monolith, Web Apps |

**JWT Structure**:
```
Header.Payload.Signature

Header:
{
  "alg": "HS512",
  "typ": "JWT"
}

Payload:
{
  "sub": "user123",
  "name": "John Doe",
  "iat": 1516239022,
  "exp": 1516242622
}

Signature:
HMACSHA512(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
)
```

### Q24: What is Spring Security?
**A:** Spring Security is a powerful and flexible authentication and authorization framework.

Add dependency:
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

### Q25: What is JWT (JSON Web Token)?
**A:** JWT is a stateless authentication mechanism that contains encoded user information.

**Structure**: Header.Payload.Signature

```java
// JWT Utility
@Component
public class JwtUtil {
    private String secret = "mySecretKey";
    private long expiration = 86400000; // 24 hours
    
    public String generateToken(String username) {
        return Jwts.builder()
            .setSubject(username)
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + expiration))
            .signWith(SignatureAlgorithm.HS512, secret)
            .compact();
    }
    
    public String getUsernameFromToken(String token) {
        return Jwts.parser()
            .setSigningKey(secret)
            .parseClaimsJws(token)
            .getBody()
            .getSubject();
    }
    
    public boolean validateToken(String token) {
        try {
            Jwts.parser().setSigningKey(secret).parseClaimsJws(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}
```

### Q26: How do you implement Authentication?
**A:**

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .authorizeRequests()
                .antMatchers("/api/auth/**").permitAll()
                .antMatchers("/api/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            .and()
            .addFilterBefore(
                new JwtAuthenticationFilter(jwtUtil),
                UsernamePasswordAuthenticationFilter.class
            );
    }
}
```

### Q27: How do you implement Authorization?
**A:**

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @GetMapping
    @PreAuthorize("hasRole('ADMIN')")
    public List<User> getAllUsers() {
        return userService.getAllUsers();
    }
    
    @GetMapping("/{id}")
    @PreAuthorize("hasAnyRole('USER', 'ADMIN')")
    public User getUser(@PathVariable Long id) {
        return userService.getUserById(id);
    }
    
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public User createUser(@RequestBody User user) {
        return userService.createUser(user);
    }
}
```

Enable method security:
```java
@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig {
}
```

---

## Testing - Concepts & Theory

### Testing Pyramid

```
        ┌─────┐
        │  E2E│  Few, Slow, Expensive
        │Tests│  User workflows
        └─────┘
       ╱       ╲
      ╱         ╲
     ╱           ╲
    ┌─────────────┐
    │Integration  │  More, Medium Speed
    │Tests        │  Component interaction
    └─────────────┘
   ╱               ╲
  ╱                 ╲
 ╱                   ╲
┌─────────────────────┐
│  Unit Tests         │  Many, Fast, Cheap
│  Single component   │
└─────────────────────┘
```

**Best Practices**:
- 70% Unit Tests
- 20% Integration Tests
- 10% E2E Tests

### Unit Testing Concepts

**Arrange-Act-Assert (AAA) Pattern**:
```java
@Test
public void testCreateUser() {
    // ARRANGE: Setup test data and mocks
    UserDTO userDTO = new UserDTO("john@example.com", "John");
    User expectedUser = new User(1L, "john@example.com", "John");
    when(userRepository.save(any(User.class))).thenReturn(expectedUser);
    
    // ACT: Execute the method being tested
    User result = userService.createUser(userDTO);
    
    // ASSERT: Verify the result
    assertEquals(expectedUser.getId(), result.getId());
    assertEquals(expectedUser.getEmail(), result.getEmail());
}
```

**Mocking vs Stubbing**:

- **Mocking**: Track method calls and their arguments
  ```java
  when(userRepository.findById(1L)).thenReturn(Optional.of(user));
  User result = userService.getUserById(1L);
  verify(userRepository, times(1)).findById(1L);  // Verify interaction
  ```

- **Stubbing**: Provide fake responses
  ```java
  when(userRepository.findById(1L)).thenReturn(Optional.of(user));
  User result = userService.getUserById(1L);
  // Just checking result, not verifying call
  ```

### Integration Testing Concepts

**Integration Tests Should**:
- Test multiple components together
- Use real databases (H2, TestContainers)
- Test actual HTTP requests
- Include real security context
- Be slower but cover more

**Layers of Integration**:
```
E2E: Full application + external services
    ↓
API Integration: Controllers + Services + DB
    ↓
Service Integration: Multiple services
    ↓
Component Integration: Service + Repository
    ↓
Unit: Single component
```

### Q28: What are types of testing in Spring Boot?
**A:**
1. **Unit Testing**: Test individual methods
2. **Integration Testing**: Test multiple components
3. **Controller Testing**: Test REST endpoints
4. **Service Testing**: Test business logic

### Q29: How do you write Unit Tests?
**A:**

```java
@RunWith(MockitoRunner.class)
public class UserServiceTest {
    
    @Mock
    private UserRepository userRepository;
    
    @InjectMocks
    private UserService userService;
    
    @Before
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }
    
    @Test
    public void testFindUserById() {
        // Arrange
        User user = new User(1L, "John");
        when(userRepository.findById(1L)).thenReturn(Optional.of(user));
        
        // Act
        User result = userService.getUserById(1L);
        
        // Assert
        assertEquals(user.getId(), result.getId());
        assertEquals(user.getName(), result.getName());
        verify(userRepository, times(1)).findById(1L);
    }
    
    @Test
    public void testUserNotFound() {
        when(userRepository.findById(1L)).thenReturn(Optional.empty());
        
        assertThrows(UserNotFoundException.class, () -> {
            userService.getUserById(1L);
        });
    }
}
```

### Q30: How do you test REST Controllers?
**A:**

```java
@WebMvcTest(UserController.class)
public class UserControllerTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @MockBean
    private UserService userService;
    
    @Test
    public void testGetUserById() throws Exception {
        User user = new User(1L, "John");
        when(userService.getUserById(1L)).thenReturn(user);
        
        mockMvc.perform(get("/api/users/1"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.id").value(1L))
            .andExpect(jsonPath("$.name").value("John"));
        
        verify(userService, times(1)).getUserById(1L);
    }
    
    @Test
    public void testCreateUser() throws Exception {
        User user = new User(null, "John");
        User savedUser = new User(1L, "John");
        
        when(userService.createUser(any(User.class))).thenReturn(savedUser);
        
        mockMvc.perform(post("/api/users")
            .contentType(MediaType.APPLICATION_JSON)
            .content(new ObjectMapper().writeValueAsString(user)))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.id").value(1L));
    }
}
```

### Q31: What is @SpringBootTest?
**A:** `@SpringBootTest` loads the entire application context for integration testing:

```java
@SpringBootTest
public class UserIntegrationTest {
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    public void testIntegration() {
        User user = new User(null, "John");
        
        ResponseEntity<User> response = restTemplate.postForEntity(
            "/api/users",
            user,
            User.class
        );
        
        assertEquals(HttpStatus.CREATED, response.getStatusCode());
        assertTrue(userRepository.findByName("John").isPresent());
    }
}
```

---

## Microservices - Concepts & Theory

### What are Microservices?

**Definition**: Architectural style where applications are built as collection of small, independent, loosely-coupled services.

**Characteristics**:

1. **Single Responsibility**: Each service has one reason to change
   ```
   UserService      → User management
   ProductService   → Product management
   OrderService     → Order processing
   ```

2. **Independence**: Services can be:
   - Deployed separately
   - Scaled independently
   - Written in different languages
   - Use different technologies

3. **Loose Coupling**: Services communicate via APIs
   - Reduces dependencies
   - Improves resilience
   - Enables independent development

4. **High Cohesion**: Related functionality grouped together

**Monolith vs Microservices**:

| Aspect | Monolith | Microservices |
|--------|----------|---------------|
| Deployment | Single unit | Independent services |
| Scaling | Scale entire app | Scale specific service |
| Technology | Single stack | Polyglot |
| Complexity | Lower (simple) | Higher (distributed) |
| Debugging | Easier | Harder |
| Database | Shared | Per service |
| Deployment Time | Slower | Faster |

### Microservices Architecture Patterns

**1. Service Registry & Discovery**:
```
Service A                Service C
    ↓                        ↓
    └────→ Service Registry ←──
           (Eureka, Consul)
                ↓
    Service B queries registry for Service A location
```

**2. API Gateway Pattern**:
```
Multiple Clients
        ↓
   API Gateway (Single Entry Point)
   ├─ Request routing
   ├─ Rate limiting
   ├─ Authentication
   ├─ Load balancing
        ↓
   ┌──────┬──────┬──────┐
   ↓      ↓      ↓      ↓
Service A Service B Service C
```

**3. Inter-Service Communication**:

**Synchronous (REST/gRPC)**:
- Request-Response
- Real-time
- Tightly coupled
- Can create cascading failures

**Asynchronous (Message Queue)**:
- Event-driven
- Decoupled
- Better resilience
- Complex to debug

**4. Circuit Breaker Pattern**:
```
Closed (Normal)
  ↓ Request fails N times
  ↓
Open (Failing)
  ↓ Wait X seconds
  ↓
Half-Open (Testing)
  ↓ Probe request succeeds → Closed
  ↓ Probe request fails → Open
```

### Distributed Systems Challenges

**Challenges & Solutions**:

| Challenge | Solution |
|-----------|----------|
| Partial Failures | Circuit Breaker, Retries |
| Network Latency | Caching, async communication |
| Data Consistency | Eventual consistency, Sagas |
| Debugging | Centralized logging, Tracing |
| Monitoring | APM tools, Metrics |
| Security | API Gateway, OAuth, mTLS |

**Saga Pattern for Distributed Transactions**:
```
OrderService.createOrder()
    ↓
PaymentService.processPayment()
    ├─ Success → continue
    └─ Failure → PaymentService.refund()
        ↓
InventoryService.reserveItems()
    ├─ Success → continue
    └─ Failure → InventoryService.release()
        ↓
ShippingService.scheduleShipment()
```

### Q32: What are Microservices?
**A:** Microservices are small, independent, loosely coupled services that work together.

**Characteristics**:
- Single Responsibility Principle
- Independently deployable
- Technology diversity
- Scalable
- Fault isolation
- Organized around business capabilities

### Q33: What is Service-to-Service Communication?
**A:**

**Synchronous (REST/Feign)**:
```java
@FeignClient(name = "product-service", url = "http://localhost:8081")
public interface ProductServiceClient {
    
    @GetMapping("/api/products/{id}")
    Product getProduct(@PathVariable Long id);
}

@Service
public class SalesService {
    
    @Autowired
    private ProductServiceClient productClient;
    
    public Sale createSale(Sale sale) {
        Product product = productClient.getProduct(sale.getProductId());
        // Use product data
        return saleRepository.save(sale);
    }
}
```

**Asynchronous (Message Queue)**:
```java
@Service
public class OrderService {
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    public void placeOrder(Order order) {
        // Process order
        orderRepository.save(order);
        
        // Send event
        rabbitTemplate.convertAndSend("order-exchange", "order.created", order);
    }
}

@Component
public class OrderEventListener {
    
    @RabbitListener(queues = "order-queue")
    public void handleOrderCreated(Order order) {
        // Handle order creation event
    }
}
```

### Q34: What is Service Discovery?
**A:** Service Discovery automatically finds available service instances.

Using Eureka:
```java
// Service Registry (Eureka Server)
@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }
}

// Microservice Client
@SpringBootApplication
@EnableDiscoveryClient
public class UserServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserServiceApplication.class, args);
    }
}

// application.yml
spring:
  application:
    name: user-service
eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka
```

### Q35: What is API Gateway?
**A:** API Gateway is a single entry point for all client requests.

```java
// Spring Cloud Gateway configuration
@Configuration
public class GatewayConfig {
    
    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
            .route("user-service", r -> r
                .path("/api/users/**")
                .uri("lb://user-service"))
            .route("product-service", r -> r
                .path("/api/products/**")
                .uri("lb://product-service"))
            .build();
    }
}
```

---

## Advanced Topics - Concepts & Theory

### Caching Strategy & Theory

**Cache Levels**:
```
1. L1 Cache (CPU Cache) - Nanoseconds
2. L2 Cache (Memory) - Microseconds
3. Application Cache - Milliseconds
4. Database Query Cache - Milliseconds
5. HTTP Cache - Network latency
```

**Caching Strategies**:

**Cache-Aside (Lazy Loading)**:
```
Request comes in
    ↓
Check Cache
    ├─ Hit → Return from cache
    └─ Miss → Query DB → Store in cache → Return
```

**Write-Through**:
```
Write request
    ↓
Write to cache
    ↓
Write to database
    ↓
Return to client
```
Slower writes, consistent data

**Write-Behind (Write-Back)**:
```
Write request
    ↓
Write to cache
    ↓
Return to client (async write to DB)
```
Faster writes, risk of data loss

**Cache Invalidation** (Hard Problem):
```
When to invalidate?
1. Time-based (TTL): Expire after X seconds
2. Event-based: Invalidate on data change
3. Manual: @CacheEvict annotation
4. LRU: Remove least recently used
```

**Cache Coherence**:
- Ensure consistent data across cache layers
- Problem in distributed systems
- Solutions: Invalidation, versioning

### Aspect-Oriented Programming (AOP) Theory

**Cross-Cutting Concerns**:
```
Traditional approach (Scattered across code):
┌─────────────────────────────────────┐
│ Logging scattered in every method   │
│ Security checks in multiple places  │
│ Transaction management overhead     │
│ Caching logic mixed with business   │
└─────────────────────────────────────┘

AOP approach (Separated):
┌──────────────┐
│  Join Points │  Methods, constructors, field access
└──────────────┘
     ↓
┌──────────────┐
│  Pointcuts   │  Select specific join points
└──────────────┘
     ↓
┌──────────────┐
│   Advice     │  Code to execute at join point
└──────────────┘
     ↓
┌──────────────┐
│  Aspects     │  Combination of pointcut + advice
└──────────────┘
```

**Advice Types**:
```
@Before: Before method execution
@After: After method execution (always)
@AfterReturning: After successful return
@AfterThrowing: After exception
@Around: Before and after (full control)
```

**Benefits**:
- Separation of concerns
- Reduced code duplication
- Easier to maintain
- Better testability

### Validation Theory

**Validation Layers**:
```
Client-side Validation
    ↓ (JavaScript validation)
    ↓ Quick feedback, not secure
    ↓
Network
    ↓
Server-side Validation
    ├─ Bean Validation (Constraints)
    ├─ Business Logic Validation
    └─ Database Constraints
    ↓ Secure, authoritative
    ↓
Database
```

**Validation Cascade**:
```
@Valid annotation on nested objects
    ↓
Public class User {
    @Valid
    private Address address;  // Also validated recursively
}
```

### Configuration Management & Profiles Theory

**12-Factor App Principle #3: Store config in environment**

**Configuration Hierarchy (Priority)**:
```
Command Line Arguments (Highest)
    ↓
System Environment Variables
    ↓
application-{profile}.properties
    ↓
application.properties
    ↓
application-{profile}.yml
    ↓
application.yml (Lowest)
```

**Profile-Based Configuration**:
```
Development Profile:
- Debug logging
- H2 in-memory database
- Longer timeouts
- Mock external services

Production Profile:
- Info logging
- Real database
- Short timeouts
- Real external services
```

### Q36: What is Caching?
**A:** Caching improves performance by storing frequently accessed data.

```java
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        return new ConcurrentMapCacheManager("users");
    }
}

@Service
public class UserService {
    
    @Cacheable(value = "users", key = "#id")
    public User getUserById(Long id) {
        // Database query
        return userRepository.findById(id).orElseThrow();
    }
    
    @CachePut(value = "users", key = "#user.id")
    public User updateUser(User user) {
        return userRepository.save(user);
    }
    
    @CacheEvict(value = "users", key = "#id")
    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }
}
```

### Q37: What is Logging?
**A:** Logging tracks application behavior for debugging and monitoring.

```java
@Slf4j
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        log.info("Fetching user with id: {}", id);
        User user = userService.getUserById(id);
        log.debug("User details: {}", user);
        return user;
    }
    
    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<String> handleUserNotFound(UserNotFoundException ex) {
        log.error("User not found", ex);
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(ex.getMessage());
    }
}
```

Logging levels: TRACE < DEBUG < INFO < WARN < ERROR < FATAL

### Q38: What is AOP (Aspect-Oriented Programming)?
**A:** AOP separates cross-cutting concerns like logging, security, caching.

```java
@Aspect
@Component
public class LoggingAspect {
    
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void serviceMethods() {
    }
    
    @Before("serviceMethods()")
    public void logBefore(JoinPoint joinPoint) {
        log.info("Method: {} called with args: {}", 
            joinPoint.getSignature().getName(), 
            joinPoint.getArgs());
    }
    
    @After("serviceMethods()")
    public void logAfter(JoinPoint joinPoint) {
        log.info("Method: {} completed", joinPoint.getSignature().getName());
    }
    
    @AfterReturning(pointcut = "serviceMethods()", returning = "result")
    public void logAfterReturning(JoinPoint joinPoint, Object result) {
        log.info("Method: {} returned: {}", 
            joinPoint.getSignature().getName(), 
            result);
    }
    
    @AfterThrowing(pointcut = "serviceMethods()", throwing = "ex")
    public void logAfterThrowing(JoinPoint joinPoint, Exception ex) {
        log.error("Method: {} threw exception: {}", 
            joinPoint.getSignature().getName(), 
            ex.getMessage());
    }
}
```

### Q39: What is Validation in Spring Boot?
**A:**

```java
public class User {
    
    @NotNull(message = "ID cannot be null")
    private Long id;
    
    @NotBlank(message = "Name cannot be blank")
    @Size(min = 2, max = 100, message = "Name must be between 2 and 100 characters")
    private String name;
    
    @Email(message = "Email should be valid")
    private String email;
    
    @Min(18)
    @Max(65)
    private int age;
    
    @Pattern(regexp = "^[0-9]{10}$", message = "Phone must be 10 digits")
    private String phone;
}

@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @PostMapping
    public ResponseEntity<User> createUser(@Valid @RequestBody User user) {
        return ResponseEntity.ok(userService.createUser(user));
    }
}

@RestControllerAdvice
public class ValidationExceptionHandler {
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, String>> handleValidationException(
        MethodArgumentNotValidException ex) {
        
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult()
            .getFieldErrors()
            .forEach(error -> errors.put(error.getField(), error.getDefaultMessage()));
        
        return ResponseEntity.badRequest().body(errors);
    }
}
```

### Q40: What are Profiles in Spring Boot?
**A:** Profiles allow different configurations for different environments.

```yaml
# application.yml (default)
spring:
  profiles:
    active: dev

# application-dev.yml
server:
  port: 8080
logging:
  level:
    root: DEBUG

# application-prod.yml
server:
  port: 8443
logging:
  level:
    root: INFO
spring:
  datasource:
    url: jdbc:mysql://prod-db:3306/mydb
```

```java
@Configuration
@Profile("dev")
public class DevConfig {
    // Dev-specific beans
}

@Configuration
@Profile("prod")
public class ProdConfig {
    // Prod-specific beans
}
```

---

## Common Interview Questions

### Design Patterns in Spring

**Creational Patterns**:

1. **Singleton Pattern**
   ```java
   // Spring beans are singletons by default
   @Service
   public class UserService {
       // Only ONE instance in entire application
   }
   ```

2. **Factory Pattern**
   ```java
   @Configuration
   public class BeanFactory {
       @Bean
       public UserService userService() {  // Factory method
           return new UserService();
       }
   }
   ```

3. **Builder Pattern**
   ```java
   @Configuration
   public class ApplicationBuilder {
       public static void main(String[] args) {
           new SpringApplicationBuilder(Application.class)
               .headless(false)
               .banner(Banner.Mode.CONSOLE)
               .run(args);
       }
   }
   ```

**Structural Patterns**:

1. **Proxy Pattern**
   ```java
   // Spring creates proxies for @Transactional, @Cacheable
   @Service
   public class UserService {
       @Transactional  // Spring wraps with transaction proxy
       public void saveUser(User user) {
           userRepository.save(user);
       }
   }
   ```

2. **Decorator Pattern**
   ```java
   // Wrappers like ResponseEntity, Optional
   ResponseEntity<User> response = ResponseEntity.ok(user);
   Optional<User> optionalUser = userRepository.findById(id);
   ```

3. **Adapter Pattern**
   ```java
   // HTTP message converters adapt between Java objects and JSON
   @RestController
   public class UserController {
       @PostMapping
       public User create(@RequestBody User user) {  // Adapter converts JSON to User
           return userService.createUser(user);
       }
   }
   ```

**Behavioral Patterns**:

1. **Observer Pattern**
   ```java
   @Component
   public class OrderEventListener {
       @EventListener
       public void handleOrderCreatedEvent(OrderCreatedEvent event) {
           // React to event
       }
   }
   
   @Service
   public class OrderService {
       @Autowired
       private ApplicationEventPublisher eventPublisher;
       
       public void createOrder(Order order) {
           orderRepository.save(order);
           eventPublisher.publishEvent(new OrderCreatedEvent(order));
       }
   }
   ```

2. **Strategy Pattern**
   ```java
   // Interface for different strategies
   public interface PaymentStrategy {
       boolean pay(Payment payment);
   }
   
   @Component
   public class CreditCardPayment implements PaymentStrategy {
       public boolean pay(Payment payment) { /* ... */ }
   }
   
   @Component
   public class UPIPayment implements PaymentStrategy {
       public boolean pay(Payment payment) { /* ... */ }
   }
   
   // Context using strategy
   @Service
   public class PaymentService {
       @Autowired
       private Map<String, PaymentStrategy> paymentStrategies;
       
       public boolean processPayment(String type, Payment payment) {
           return paymentStrategies.get(type).pay(payment);
       }
   }
   ```

3. **Template Method Pattern**
   ```java
   public abstract class BaseService<T> {
       public T create(T entity) {
           validate(entity);
           return save(entity);
       }
       
       protected abstract void validate(T entity);
       protected abstract T save(T entity);
   }
   
   @Service
   public class UserService extends BaseService<User> {
       protected void validate(User user) { /* ... */ }
       protected User save(User user) { /* ... */ }
   }
   ```

### Q41: What is the difference between @Component, @Service, and @Repository?
**A:**
- `@Component`: Generic stereotype for any class
- `@Service`: Business logic layer (semantically indicates service)
- `@Repository`: Data access layer (provides exception translation)

### Q42: Explain the Bean Lifecycle
**A:**
1. Bean instantiation
2. Setter injection
3. `@PostConstruct` method execution
4. Bean ready for use
5. `@PreDestroy` method execution
6. Bean destruction

```java
@Component
public class MyBean {
    
    @PostConstruct
    public void init() {
        System.out.println("Bean initialized");
    }
    
    @PreDestroy
    public void cleanup() {
        System.out.println("Bean destroyed");
    }
}
```

### Q43: What is @Qualifier used for?
**A:** `@Qualifier` resolves ambiguity when multiple beans of the same type exist.

```java
@Repository
public class MySQLUserRepository implements UserRepository {
}

@Repository
public class MongoUserRepository implements UserRepository {
}

@Service
public class UserService {
    
    @Autowired
    @Qualifier("mySQLUserRepository")
    private UserRepository userRepository;
}
```

### Q44: What is the difference between @Autowired and @Inject?
**A:**
- `@Autowired`: Spring-specific
- `@Inject`: Standard Java annotation (JSR-330)

Both perform dependency injection but `@Autowired` has `required` attribute:
```java
@Autowired(required = false)
private OptionalService optionalService;
```

### Q45: How do you handle Circular Dependencies?
**A:**

**Circular Dependency Problem**:
```java
@Service
public class ServiceA {
    @Autowired
    private ServiceB serviceB;
}

@Service
public class ServiceB {
    @Autowired
    private ServiceA serviceA;
}
```

**Solution - Lazy Loading**:
```java
@Service
public class ServiceA {
    @Autowired
    private ObjectProvider<ServiceB> serviceB;
    
    public void useServiceB() {
        serviceB.getIfAvailable().someMethod();
    }
}
```

### Q46: What is Swagger/OpenAPI?
**A:** Swagger documents REST APIs automatically.

Add dependency:
```xml
<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
    <version>2.0.2</version>
</dependency>
```

```java
@RestController
@RequestMapping("/api/users")
@Tag(name = "User Management", description = "APIs for user management")
public class UserController {
    
    @GetMapping("/{id}")
    @Operation(summary = "Get user by ID", description = "Retrieve a user by their unique ID")
    @ApiResponse(responseCode = "200", description = "User found")
    @ApiResponse(responseCode = "404", description = "User not found")
    public User getUser(@PathVariable Long id) {
        return userService.getUserById(id);
    }
}
```

Access Swagger UI at: `http://localhost:8080/swagger-ui.html`

### Q47: How do you implement CORS?
**A:** CORS handles cross-origin requests.

```java
@Configuration
public class CorsConfig {
    
    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/api/**")
                    .allowedOrigins("http://localhost:3000", "http://localhost:4200")
                    .allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH")
                    .allowedHeaders("*")
                    .allowCredentials(true)
                    .maxAge(3600);
            }
        };
    }
}
```

### Q48: What is Content Negotiation?
**A:** Content negotiation returns different formats based on client request.

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @GetMapping(value = "/{id}", produces = {"application/json", "application/xml"})
    public User getUser(@PathVariable Long id) {
        return userService.getUserById(id);
    }
}
```

### Q49: How do you implement Pagination with Spring Data?
**A:** Already covered in Q23.

### Q50: What is the difference between @RequestParam and @PathVariable?
**A:**
- `@RequestParam`: Query parameters (?key=value)
- `@PathVariable`: URL path parameters (/users/123)

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    // GET /api/users/123
    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.getUserById(id);
    }
    
    // GET /api/users?name=John&age=30
    @GetMapping
    public List<User> searchUsers(
        @RequestParam(required = false) String name,
        @RequestParam(required = false) Integer age
    ) {
        return userService.searchUsers(name, age);
    }
}
```

---

## Summary

### Key Takeaways:

1. **Spring Boot Basics**: Auto-configuration, starters, embedded servers
2. **Dependency Injection**: Constructor injection is recommended
3. **REST APIs**: Use proper HTTP methods and status codes
4. **Database**: Spring Data JPA simplifies database operations
5. **Security**: JWT for stateless authentication
6. **Testing**: Use @WebMvcTest for controllers, @SpringBootTest for integration
7. **Microservices**: Implement service discovery, API Gateway, circuit breakers
8. **Best Practices**:
   - Use constructor injection
   - Handle exceptions globally
   - Implement proper logging
   - Write comprehensive tests
   - Use meaningful exception messages
   - Validate input data
   - Use profiles for different environments
   - Cache frequently accessed data
   - Document APIs with Swagger

### Important Annotations Summary:

| Annotation | Purpose |
|-----------|---------|
| @SpringBootApplication | Main application class |
| @RestController | REST endpoint handler |
| @RequestMapping | URL mapping |
| @GetMapping, @PostMapping | HTTP method specific mapping |
| @PathVariable | Extract URL path variable |
| @RequestParam | Query parameter |
| @RequestBody | Convert request body to object |
| @Service | Business logic |
| @Repository | Data access |
| @Autowired | Dependency injection |
| @Configuration | Configuration class |
| @Bean | Create managed bean |
| @Transactional | Transaction management |
| @Cacheable | Cache result |
| @ExceptionHandler | Handle exceptions |
| @EnableCaching | Enable caching |
| @Aspect | Aspect for AOP |

---

## Spring Boot Best Practices & Common Mistakes

### Code Organization Best Practices

**1. Package Structure**:
```
com.example.application/
├── config/          # @Configuration classes
├── controller/      # REST controllers
├── service/         # Business logic
├── repository/      # Data access
├── entity/          # Domain entities
├── dto/             # Data transfer objects
├── exception/       # Custom exceptions
├── util/            # Utility classes
└── Application.java # Main class
```

**2. Dependency Injection Best Practices**:
```java
// ✓ GOOD: Constructor Injection (Immutable, Testable)
@Service
public class UserService {
    private final UserRepository userRepository;
    
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}

// ✗ BAD: Field Injection (Mutable, Hard to test)
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;
}
```

### Error Handling Best Practices

**✓ GOOD: Structured Exception Handling**
```java
// Custom exception
public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(String message) {
        super(message);
    }
}

// Global exception handler
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException ex) {
        ErrorResponse error = new ErrorResponse(
            LocalDateTime.now(),
            HttpStatus.NOT_FOUND.value(),
            ex.getMessage()
        );
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }
}
```

### Database Best Practices

**✓ GOOD: Proper Entity Design**
```java
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, unique = true)
    private String email;
    
    @Column(nullable = false)
    private String name;
    
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    private LocalDateTime updatedAt;
}
```

### Query Best Practices

**✓ GOOD: Pagination and Specific Queries**
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Page<User> findByNameContains(String name, Pageable pageable);
}

@Service
public class UserService {
    public Page<User> searchUsers(String name, int page) {
        Pageable pageable = PageRequest.of(page, 10);
        return userRepository.findByNameContains(name, pageable);
    }
}
```

**✗ BAD: N+1 Query Problem**
```java
// This loads all users, then queries for each one
List<User> users = userRepository.findAll();
users.forEach(u -> u.getOrders().size());  // Query per user!
```

### Logging Best Practices

**✓ GOOD: Structured Logging**
```java
@Slf4j
@Service
public class UserService {
    
    public User createUser(User user) {
        log.info("Creating user with email: {}", user.getEmail());
        try {
            User saved = userRepository.save(user);
            log.debug("User saved with id: {}", saved.getId());
            return saved;
        } catch (Exception e) {
            log.error("Error creating user", e);
            throw e;
        }
    }
}
```

### Security Best Practices

**✓ GOOD: Secure Configuration**
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .authorizeRequests()
                .antMatchers("/api/auth/**").permitAll()
                .antMatchers("/api/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated();
        
        return http.build();
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(12);
    }
}
```

### API Design Best Practices

**✓ GOOD: RESTful Design with Versioning**
```java
@RestController
@RequestMapping("/api/v1/users")
public class UserController {
    
    @GetMapping
    public ResponseEntity<Page<UserDTO>> listUsers(
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "10") int size
    ) {
        return ResponseEntity.ok(userService.getUsers(page, size));
    }
    
    @PostMapping
    public ResponseEntity<UserDTO> createUser(@Valid @RequestBody UserDTO dto) {
        return ResponseEntity.status(HttpStatus.CREATED)
            .body(userService.createUser(dto));
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<UserDTO> getUser(@PathVariable Long id) {
        return ResponseEntity.ok(userService.getUserById(id));
    }
    
    @PutMapping("/{id}")
    public ResponseEntity<UserDTO> updateUser(@PathVariable Long id, 
        @Valid @RequestBody UserDTO dto) {
        return ResponseEntity.ok(userService.updateUser(id, dto));
    }
    
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        userService.deleteUser(id);
        return ResponseEntity.noContent().build();
    }
}
```

### Common Mistakes to Avoid

| Mistake | Problem | Solution |
|---------|---------|----------|
| Using @Autowired field injection | Hard to test, ordering issues | Use constructor injection |
| Catching Exception broadly | Hides real errors | Catch specific exceptions |
| No pagination on large queries | Memory exhaustion | Implement pagination |
| Storing secrets in code | Security risk | Use environment variables |
| No input validation | SQL injection, bad data | Use @Valid, Bean Validation |
| Synchronous service calls | Cascading failures | Use async/message queues |
| No transaction boundaries | Data inconsistency | Use @Transactional |
| Mixed DTOs and Entities | Tight coupling | Separate concerns clearly |
| No error handling | Undefined behavior | Global exception handler |
| Inefficient DB queries | Performance issues | Use projections, pagination |

---

## Practice Questions for Self-Study:

1. Design a complete REST API for e-commerce with proper error handling
2. Implement JWT authentication from scratch with refresh tokens
3. Create a multi-service microservices architecture with Eureka discovery
4. Write comprehensive unit and integration tests
5. Implement caching strategies (Cache-Aside, Write-Through)
6. Design complex database schema with proper relationships
7. Implement CRUD with validation and global exception handling
8. Create custom exception hierarchy and handlers
9. Implement pagination, sorting, and filtering
10. Design API versioning strategy with backward compatibility

---

**Last Updated**: November 29, 2025

This comprehensive guide covers Spring Boot from fundamentals to advanced concepts commonly asked in interviews. The guide includes:
- **Extensive Theory**: Deep understanding of concepts, not just code
- **50+ Interview Q&As**: Real questions with detailed answers
- **Design Patterns**: How Spring uses common patterns
- **Best Practices**: Real-world advice for production systems
- **Common Mistakes**: What to avoid and why
- **Code Examples**: Practical examples for every concept

Practice implementing these concepts with real projects for mastery.
