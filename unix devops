# UNIX Notes - Comprehensive Guide with Examples

## Table of Contents
1. [Introduction to UNIX](#introduction-to-unix)
2. [File System & Navigation](#file-system--navigation)
3. [File Operations](#file-operations)
4. [File Permissions](#file-permissions)
5. [Process Management](#process-management)
6. [Text Processing](#text-processing)
7. [Shell Scripting](#shell-scripting)
8. [Networking](#networking)
9. [System Administration](#system-administration)
10. [Advanced Commands](#advanced-commands)
11. [Interview Questions & Answers](#interview-questions--answers)

---

## Introduction to UNIX

### What is UNIX?

**UNIX** is a powerful, multi-user, multitasking operating system originally developed in the 1960s-1970s at AT&T Bell Labs by Ken Thompson, Dennis Ritchie, and others. It has influenced many modern operating systems including Linux, macOS, BSD, and Solaris.

### Key Features of UNIX

1. **Multi-user System**
   - Multiple users can access the system simultaneously
   - Each user has their own environment and permissions
   - Resources are shared efficiently among users

2. **Multitasking**
   - Can run multiple processes concurrently
   - Time-sharing allows efficient CPU utilization
   - Background and foreground process execution

3. **Portability**
   - Written primarily in C language
   - Can be adapted to different hardware platforms
   - POSIX standards ensure compatibility

4. **Hierarchical File System**
   - Everything is organized in a tree structure
   - Single root directory (/)
   - Unified namespace for all resources

5. **Security**
   - User authentication and authorization
   - File permissions (read, write, execute)
   - Process isolation

6. **Pipes and Filters**
   - Output of one command becomes input of another
   - Modular design philosophy
   - Small programs that do one thing well

### UNIX Architecture

```
┌─────────────────────────────────────────┐
│           User Applications             │
│     (Shell, Utilities, User Programs)   │
├─────────────────────────────────────────┤
│              Shell Layer                │
│   (bash, sh, csh, ksh, zsh, etc.)      │
├─────────────────────────────────────────┤
│         System Call Interface           │
│    (open, read, write, fork, exec)     │
├─────────────────────────────────────────┤
│              UNIX Kernel                │
│  ┌───────────────────────────────────┐ │
│  │    Process Management             │ │
│  ├───────────────────────────────────┤ │
│  │    Memory Management              │ │
│  ├───────────────────────────────────┤ │
│  │    File System Management         │ │
│  ├───────────────────────────────────┤ │
│  │    Device Drivers                 │ │
│  └───────────────────────────────────┘ │
├─────────────────────────────────────────┤
│              Hardware                   │
│    (CPU, Memory, Disk, Network)        │
└─────────────────────────────────────────┘
```

### UNIX Philosophy

1. **Write programs that do one thing and do it well**
2. **Write programs to work together**
3. **Write programs to handle text streams** (universal interface)
4. **Keep it simple** (KISS principle)
5. **Choose portability over efficiency**
6. **Store data in flat text files**
7. **Use software leverage** (build on existing tools)

### Types of UNIX Shells

| Shell | Description | Prompt |
|-------|-------------|--------|
| **sh** (Bourne Shell) | Original UNIX shell | $ |
| **bash** (Bourne Again Shell) | Most popular, GNU project | $ |
| **csh** (C Shell) | C-like syntax | % |
| **tcsh** | Enhanced C shell | % |
| **ksh** (Korn Shell) | Combines features of sh and csh | $ |
| **zsh** (Z Shell) | Modern, feature-rich | % |

### UNIX vs Linux

| Feature | UNIX | Linux |
|---------|------|-------|
| Origin | AT&T Bell Labs | Linus Torvalds |
| License | Proprietary (mostly) | Open Source (GPL) |
| Cost | Commercial | Free |
| Examples | Solaris, AIX, HP-UX | Ubuntu, CentOS, Debian |
| Kernel | Original UNIX kernel | Linux kernel |
| Portability | Hardware specific | Highly portable |

---

## File System & Navigation

### Theory: UNIX File System

The UNIX file system is a hierarchical structure starting from the root directory `/`. Everything in UNIX is treated as a file, including:
- Regular files
- Directories
- Device files (hardware interfaces)
- Sockets (network communication)
- Pipes (inter-process communication)
- Symbolic links (shortcuts)

**File System Types:**
- **ext4** - Fourth extended filesystem (Linux default)
- **XFS** - High-performance journaling file system
- **Btrfs** - Modern copy-on-write filesystem
- **NFS** - Network File System
- **NTFS** - Windows filesystem (read/write support)

**Inode:** An inode is a data structure that stores metadata about a file:
- File size
- Owner and group
- Permissions
- Timestamps (created, modified, accessed)
- Link count
- Pointers to data blocks

Each file has a unique inode number. Multiple filenames can point to the same inode (hard links).

### Directory Structure
```
/           # Root directory
├── bin     # Essential command binaries
├── boot    # Boot loader files
├── dev     # Device files
├── etc     # System configuration files
├── home    # User home directories
├── lib     # Shared libraries
├── opt     # Optional software packages
├── tmp     # Temporary files
├── usr     # User programs
└── var     # Variable data (logs, etc.)
```

### Navigation Commands

#### `pwd` - Print Working Directory
```bash
# Display current directory
$ pwd
/home/user/documents

# Physical path (resolves symlinks)
$ pwd -P
/mnt/storage/documents
```

#### `cd` - Change Directory
```bash
# Go to home directory
$ cd
$ cd ~

# Go to previous directory
$ cd -

# Go up one level
$ cd ..

# Go up two levels
$ cd ../..

# Absolute path
$ cd /usr/local/bin

# Relative path
$ cd documents/projects
```

#### `ls` - List Directory Contents
```bash
# Basic listing
$ ls
file1.txt  file2.txt  directory1

# Long format with details
$ ls -l
-rw-r--r-- 1 user group 1024 Nov 29 10:30 file1.txt
drwxr-xr-x 2 user group 4096 Nov 29 10:31 directory1

# Show hidden files
$ ls -a
.  ..  .hidden  file1.txt

# Human-readable sizes
$ ls -lh
-rw-r--r-- 1 user group 1.0K Nov 29 10:30 file1.txt

# Sort by modification time
$ ls -lt

# Reverse order
$ ls -lr

# Recursive listing
$ ls -R

# Combined options
$ ls -alh
```

---

## File Operations

### Theory: File Types in UNIX

UNIX recognizes seven types of files:

1. **Regular File (-)**: Contains data, text, or program instructions
2. **Directory (d)**: Contains references to other files
3. **Symbolic Link (l)**: Points to another file by name
4. **Character Device (c)**: Provides unbuffered access to hardware (e.g., keyboard)
5. **Block Device (b)**: Provides buffered access to hardware (e.g., hard drive)
6. **Socket (s)**: Used for inter-process communication
7. **Named Pipe/FIFO (p)**: Used for inter-process communication

**File Naming Rules:**
- Can be up to 255 characters long
- Case-sensitive (File.txt ≠ file.txt)
- Can contain any character except `/` and null
- Hidden files start with `.` (e.g., .bashrc)
- Avoid spaces and special characters for ease of use

**File Extensions:**
Unlike Windows, UNIX doesn't rely on extensions, but conventions exist:
- `.txt` - Text file
- `.sh` - Shell script
- `.c` - C source code
- `.tar` - Tape archive
- `.gz` - Gzip compressed
- `.conf` - Configuration file

### Creating Files and Directories

#### `touch` - Create Empty File
```bash
# Create single file
$ touch newfile.txt

# Create multiple files
$ touch file1.txt file2.txt file3.txt

# Update timestamp
$ touch existing_file.txt

# Create with specific timestamp
$ touch -t 202311291030 file.txt
```

#### `mkdir` - Make Directory
```bash
# Create single directory
$ mkdir mydir

# Create multiple directories
$ mkdir dir1 dir2 dir3

# Create nested directories
$ mkdir -p parent/child/grandchild

# Create with specific permissions
$ mkdir -m 755 mydir
```

### Copying Files

#### `cp` - Copy Files and Directories
```bash
# Copy file
$ cp source.txt destination.txt

# Copy to directory
$ cp file.txt /path/to/directory/

# Copy multiple files
$ cp file1.txt file2.txt /destination/

# Copy directory recursively
$ cp -r source_dir/ destination_dir/

# Interactive (prompt before overwrite)
$ cp -i source.txt dest.txt

# Preserve attributes (timestamps, permissions)
$ cp -p source.txt dest.txt

# Verbose output
$ cp -v source.txt dest.txt

# Copy only if source is newer
$ cp -u source.txt dest.txt

# Example: Backup with timestamp
$ cp file.txt file.txt.backup.$(date +%Y%m%d)
```

### Moving and Renaming

#### `mv` - Move/Rename Files
```bash
# Rename file
$ mv oldname.txt newname.txt

# Move file to directory
$ mv file.txt /path/to/directory/

# Move multiple files
$ mv file1.txt file2.txt /destination/

# Move directory
$ mv old_dir/ new_dir/

# Interactive mode
$ mv -i source.txt dest.txt

# Don't overwrite existing files
$ mv -n source.txt dest.txt

# Verbose output
$ mv -v source.txt dest.txt
```

### Deleting Files

#### `rm` - Remove Files and Directories
```bash
# Remove file
$ rm file.txt

# Remove multiple files
$ rm file1.txt file2.txt file3.txt

# Remove with confirmation
$ rm -i file.txt

# Force removal (no prompt)
$ rm -f file.txt

# Remove directory and contents
$ rm -r directory/

# Remove directory (force and recursive)
$ rm -rf directory/

# Remove with verbose output
$ rm -v file.txt

# Remove all .txt files
$ rm *.txt

# Safe removal using find
$ find . -name "*.tmp" -type f -delete
```

#### `rmdir` - Remove Empty Directories
```bash
# Remove empty directory
$ rmdir empty_dir

# Remove nested empty directories
$ rmdir -p parent/child/grandchild
```

### Viewing Files

#### `cat` - Concatenate and Display
```bash
# Display file contents
$ cat file.txt

# Display multiple files
$ cat file1.txt file2.txt

# Number all lines
$ cat -n file.txt

# Number non-empty lines
$ cat -b file.txt

# Show end of line markers
$ cat -E file.txt

# Show tabs as ^I
$ cat -T file.txt

# Create file with cat
$ cat > newfile.txt
This is line 1
This is line 2
^D  # Press Ctrl+D to save

# Append to file
$ cat >> file.txt
Additional line
^D

# Concatenate files
$ cat file1.txt file2.txt > combined.txt
```

#### `less` - Page Through File
```bash
# View file with pagination
$ less file.txt

# Commands within less:
# Space/f  - Forward one page
# b        - Backward one page
# g        - Go to beginning
# G        - Go to end
# /pattern - Search forward
# ?pattern - Search backward
# n        - Next search result
# N        - Previous search result
# q        - Quit

# View with line numbers
$ less -N file.txt

# Don't wrap long lines
$ less -S file.txt
```

#### `head` - Display Beginning of File
```bash
# First 10 lines (default)
$ head file.txt

# First 5 lines
$ head -n 5 file.txt
$ head -5 file.txt

# First 100 bytes
$ head -c 100 file.txt

# Multiple files
$ head file1.txt file2.txt

# All but last 5 lines
$ head -n -5 file.txt
```

#### `tail` - Display End of File
```bash
# Last 10 lines (default)
$ tail file.txt

# Last 20 lines
$ tail -n 20 file.txt
$ tail -20 file.txt

# Last 100 bytes
$ tail -c 100 file.txt

# Follow file in real-time (logs)
$ tail -f /var/log/syslog

# Follow with retry
$ tail -F /var/log/syslog

# Start from line 50
$ tail -n +50 file.txt
```

---

## File Permissions

### Theory: UNIX Permission Model

UNIX uses a **discretionary access control (DAC)** model with three permission categories and three types of access:

**Permission Categories:**
1. **User (u)** - The file owner
2. **Group (g)** - Members of the file's group
3. **Others (o)** - Everyone else

**Permission Types:**
1. **Read (r)** - View file contents or list directory
2. **Write (w)** - Modify file or create/delete files in directory
3. **Execute (x)** - Run file as program or enter directory

**Special Permissions:**

1. **SUID (Set User ID) - 4000**
   - When set on executable, runs with owner's privileges
   - Example: `/usr/bin/passwd` (allows users to change password)
   - Notation: `rws` in user execute position

2. **SGID (Set Group ID) - 2000**
   - File: Runs with group's privileges
   - Directory: New files inherit directory's group
   - Notation: `rws` in group execute position

3. **Sticky Bit - 1000**
   - Applied to directories (e.g., `/tmp`)
   - Only owner can delete their files
   - Notation: `rwt` in others execute position

**Example:**
```bash
-rwsr-xr-x  1 root root  /usr/bin/passwd    # SUID set
drwxrwsr-x  2 user dev   /shared/project    # SGID set
drwxrwxrwt  2 root root  /tmp               # Sticky bit set
```

**Default Permissions (umask):**
- Default file: 666 (rw-rw-rw-)
- Default directory: 777 (rwxrwxrwx)
- umask value is subtracted
- Common umask: 022 → files: 644, dirs: 755

### Understanding Permissions

```
-rwxr-xr--
│││││││││└─ Other: read
││││││││└── Other: write (-)
│││││││└─── Other: execute (-)
││││││└──── Group: read
│││││└───── Group: write (-)
││││└────── Group: execute
│││└─────── User: read
││└──────── User: write
│└───────── User: execute
└────────── File type (- = file, d = directory, l = link)
```

### Permission Values
```
r (read)    = 4
w (write)   = 2
x (execute) = 1

rwx = 4+2+1 = 7
r-x = 4+0+1 = 5
r-- = 4+0+0 = 4
```

### `chmod` - Change Permissions
```bash
# Symbolic notation
$ chmod u+x file.sh          # Add execute for user
$ chmod g-w file.txt         # Remove write for group
$ chmod o+r file.txt         # Add read for others
$ chmod a+x script.sh        # Add execute for all

# Numeric notation
$ chmod 755 script.sh        # rwxr-xr-x
$ chmod 644 file.txt         # rw-r--r--
$ chmod 600 private.key      # rw-------
$ chmod 777 file.txt         # rwxrwxrwx (not recommended)

# Recursive
$ chmod -R 755 directory/

# Set exact permissions
$ chmod u=rwx,g=rx,o=r file.txt

# Copy permissions from reference file
$ chmod --reference=ref.txt target.txt

# Examples
$ chmod u+x,g+x script.sh    # Add execute for user and group
$ chmod a-w file.txt         # Remove write for all
```

### `chown` - Change Owner
```bash
# Change owner
$ chown newuser file.txt

# Change owner and group
$ chown newuser:newgroup file.txt

# Change only group
$ chown :newgroup file.txt

# Recursive
$ chown -R user:group directory/

# Use reference file
$ chown --reference=ref.txt target.txt

# Examples
$ sudo chown www-data:www-data /var/www/html
$ sudo chown -R user:user /home/user/project
```

### `chgrp` - Change Group
```bash
# Change group
$ chgrp developers file.txt

# Recursive
$ chgrp -R developers project/

# Verbose output
$ chgrp -v developers file.txt
```

### `umask` - Set Default Permissions
```bash
# Display current umask
$ umask
0022

# Set umask
$ umask 022     # Default: 755 for dirs, 644 for files

# Umask calculation
# Files: 666 - umask
# Dirs:  777 - umask

# Examples
$ umask 077     # Private: 700 for dirs, 600 for files
$ umask 002     # Group writable: 775 for dirs, 664 for files
```

---

## Process Management

### Theory: Processes in UNIX

**What is a Process?**
A process is an instance of a running program. Each process has:
- **PID (Process ID)** - Unique identifier
- **PPID (Parent Process ID)** - Parent that created it
- **UID/GID** - User and group ownership
- **Memory space** - Allocated RAM
- **File descriptors** - Open files/streams
- **Priority** - CPU scheduling importance
- **State** - Current execution status

**Process States:**
```
┌─────────────┐
│   Created   │
└──────┬──────┘
       ↓
┌─────────────┐
│    Ready    │ ←──────┐
└──────┬──────┘        │
       ↓               │
┌─────────────┐        │
│   Running   │        │
└──────┬──────┘        │
       ↓               │
    ┌──┴──┐            │
    ↓     ↓            │
┌───────┐ ┌────────┐   │
│Blocked│ │Stopped │   │
└───┬───┘ └────────┘   │
    └──────────────────┘
         ↓
    ┌─────────┐
    │Terminated│
    └─────────┘
```

- **Running (R)** - Currently executing
- **Sleeping (S)** - Waiting for event/resource
- **Stopped (T)** - Paused by signal
- **Zombie (Z)** - Finished but not cleaned up
- **Uninterruptible Sleep (D)** - Waiting for I/O

**Process Types:**

1. **Foreground Process**
   - Runs in current terminal
   - Blocks shell until complete
   - Receives keyboard input

2. **Background Process**
   - Runs independently
   - Shell remains available
   - Started with `&` or `bg` command

3. **Daemon Process**
   - System background service
   - No controlling terminal
   - Usually started at boot
   - Examples: httpd, sshd, crond

4. **Orphan Process**
   - Parent process terminated
   - Adopted by init (PID 1)

5. **Zombie Process**
   - Completed execution
   - Waiting for parent to read exit status
   - Shows as `<defunct>` in ps output

**Process Creation:**
```
Parent Process (PID: 1000)
         │
         │ fork()      Creates copy of parent
         ├─────────→   Child Process (PID: 1001)
         │             Same code, data, stack
         │
         │ exec()      Replaces process image
         └─────────→   New Program
```

**Process Priority:**
- **Nice Value**: -20 (highest) to +19 (lowest)
- Default nice value: 0
- Only root can set negative nice values
- Higher nice = lower priority = "nicer" to other processes

**Signals:**
Common signals for process control:

| Signal | Number | Default Action | Description |
|--------|--------|----------------|-------------|
| SIGHUP | 1 | Terminate | Hangup (terminal closed) |
| SIGINT | 2 | Terminate | Interrupt (Ctrl+C) |
| SIGQUIT | 3 | Core dump | Quit (Ctrl+\) |
| SIGKILL | 9 | Terminate | Cannot be caught/ignored |
| SIGTERM | 15 | Terminate | Graceful termination |
| SIGSTOP | 19 | Stop | Cannot be caught/ignored |
| SIGTSTP | 20 | Stop | Terminal stop (Ctrl+Z) |
| SIGCONT | 18 | Continue | Resume stopped process |

### Viewing Processes

#### `ps` - Process Status
```bash
# Current shell processes
$ ps

# All processes (BSD style)
$ ps aux

# All processes (UNIX style)
$ ps -ef

# Process tree
$ ps auxf

# Specific user processes
$ ps -u username

# Process by PID
$ ps -p 1234

# Detailed information
$ ps aux | head
USER       PID %CPU %MEM    VSZ   RSS TTY   STAT START TIME COMMAND
root         1  0.0  0.1 169416 13944 ?     Ss   Nov28 0:03 /sbin/init

# Find specific process
$ ps aux | grep apache
```

#### `top` - Dynamic Process Viewer
```bash
# Interactive process viewer
$ top

# Commands within top:
# k    - Kill process
# r    - Renice process
# f    - Select display fields
# o    - Change sort order
# u    - Filter by user
# M    - Sort by memory
# P    - Sort by CPU
# q    - Quit

# Run once and exit
$ top -n 1

# Monitor specific user
$ top -u username

# Set update interval (seconds)
$ top -d 5
```

#### `htop` - Enhanced Process Viewer
```bash
# Interactive, colorful viewer
$ htop

# Features:
# - Mouse support
# - Tree view (F5)
# - Search (F3)
# - Filter (F4)
# - Kill process (F9)
# - Color-coded
```

### Managing Processes

#### Background and Foreground
```bash
# Run in background
$ command &

# Send to background (Ctrl+Z, then)
$ bg

# Bring to foreground
$ fg

# List background jobs
$ jobs
[1]  - running    firefox
[2]  + running    gedit

# Bring specific job to foreground
$ fg %1

# Run in background (ignore hangup)
$ nohup command &

# Example: Long-running task
$ nohup ./long_script.sh > output.log 2>&1 &
```

#### `kill` - Terminate Processes
```bash
# Kill by PID
$ kill 1234

# Force kill
$ kill -9 1234
$ kill -SIGKILL 1234

# Graceful termination
$ kill -15 1234
$ kill -SIGTERM 1234

# Common signals
$ kill -l
# 1)  SIGHUP      2) SIGINT    9) SIGKILL   15) SIGTERM

# Kill by name
$ killall firefox

# Kill all user processes
$ pkill -u username

# Kill by pattern
$ pkill -f "python.*script"
```

#### Process Priority

##### `nice` - Start with Priority
```bash
# Priority range: -20 (highest) to 19 (lowest)
# Default: 0

# Start with low priority
$ nice -n 10 command

# Start with high priority (requires sudo)
$ sudo nice -n -10 command

# Examples
$ nice -n 15 tar -czf backup.tar.gz /data
```

##### `renice` - Change Priority
```bash
# Change priority of running process
$ renice -n 10 -p 1234

# Change for all processes of user
$ sudo renice -n 5 -u username

# Examples
$ renice -n 0 -p 1234
```

---

## Text Processing

### `grep` - Search Text Patterns
```bash
# Basic search
$ grep "pattern" file.txt

# Case-insensitive search
$ grep -i "pattern" file.txt

# Show line numbers
$ grep -n "pattern" file.txt

# Count matches
$ grep -c "pattern" file.txt

# Invert match (lines NOT containing pattern)
$ grep -v "pattern" file.txt

# Recursive search in directory
$ grep -r "pattern" /path/to/dir/

# Search only in specific file types
$ grep -r --include="*.txt" "pattern" .

# Show only filenames
$ grep -l "pattern" *.txt

# Show context (3 lines before and after)
$ grep -C 3 "pattern" file.txt

# Before context
$ grep -B 2 "pattern" file.txt

# After context
$ grep -A 2 "pattern" file.txt

# Regular expressions
$ grep "^start" file.txt        # Lines starting with "start"
$ grep "end$" file.txt          # Lines ending with "end"
$ grep "b.t" file.txt           # bat, bit, but, etc.
$ grep "colou\?r" file.txt      # color or colour

# Extended regex
$ grep -E "pattern1|pattern2" file.txt
$ grep -E "[0-9]{3}-[0-9]{4}" file.txt    # Phone numbers

# Whole word match
$ grep -w "word" file.txt

# Multiple patterns
$ grep -e "pattern1" -e "pattern2" file.txt

# Examples
$ grep -r "TODO" --include="*.js" src/
$ grep -n "error" /var/log/syslog | tail -20
$ ps aux | grep "apache"
```

### `sed` - Stream Editor
```bash
# Substitute (replace first occurrence)
$ sed 's/old/new/' file.txt

# Substitute all occurrences
$ sed 's/old/new/g' file.txt

# In-place editing (modify file)
$ sed -i 's/old/new/g' file.txt

# Create backup before editing
$ sed -i.bak 's/old/new/g' file.txt

# Delete lines
$ sed '5d' file.txt              # Delete line 5
$ sed '2,4d' file.txt            # Delete lines 2-4
$ sed '/pattern/d' file.txt      # Delete lines matching pattern

# Print specific lines
$ sed -n '1,5p' file.txt         # Print lines 1-5
$ sed -n '/pattern/p' file.txt   # Print matching lines

# Insert line before pattern
$ sed '/pattern/i\New line' file.txt

# Append line after pattern
$ sed '/pattern/a\New line' file.txt

# Multiple commands
$ sed -e 's/old/new/g' -e 's/foo/bar/g' file.txt

# Use different delimiter
$ sed 's|/old/path|/new/path|g' file.txt

# Examples
$ sed 's/http:/https:/g' urls.txt
$ sed -i 's/var /let /g' script.js
$ sed -n '/ERROR/,/END/p' log.txt
```

### `awk` - Text Processing Language
```bash
# Print entire file
$ awk '{print}' file.txt

# Print specific columns
$ awk '{print $1}' file.txt      # First column
$ awk '{print $1, $3}' file.txt  # First and third columns
$ awk '{print $NF}' file.txt     # Last column

# Custom delimiter
$ awk -F: '{print $1}' /etc/passwd    # Print usernames

# Pattern matching
$ awk '/pattern/ {print}' file.txt
$ awk '/pattern/ {print $2}' file.txt

# Conditions
$ awk '$3 > 100 {print $1, $3}' file.txt

# Built-in variables
$ awk '{print NR, $0}' file.txt      # Line number and line
$ awk '{print NF}' file.txt          # Number of fields

# BEGIN and END blocks
$ awk 'BEGIN {print "Start"} {print $1} END {print "End"}' file.txt

# Calculations
$ awk '{sum += $2} END {print sum}' file.txt
$ awk '{sum += $2} END {print sum/NR}' file.txt    # Average

# Examples
$ awk -F: '{print $1, $6}' /etc/passwd    # Users and home dirs
$ ps aux | awk '{print $2, $11}'          # PID and command
$ df -h | awk 'NR>1 {print $5, $6}'       # Disk usage
$ awk '{total += $1} END {print total}' numbers.txt
```

### `cut` - Extract Columns
```bash
# Cut by character position
$ cut -c 1-5 file.txt           # Characters 1-5
$ cut -c 1,5,9 file.txt         # Characters 1, 5, and 9

# Cut by delimiter (default: tab)
$ cut -f 1 file.txt             # First field
$ cut -f 1,3 file.txt           # Fields 1 and 3

# Custom delimiter
$ cut -d: -f1 /etc/passwd       # First field, colon delimiter
$ cut -d, -f2,4 data.csv        # CSV fields

# Complement (all except specified)
$ cut -d: -f1 --complement /etc/passwd

# Examples
$ echo "John,Doe,30" | cut -d, -f2
$ cut -d: -f1,6 /etc/passwd     # Username and home directory
```

### `sort` - Sort Lines
```bash
# Alphabetical sort
$ sort file.txt

# Reverse sort
$ sort -r file.txt

# Numeric sort
$ sort -n numbers.txt

# Sort by column
$ sort -k 2 file.txt            # Sort by 2nd column

# Unique lines only
$ sort -u file.txt

# Case-insensitive
$ sort -f file.txt

# Sort CSV by column
$ sort -t, -k2 data.csv

# Examples
$ ls -l | sort -k5 -n           # Sort files by size
$ cat file.txt | sort | uniq    # Remove duplicates
```

### `uniq` - Remove Duplicates
```bash
# Remove adjacent duplicates (use with sort)
$ sort file.txt | uniq

# Count occurrences
$ sort file.txt | uniq -c

# Show only duplicates
$ sort file.txt | uniq -d

# Show only unique lines
$ sort file.txt | uniq -u

# Ignore case
$ sort file.txt | uniq -i

# Examples
$ cat access.log | cut -d' ' -f1 | sort | uniq -c    # IP frequency
```

### `wc` - Word Count
```bash
# Count lines, words, bytes
$ wc file.txt
  10  50  250 file.txt

# Lines only
$ wc -l file.txt

# Words only
$ wc -w file.txt

# Characters only
$ wc -m file.txt

# Bytes only
$ wc -c file.txt

# Examples
$ ls | wc -l                    # Count files
$ grep "error" log.txt | wc -l  # Count errors
```

### `tr` - Translate Characters
```bash
# Convert lowercase to uppercase
$ echo "hello" | tr 'a-z' 'A-Z'
HELLO

# Delete characters
$ echo "hello123" | tr -d '0-9'
hello

# Squeeze repeated characters
$ echo "hello   world" | tr -s ' '
hello world

# Replace characters
$ echo "hello" | tr 'l' 'L'
heLLo

# Examples
$ cat file.txt | tr -d '\r'     # Remove carriage returns
$ echo $PATH | tr ':' '\n'      # Show PATH on separate lines
```

---

## Shell Scripting

### Theory: Shell Scripting Fundamentals

**What is a Shell?**
A shell is a command-line interpreter that:
- Accepts commands from users
- Interprets and executes commands
- Provides programming constructs (variables, loops, conditions)
- Acts as interface between user and kernel

**Shell Script Components:**

1. **Shebang (#!)** - Specifies interpreter
   ```bash
   #!/bin/bash      # Bash shell
   #!/bin/sh        # Bourne shell
   #!/usr/bin/env python3  # Python
   ```

2. **Comments** - Documentation
   ```bash
   # Single line comment
   : '
   Multi-line
   comment block
   '
   ```

3. **Variables** - Store data
   - No spaces around `=`
   - Case-sensitive
   - Use `$` to reference value

4. **Special Variables:**
   - `$0` - Script name
   - `$1-$9` - Positional parameters
   - `$#` - Number of arguments
   - `$@` - All arguments as separate strings
   - `$*` - All arguments as single string
   - `$$` - Current process PID
   - `$?` - Exit status of last command
   - `$!` - PID of last background process

**Exit Status:**
- `0` - Success
- `1-255` - Error (convention: 1 for general errors, 2 for misuse)

**Quoting:**
- **Single quotes (`'`)** - Literal string (no expansion)
- **Double quotes (`"`)** - Allows variable expansion
- **Backticks (`` ` ``)** - Command substitution (deprecated)
- **`$(command)`** - Command substitution (preferred)

**Example:**
```bash
VAR="World"
echo 'Hello $VAR'      # Output: Hello $VAR
echo "Hello $VAR"      # Output: Hello World
echo "Today is $(date)" # Command substitution
```

**Shell Script Best Practices:**
1. Always use shebang
2. Quote variables to handle spaces
3. Check command exit status
4. Use meaningful variable names
5. Add comments for complex logic
6. Use `set -e` to exit on errors
7. Use `set -u` to catch undefined variables
8. Use shellcheck for validation
9. Make scripts executable with `chmod +x`
10. Handle errors gracefully

### Basic Script Structure
```bash
#!/bin/bash
# Script description

# Variables
NAME="John"
AGE=30

# Output
echo "Hello, $NAME"
echo "Age: $AGE"

# Command substitution
CURRENT_DATE=$(date +%Y-%m-%d)
echo "Today is $CURRENT_DATE"
```

### Variables
```bash
#!/bin/bash

# Variable assignment (no spaces around =)
VAR="value"
NUM=42

# Read-only variable
readonly CONST="constant"

# Using variables
echo $VAR
echo ${VAR}

# Command substitution
FILES=$(ls)
TODAY=`date`

# Arithmetic
SUM=$((5 + 3))
RESULT=$((NUM * 2))

# String concatenation
FULL_NAME="$FIRST_NAME $LAST_NAME"

# Default values
echo ${VAR:-"default"}          # Use default if VAR is unset
echo ${VAR:="default"}          # Set VAR to default if unset

# String length
echo ${#VAR}

# Substring
echo ${VAR:0:5}                 # First 5 characters
```

### User Input
```bash
#!/bin/bash

# Basic input
echo "Enter your name:"
read NAME
echo "Hello, $NAME"

# Prompt and input in one line
read -p "Enter your age: " AGE

# Silent input (passwords)
read -sp "Enter password: " PASS
echo

# Read into array
echo "Enter values:"
read -a VALUES

# Timeout
read -t 10 -p "Quick! Enter something: " RESPONSE

# Example script
#!/bin/bash
read -p "Enter filename: " FILE
if [ -f "$FILE" ]; then
    echo "File exists"
    cat "$FILE"
else
    echo "File not found"
fi
```

### Conditional Statements
```bash
#!/bin/bash

# If-else statement
if [ $AGE -ge 18 ]; then
    echo "Adult"
else
    echo "Minor"
fi

# If-elif-else
if [ $SCORE -ge 90 ]; then
    echo "A"
elif [ $SCORE -ge 80 ]; then
    echo "B"
elif [ $SCORE -ge 70 ]; then
    echo "C"
else
    echo "F"
fi

# Test operators
# Numbers: -eq, -ne, -gt, -ge, -lt, -le
# Strings: =, !=, -z (empty), -n (not empty)
# Files: -f (file), -d (directory), -e (exists), -r (readable), -w (writable), -x (executable)

# File tests
if [ -f "file.txt" ]; then
    echo "File exists"
fi

if [ -d "directory" ]; then
    echo "Directory exists"
fi

# String tests
if [ -z "$VAR" ]; then
    echo "Variable is empty"
fi

if [ "$STR1" = "$STR2" ]; then
    echo "Strings are equal"
fi

# Logical operators
if [ $AGE -ge 18 ] && [ $AGE -le 65 ]; then
    echo "Working age"
fi

if [ $NUM -lt 0 ] || [ $NUM -gt 100 ]; then
    echo "Out of range"
fi

# Alternative syntax [[ ]]
if [[ $NAME == "John" && $AGE -ge 18 ]]; then
    echo "Adult John"
fi

# Case statement
case $CHOICE in
    1)
        echo "Option 1"
        ;;
    2)
        echo "Option 2"
        ;;
    3|4)
        echo "Option 3 or 4"
        ;;
    *)
        echo "Invalid option"
        ;;
esac
```

### Loops
```bash
#!/bin/bash

# For loop
for i in 1 2 3 4 5; do
    echo "Number: $i"
done

# For loop with range
for i in {1..10}; do
    echo $i
done

# For loop with step
for i in {0..100..10}; do
    echo $i
done

# C-style for loop
for ((i=0; i<5; i++)); do
    echo "Count: $i"
done

# For loop over files
for file in *.txt; do
    echo "Processing $file"
    cat "$file"
done

# While loop
COUNT=0
while [ $COUNT -lt 5 ]; do
    echo "Count: $COUNT"
    COUNT=$((COUNT + 1))
done

# While reading file
while read line; do
    echo "Line: $line"
done < file.txt

# Until loop
NUM=0
until [ $NUM -ge 5 ]; do
    echo "Number: $NUM"
    NUM=$((NUM + 1))
done

# Break and continue
for i in {1..10}; do
    if [ $i -eq 5 ]; then
        continue    # Skip 5
    fi
    if [ $i -eq 8 ]; then
        break       # Stop at 8
    fi
    echo $i
done
```

### Functions
```bash
#!/bin/bash

# Simple function
greet() {
    echo "Hello, World!"
}

# Call function
greet

# Function with parameters
greet_user() {
    echo "Hello, $1!"
}

greet_user "John"

# Function with return value
add() {
    local sum=$(($1 + $2))
    echo $sum
}

result=$(add 5 3)
echo "Sum: $result"

# Function with return status
check_file() {
    if [ -f "$1" ]; then
        return 0    # Success
    else
        return 1    # Failure
    fi
}

if check_file "test.txt"; then
    echo "File exists"
else
    echo "File not found"
fi

# Local variables
my_function() {
    local LOCAL_VAR="local"
    GLOBAL_VAR="global"
    echo $LOCAL_VAR
}

# Example: Complete script with functions
#!/bin/bash

# Function to backup files
backup_files() {
    local source=$1
    local dest=$2
    local timestamp=$(date +%Y%m%d_%H%M%S)
    
    echo "Starting backup..."
    tar -czf "${dest}/backup_${timestamp}.tar.gz" "$source"
    
    if [ $? -eq 0 ]; then
        echo "Backup successful"
        return 0
    else
        echo "Backup failed"
        return 1
    fi
}

# Main script
SOURCE_DIR="/home/user/documents"
BACKUP_DIR="/backup"

if backup_files "$SOURCE_DIR" "$BACKUP_DIR"; then
    echo "Backup completed successfully"
else
    echo "Backup failed" >&2
    exit 1
fi
```

### Arrays
```bash
#!/bin/bash

# Declare array
ARRAY=(apple banana cherry)

# Access elements
echo ${ARRAY[0]}        # apple
echo ${ARRAY[1]}        # banana

# All elements
echo ${ARRAY[@]}
echo ${ARRAY[*]}

# Array length
echo ${#ARRAY[@]}

# Add element
ARRAY+=(date)

# Iterate over array
for fruit in "${ARRAY[@]}"; do
    echo "Fruit: $fruit"
done

# Associative array (hash/dictionary)
declare -A PERSON
PERSON[name]="John"
PERSON[age]=30
PERSON[city]="NYC"

echo ${PERSON[name]}
echo ${PERSON[@]}       # All values
echo ${!PERSON[@]}      # All keys
```

### Script Arguments
```bash
#!/bin/bash

# Command line arguments
echo "Script name: $0"
echo "First argument: $1"
echo "Second argument: $2"
echo "All arguments: $@"
echo "Number of arguments: $#"

# Check if argument provided
if [ $# -eq 0 ]; then
    echo "No arguments provided"
    echo "Usage: $0 <filename>"
    exit 1
fi

# Example: File processor
#!/bin/bash

if [ $# -ne 1 ]; then
    echo "Usage: $0 <filename>"
    exit 1
fi

FILE=$1

if [ ! -f "$FILE" ]; then
    echo "Error: File not found"
    exit 1
fi

echo "Processing $FILE..."
wc -l "$FILE"
```

### Error Handling
```bash
#!/bin/bash

# Exit on error
set -e

# Exit on undefined variable
set -u

# Pipe failure detection
set -o pipefail

# Combined
set -euo pipefail

# Check command success
if ! command; then
    echo "Command failed" >&2
    exit 1
fi

# Check exit status
command
if [ $? -eq 0 ]; then
    echo "Success"
else
    echo "Failed"
fi

# Trap errors
trap 'echo "Error occurred on line $LINENO"' ERR

# Cleanup on exit
cleanup() {
    echo "Cleaning up..."
    rm -f /tmp/tempfile
}

trap cleanup EXIT

# Example with error handling
#!/bin/bash

set -e

error_exit() {
    echo "Error: $1" >&2
    exit 1
}

FILE=$1

[ -f "$FILE" ] || error_exit "File not found: $FILE"
[ -r "$FILE" ] || error_exit "File not readable: $FILE"

echo "Processing $FILE..."
# ... rest of script
```

---

## Networking

### Network Information

#### `ifconfig` / `ip` - Network Configuration
```bash
# Show all interfaces (ifconfig - deprecated)
$ ifconfig

# Show all interfaces (ip)
$ ip addr
$ ip a

# Show specific interface
$ ip addr show eth0

# Show routing table
$ ip route
$ route -n

# Show ARP table
$ ip neigh
$ arp -a
```

#### `netstat` - Network Statistics
```bash
# Show all connections
$ netstat -a

# Show listening ports
$ netstat -l

# Show TCP connections
$ netstat -t

# Show UDP connections
$ netstat -u

# Show program names
$ netstat -p

# Combined (listening TCP with programs)
$ netstat -tlnp

# Show routing table
$ netstat -r

# Show network statistics
$ netstat -s
```

#### `ss` - Socket Statistics (modern netstat)
```bash
# Show all sockets
$ ss -a

# Show listening sockets
$ ss -l

# Show TCP sockets
$ ss -t

# Show UDP sockets
$ ss -u

# Show process information
$ ss -p

# Combined
$ ss -tlnp

# Show summary
$ ss -s
```

### Network Testing

#### `ping` - Test Connectivity
```bash
# Ping host
$ ping google.com

# Ping with count
$ ping -c 4 google.com

# Ping with interval
$ ping -i 2 google.com

# Ping with size
$ ping -s 1000 google.com

# Ping IPv6
$ ping6 google.com
```

#### `traceroute` - Trace Network Path
```bash
# Trace route to host
$ traceroute google.com

# Use ICMP instead of UDP
$ traceroute -I google.com

# Specify max hops
$ traceroute -m 20 google.com
```

#### `nslookup` / `dig` - DNS Lookup
```bash
# nslookup
$ nslookup google.com

# Reverse lookup
$ nslookup 8.8.8.8

# dig (more detailed)
$ dig google.com

# Short answer
$ dig +short google.com

# Specific record type
$ dig google.com MX
$ dig google.com AAAA

# Reverse lookup
$ dig -x 8.8.8.8

# Trace DNS resolution
$ dig +trace google.com
```

#### `curl` - Transfer Data
```bash
# GET request
$ curl https://api.example.com

# Save to file
$ curl -o output.html https://example.com

# Follow redirects
$ curl -L https://example.com

# Show headers
$ curl -I https://example.com

# POST request
$ curl -X POST -d "param=value" https://api.example.com

# POST JSON
$ curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"name":"John","age":30}' \
  https://api.example.com

# Authentication
$ curl -u username:password https://api.example.com

# Custom header
$ curl -H "Authorization: Bearer token" https://api.example.com

# Upload file
$ curl -F "file=@document.pdf" https://upload.example.com

# Download with progress
$ curl -O https://example.com/file.zip

# Resume download
$ curl -C - -O https://example.com/large-file.zip
```

#### `wget` - Download Files
```bash
# Download file
$ wget https://example.com/file.zip

# Custom filename
$ wget -O myfile.zip https://example.com/file.zip

# Resume download
$ wget -c https://example.com/file.zip

# Background download
$ wget -b https://example.com/file.zip

# Recursive download (website)
$ wget -r -l 2 https://example.com

# Mirror website
$ wget --mirror --convert-links --adjust-extension --page-requisites \
  --no-parent https://example.com

# Download with authentication
$ wget --user=username --password=password https://example.com/file.zip

# Limit rate
$ wget --limit-rate=200k https://example.com/file.zip
```

### SSH - Secure Shell

```bash
# Connect to remote host
$ ssh user@hostname

# Connect on specific port
$ ssh -p 2222 user@hostname

# Execute command remotely
$ ssh user@hostname "ls -la"

# SSH with key
$ ssh -i ~/.ssh/private_key user@hostname

# Copy files (scp)
$ scp local_file user@hostname:/remote/path
$ scp user@hostname:/remote/file local_path

# Recursive copy
$ scp -r local_dir user@hostname:/remote/path

# Copy via intermediate host
$ scp -o ProxyJump=jump_host file user@target:/path

# SSH tunnel (port forwarding)
$ ssh -L 8080:localhost:80 user@hostname

# Reverse tunnel
$ ssh -R 8080:localhost:80 user@hostname

# Generate SSH key
$ ssh-keygen -t rsa -b 4096 -C "email@example.com"

# Copy public key to server
$ ssh-copy-id user@hostname
```

---

## System Administration

### System Information

#### `uname` - System Information
```bash
# System name
$ uname

# All information
$ uname -a

# Kernel version
$ uname -r

# Machine hardware
$ uname -m

# Processor type
$ uname -p

# Operating system
$ uname -o
```

#### `df` - Disk Space
```bash
# Show disk usage
$ df

# Human-readable sizes
$ df -h

# Show file system type
$ df -T

# Show inodes
$ df -i

# Specific filesystem
$ df -h /home
```

#### `du` - Directory Usage
```bash
# Show directory size
$ du /path/to/dir

# Human-readable
$ du -h /path/to/dir

# Summary only
$ du -sh /path/to/dir

# Show all files
$ du -ah /path/to/dir

# Limit depth
$ du -h --max-depth=1 /path/to/dir

# Sort by size
$ du -h | sort -h

# Top 10 largest
$ du -ah | sort -rh | head -10
```

#### `free` - Memory Usage
```bash
# Show memory usage
$ free

# Human-readable
$ free -h

# Show in MB
$ free -m

# Continuous display
$ free -h -s 5
```

### User Management

#### `useradd` - Add User
```bash
# Add user
$ sudo useradd newuser

# With home directory
$ sudo useradd -m newuser

# Specify shell
$ sudo useradd -m -s /bin/bash newuser

# With specific UID
$ sudo useradd -m -u 1500 newuser

# Add to groups
$ sudo useradd -m -G sudo,docker newuser

# Complete example
$ sudo useradd -m -s /bin/bash -G sudo -c "John Doe" johndoe
```

#### `usermod` - Modify User
```bash
# Change username
$ sudo usermod -l newname oldname

# Change home directory
$ sudo usermod -d /new/home -m username

# Change shell
$ sudo usermod -s /bin/zsh username

# Add to group
$ sudo usermod -aG groupname username

# Lock account
$ sudo usermod -L username

# Unlock account
$ sudo usermod -U username
```

#### `userdel` - Delete User
```bash
# Delete user
$ sudo userdel username

# Delete with home directory
$ sudo userdel -r username
```

#### `passwd` - Change Password
```bash
# Change own password
$ passwd

# Change another user's password
$ sudo passwd username

# Lock account
$ sudo passwd -l username

# Unlock account
$ sudo passwd -u username

# Delete password (no password login)
$ sudo passwd -d username
```

#### `groups` - User Groups
```bash
# Show current user groups
$ groups

# Show specific user groups
$ groups username

# Add group
$ sudo groupadd developers

# Delete group
$ sudo groupdel developers

# Add user to group
$ sudo usermod -aG developers username
```

### System Monitoring

#### `dmesg` - Kernel Messages
```bash
# Show all kernel messages
$ dmesg

# Human-readable timestamps
$ dmesg -T

# Follow new messages
$ dmesg -w

# Filter by facility
$ dmesg -f kern

# Clear buffer
$ sudo dmesg -C
```

#### `journalctl` - System Logs (systemd)
```bash
# Show all logs
$ journalctl

# Follow logs (like tail -f)
$ journalctl -f

# Show kernel messages
$ journalctl -k

# Show logs for specific unit
$ journalctl -u nginx.service

# Show logs since boot
$ journalctl -b

# Show logs for specific time
$ journalctl --since "2025-11-29 10:00:00"
$ journalctl --since "1 hour ago"

# Show priority errors
$ journalctl -p err

# Disk usage
$ journalctl --disk-usage
```

#### `cron` - Scheduled Tasks
```bash
# Edit crontab
$ crontab -e

# List crontab
$ crontab -l

# Remove crontab
$ crontab -r

# Crontab format
# * * * * * command
# │ │ │ │ │
# │ │ │ │ └─ Day of week (0-7, Sunday=0 or 7)
# │ │ │ └─── Month (1-12)
# │ │ └───── Day of month (1-31)
# │ └─────── Hour (0-23)
# └───────── Minute (0-59)

# Examples
# Run every minute
* * * * * /path/to/script.sh

# Run every day at 2:30 AM
30 2 * * * /path/to/backup.sh

# Run every Monday at 9 AM
0 9 * * 1 /path/to/weekly.sh

# Run every 15 minutes
*/15 * * * * /path/to/script.sh

# Run on first day of month
0 0 1 * * /path/to/monthly.sh
```

### Package Management

#### Debian/Ubuntu (apt)
```bash
# Update package list
$ sudo apt update

# Upgrade packages
$ sudo apt upgrade

# Full upgrade
$ sudo apt full-upgrade

# Install package
$ sudo apt install package_name

# Remove package
$ sudo apt remove package_name

# Remove with config files
$ sudo apt purge package_name

# Search for package
$ apt search keyword

# Show package info
$ apt show package_name

# List installed packages
$ apt list --installed

# Clean package cache
$ sudo apt clean
$ sudo apt autoclean

# Remove unused packages
$ sudo apt autoremove
```

#### Red Hat/CentOS (yum/dnf)
```bash
# Update package list
$ sudo yum update

# Install package
$ sudo yum install package_name

# Remove package
$ sudo yum remove package_name

# Search for package
$ yum search keyword

# Show package info
$ yum info package_name

# List installed packages
$ yum list installed

# Clean cache
$ sudo yum clean all
```

---

## Advanced Commands

### `find` - Search for Files
```bash
# Find by name
$ find /path -name "filename"

# Case-insensitive
$ find /path -iname "filename"

# Find by type (f=file, d=directory, l=link)
$ find /path -type f

# Find by extension
$ find /path -name "*.txt"

# Find by size
$ find /path -size +100M        # Larger than 100MB
$ find /path -size -1M          # Smaller than 1MB

# Find by modification time
$ find /path -mtime -7          # Modified in last 7 days
$ find /path -mtime +30         # Modified more than 30 days ago

# Find by permissions
$ find /path -perm 644

# Find and execute command
$ find /path -name "*.log" -exec rm {} \;

# Find and delete
$ find /path -name "*.tmp" -delete

# Find empty files
$ find /path -type f -empty

# Find and list with details
$ find /path -name "*.txt" -ls

# Multiple conditions (AND)
$ find /path -name "*.txt" -size +1M

# Multiple conditions (OR)
$ find /path \( -name "*.txt" -o -name "*.log" \)

# Exclude directory
$ find /path -name "*.txt" -not -path "*/node_modules/*"

# Examples
$ find . -name "*.js" -mtime -1    # JS files modified today
$ find /tmp -type f -atime +30 -delete    # Delete old temp files
$ find . -type f -perm 777 -exec chmod 644 {} \;
```

### `xargs` - Build Command Arguments
```bash
# Basic usage
$ echo "file1 file2 file3" | xargs rm

# Find and process
$ find . -name "*.txt" | xargs wc -l

# Specify delimiter
$ echo "file1,file2,file3" | xargs -d, rm

# Execute command per item
$ find . -name "*.txt" | xargs -I {} cp {} /backup/

# Limit arguments per command
$ find . -name "*.txt" | xargs -n 1 echo "Processing:"

# Parallel execution
$ find . -name "*.jpg" | xargs -P 4 -I {} convert {} {}.png

# Handle spaces in filenames
$ find . -name "*.txt" -print0 | xargs -0 rm

# Examples
$ cat urls.txt | xargs -n 1 curl -O
$ find . -name "*.log" | xargs -I {} gzip {}
```

### `tar` - Archive Files
```bash
# Create archive
$ tar -cf archive.tar files/

# Create gzip compressed archive
$ tar -czf archive.tar.gz files/

# Create bzip2 compressed archive
$ tar -cjf archive.tar.bz2 files/

# Extract archive
$ tar -xf archive.tar

# Extract to specific directory
$ tar -xf archive.tar -C /path/to/dir

# Extract gzip archive
$ tar -xzf archive.tar.gz

# List contents
$ tar -tf archive.tar

# Verbose output
$ tar -czf archive.tar.gz -v files/

# Exclude files
$ tar -czf archive.tar.gz --exclude="*.log" files/

# Append to existing archive
$ tar -rf archive.tar newfile

# Examples
$ tar -czf backup_$(date +%Y%m%d).tar.gz /home/user/
$ tar -xzf archive.tar.gz --strip-components=1
```

### `rsync` - Sync Files
```bash
# Sync local directories
$ rsync -av source/ destination/

# Sync to remote host
$ rsync -av source/ user@remote:/path/

# Sync from remote host
$ rsync -av user@remote:/path/ local/

# Show progress
$ rsync -av --progress source/ destination/

# Delete files in destination not in source
$ rsync -av --delete source/ destination/

# Dry run (test without changes)
$ rsync -avn source/ destination/

# Exclude files
$ rsync -av --exclude="*.tmp" source/ destination/

# Include/exclude patterns
$ rsync -av --include="*/" --include="*.txt" --exclude="*" source/ dest/

# Preserve everything
$ rsync -aAXv source/ destination/

# Bandwidth limit
$ rsync -av --bwlimit=1000 source/ destination/

# Examples
$ rsync -av --delete /data/ /backup/data/
$ rsync -avz --progress ~/project/ user@server:~/project/
```

### `ln` - Create Links
```bash
# Create symbolic link
$ ln -s target linkname

# Create hard link
$ ln target linkname

# Force (overwrite existing)
$ ln -sf target linkname

# Create link in directory
$ ln -s /path/to/file /usr/local/bin/

# Examples
$ ln -s /usr/local/bin/python3 /usr/local/bin/python
$ ln -s ~/Documents/project ~/Desktop/project
```

### `alias` - Command Shortcuts
```bash
# Create alias
$ alias ll='ls -lah'
$ alias ..='cd ..'
$ alias update='sudo apt update && sudo apt upgrade'

# Show all aliases
$ alias

# Remove alias
$ unalias ll

# Permanent aliases (add to ~/.bashrc or ~/.bash_aliases)
$ echo "alias ll='ls -lah'" >> ~/.bashrc
$ source ~/.bashrc

# Common useful aliases
alias grep='grep --color=auto'
alias df='df -h'
alias free='free -h'
alias mkdir='mkdir -pv'
alias ports='netstat -tulanp'
```

### Environment Variables
```bash
# Show all variables
$ printenv
$ env

# Show specific variable
$ echo $HOME
$ echo $PATH

# Set variable (current session)
$ export VAR="value"

# Permanent (add to ~/.bashrc)
$ echo 'export VAR="value"' >> ~/.bashrc
$ source ~/.bashrc

# Append to PATH
$ export PATH=$PATH:/new/path

# Common variables
echo $USER      # Current user
echo $HOME      # Home directory
echo $PWD       # Current directory
echo $SHELL     # Current shell
echo $PATH      # Executable search paths
```

---

## Summary and Best Practices

### Command Combinations (Pipelines)
```bash
# Count files in directory
$ ls | wc -l

# Find largest files
$ du -ah | sort -rh | head -10

# Find and count occurrences
$ grep -r "pattern" . | wc -l

# Process log file
$ cat access.log | grep "404" | awk '{print $1}' | sort | uniq -c | sort -rn

# Find process by name and kill
$ ps aux | grep "process_name" | awk '{print $2}' | xargs kill

# Disk usage by directory
$ du -sh */ | sort -h

# Active network connections by IP
$ netstat -an | grep ESTABLISHED | awk '{print $5}' | cut -d: -f1 | sort | uniq -c | sort -rn
```

### Redirection
```bash
# Output redirection
$ command > file.txt        # Overwrite
$ command >> file.txt       # Append

# Error redirection
$ command 2> error.txt      # Stderr to file
$ command 2>&1              # Stderr to stdout

# Both stdout and stderr
$ command &> output.txt
$ command > output.txt 2>&1

# Discard output
$ command > /dev/null       # Discard stdout
$ command 2> /dev/null      # Discard stderr
$ command &> /dev/null      # Discard all

# Input redirection
$ command < input.txt

# Here document
$ cat << EOF > file.txt
Line 1
Line 2
EOF
```

### Best Practices

1. **Always backup before destructive operations**
```bash
$ cp file.txt file.txt.backup
$ tar -czf backup.tar.gz important_dir/
```

2. **Use quotes for variables**
```bash
$ rm "$FILE"           # Good
$ rm $FILE             # Can break with spaces
```

3. **Check command success**
```bash
$ if [ $? -eq 0 ]; then
    echo "Success"
fi
```

4. **Use absolute paths in scripts**
```bash
$ /usr/bin/python3 script.py
```

5. **Make scripts executable**
```bash
$ chmod +x script.sh
```

6. **Add shebang to scripts**
```bash
#!/bin/bash
```

7. **Use shellcheck for script validation**
```bash
$ shellcheck script.sh
```

8. **Document your scripts**
```bash
#!/bin/bash
# Script: backup.sh
# Description: Backs up important files
# Author: Your Name
# Date: 2025-11-29
```

---

## Quick Reference Card

### Most Used Commands
```bash
# Navigation
pwd, cd, ls

# Files
cat, less, head, tail, touch, cp, mv, rm, mkdir

# Search
find, grep, locate

# Text Processing
awk, sed, cut, sort, uniq, wc, tr

# Permissions
chmod, chown, chgrp

# Processes
ps, top, kill, bg, fg, jobs

# System
df, du, free, uname, uptime

# Networking
ping, curl, wget, ssh, scp

# Compression
tar, gzip, gunzip, zip, unzip
```

### Keyboard Shortcuts
```bash
Ctrl+C    # Kill current process
Ctrl+Z    # Suspend process
Ctrl+D    # Exit shell/EOF
Ctrl+L    # Clear screen
Ctrl+A    # Beginning of line
Ctrl+E    # End of line
Ctrl+R    # Search history
Tab       # Auto-complete
!!        # Repeat last command
!$        # Last argument of previous command
```

---

## Interview Questions & Answers

### Basic Level Questions

#### Q1: What is UNIX and what are its key features?
**Answer:**
UNIX is a powerful, multi-user, multitasking operating system developed at AT&T Bell Labs in the 1960s-70s. 

**Key features:**
- **Multi-user**: Multiple users can access simultaneously
- **Multitasking**: Can run multiple processes concurrently
- **Portability**: Written in C, easily adapted to different hardware
- **Hierarchical File System**: Tree structure starting from root (/)
- **Security**: Strong permission and authentication model
- **Pipes and Filters**: Commands can be chained together
- **Shell Programming**: Powerful scripting capabilities

#### Q2: What is the difference between UNIX and Linux?
**Answer:**

| Aspect | UNIX | Linux |
|--------|------|-------|
| **Origin** | AT&T Bell Labs | Linus Torvalds (1991) |
| **License** | Proprietary | Open Source (GPL) |
| **Cost** | Commercial | Free |
| **Source Code** | Closed (mostly) | Open |
| **Examples** | Solaris, AIX, HP-UX, BSD | Ubuntu, CentOS, Debian, RedHat |
| **Kernel** | Original UNIX kernel variants | Linux kernel |
| **Support** | Vendor-specific | Community + Commercial |

Linux is a UNIX-like operating system but not certified UNIX.

#### Q3: Explain the UNIX file system hierarchy.
**Answer:**
```
/               Root directory (top of hierarchy)
├── bin         Essential command binaries (ls, cp, mv)
├── boot        Boot loader files (kernel, initrd)
├── dev         Device files (hardware interfaces)
├── etc         System configuration files
├── home        User home directories (/home/username)
├── lib         Shared libraries needed by binaries
├── media       Mount points for removable media
├── mnt         Temporary mount points
├── opt         Optional/third-party software
├── proc        Virtual filesystem (process/kernel info)
├── root        Root user's home directory
├── sbin        System binaries (admin commands)
├── tmp         Temporary files (cleared on reboot)
├── usr         User programs and data
│   ├── bin     User command binaries
│   ├── lib     Libraries for /usr/bin
│   ├── local   Locally installed software
│   └── share   Architecture-independent data
└── var         Variable data (logs, mail, databases)
    ├── log     Log files
    ├── tmp     Temporary files preserved between reboots
    └── www     Web server files
```

#### Q4: What is an inode?
**Answer:**
An **inode** (index node) is a data structure that stores metadata about a file, but NOT the filename or data itself.

**Inode contains:**
- File size
- Owner UID and GID
- File permissions (rwx)
- Timestamps (created, modified, accessed)
- Number of hard links
- Pointers to data blocks on disk
- File type (regular, directory, link, etc.)

**Key points:**
- Every file has a unique inode number
- Filename is stored in directory, mapped to inode
- `ls -i` shows inode numbers
- Multiple filenames can point to same inode (hard links)
- Deleting a file removes directory entry, but inode remains until all links are deleted

```bash
$ ls -li myfile.txt
1234567 -rw-r--r-- 1 user group 1024 Nov 29 10:30 myfile.txt
        ↑ inode number
```

#### Q5: What is the difference between hard link and soft link (symbolic link)?
**Answer:**

| Feature | Hard Link | Soft Link (Symbolic Link) |
|---------|-----------|---------------------------|
| **Inode** | Points to same inode | Has its own inode |
| **Command** | `ln file link` | `ln -s file link` |
| **Cross Filesystem** | No | Yes |
| **Directory Linking** | No (except root) | Yes |
| **Original Deletion** | Link still works | Link breaks (dangling) |
| **File Size** | Same as original | Small (path length) |
| **Disk Space** | No additional | Minimal |
| **Permissions** | Same as original | Always `lrwxrwxrwx` |

**Example:**
```bash
# Create files
$ echo "Hello" > original.txt

# Hard link
$ ln original.txt hardlink.txt
$ ls -li
1234567 -rw-r--r-- 2 user group 6 Nov 29 10:30 original.txt
1234567 -rw-r--r-- 2 user group 6 Nov 29 10:30 hardlink.txt
        ↑ Same inode number

# Soft link
$ ln -s original.txt softlink.txt
$ ls -li
1234567 -rw-r--r-- 2 user group 6 Nov 29 10:30 original.txt
7654321 lrwxrwxrwx 1 user group 12 Nov 29 10:31 softlink.txt -> original.txt
        ↑ Different inode

# Delete original
$ rm original.txt
$ cat hardlink.txt      # Still works
Hello
$ cat softlink.txt      # Breaks
cat: softlink.txt: No such file or directory
```

#### Q6: Explain file permissions in UNIX.
**Answer:**
UNIX has a 10-character permission string:
```
-rwxr-xr--
│││││││││└─ Others: read (r), no write (-), no execute (-)
││││││││└── Group: read (r), no write (-), execute (x)
│││││││└─── User/Owner: read (r), write (w), execute (x)
││││││└──── File type: - (file), d (directory), l (link)
```

**Permission Values:**
- **r (read) = 4**: View file contents / List directory
- **w (write) = 2**: Modify file / Create/delete files in directory
- **x (execute) = 1**: Run as program / Enter directory

**Numeric representation:**
```
rwx = 4+2+1 = 7
rw- = 4+2+0 = 6
r-x = 4+0+1 = 5
r-- = 4+0+0 = 4
--- = 0+0+0 = 0

chmod 755 file  # rwxr-xr-x
chmod 644 file  # rw-r--r--
chmod 600 file  # rw-------
```

#### Q7: What is the purpose of the `chmod` command?
**Answer:**
`chmod` (change mode) modifies file/directory permissions.

**Syntax:**
```bash
chmod [options] mode file

# Numeric mode
chmod 755 script.sh      # rwxr-xr-x
chmod 644 file.txt       # rw-r--r--

# Symbolic mode
chmod u+x script.sh      # Add execute for user
chmod g-w file.txt       # Remove write for group
chmod o+r file.txt       # Add read for others
chmod a+x script.sh      # Add execute for all

# Recursive
chmod -R 755 directory/

# Who: u(user), g(group), o(others), a(all)
# What: +(add), -(remove), =(set exactly)
# Permission: r(read), w(write), x(execute)
```

#### Q8: What is a shell in UNIX?
**Answer:**
A **shell** is a command-line interpreter that acts as an interface between the user and the UNIX kernel.

**Functions:**
1. Accepts commands from user
2. Interprets and executes commands
3. Provides programming features (variables, loops, conditions)
4. Manages input/output redirection
5. Handles job control (background/foreground)

**Common shells:**
- **sh** (Bourne Shell) - Original shell
- **bash** (Bourne Again Shell) - Most popular, default on Linux
- **csh** (C Shell) - C-like syntax
- **ksh** (Korn Shell) - Enhanced sh
- **zsh** (Z Shell) - Modern, feature-rich

**Check your shell:**
```bash
$ echo $SHELL
/bin/bash

$ echo $0
bash
```

### Intermediate Level Questions

#### Q9: What is a process in UNIX? Explain process states.
**Answer:**
A **process** is an instance of a running program with its own memory space, PID, and resources.

**Process States:**
1. **Running (R)**: Currently executing on CPU
2. **Sleeping/Waiting (S)**: Waiting for event (I/O, resource)
3. **Stopped (T)**: Suspended (Ctrl+Z)
4. **Zombie (Z)**: Terminated but not cleaned up by parent
5. **Uninterruptible Sleep (D)**: Waiting for I/O (cannot be interrupted)

**Process Information:**
```bash
$ ps aux
USER  PID  %CPU %MEM    VSZ   RSS TTY  STAT START  TIME COMMAND
user  1234  0.5  1.2  45678  9876 pts/0 R+  10:30  0:05 python script.py
      ↑PID       ↑%CPU ↑%MEM              ↑State
```

**State Codes:**
- `R` - Running
- `S` - Sleeping
- `D` - Uninterruptible sleep
- `T` - Stopped
- `Z` - Zombie
- `<` - High priority
- `N` - Low priority
- `+` - Foreground process
- `s` - Session leader
- `l` - Multi-threaded

#### Q10: What is the difference between `kill` and `kill -9`?
**Answer:**

| Command | Signal | Name | Behavior |
|---------|--------|------|----------|
| `kill PID` | 15 | SIGTERM | Graceful termination (can be caught) |
| `kill -9 PID` | 9 | SIGKILL | Forceful termination (cannot be caught) |

**SIGTERM (15) - Default:**
- Allows process to clean up (close files, save state)
- Process can catch signal and decide how to terminate
- Preferred method for stopping processes

**SIGKILL (9) - Force:**
- Immediately terminates process
- Cannot be caught, blocked, or ignored
- No cleanup performed
- Use as last resort

**Other common signals:**
```bash
kill -1 PID   # SIGHUP (restart/reload config)
kill -2 PID   # SIGINT (Ctrl+C)
kill -15 PID  # SIGTERM (graceful termination)
kill -9 PID   # SIGKILL (force kill)
kill -19 PID  # SIGSTOP (pause process)
kill -18 PID  # SIGCONT (resume process)

# List all signals
kill -l
```

#### Q11: Explain the difference between `ps` and `top` commands.
**Answer:**

**`ps` (Process Status):**
- Static snapshot of processes at moment of execution
- Shows processes once
- Can filter by user, PID, command
- Output can be piped to other commands

```bash
$ ps aux          # All processes
$ ps -ef          # Full format
$ ps -u username  # User's processes
```

**`top` (Table of Processes):**
- Dynamic, real-time process viewer
- Continuously updates (default: 3 seconds)
- Interactive (can kill, renice processes)
- Shows CPU/memory usage
- Sorted by CPU usage by default

```bash
$ top
# Press 'k' to kill process
# Press 'r' to renice
# Press 'M' to sort by memory
# Press 'q' to quit
```

**Comparison:**

| Feature | ps | top |
|---------|----|----|
| Display | Static | Dynamic |
| Update | Once | Continuous |
| Interactive | No | Yes |
| CPU Usage | Moment | Real-time average |
| Output | Can pipe | Terminal only |
| Best for | Scripting | Monitoring |

#### Q12: What is the difference between `grep`, `egrep`, and `fgrep`?
**Answer:**

| Command | Type | Description | Example |
|---------|------|-------------|---------|
| `grep` | Basic regex | Searches using basic regular expressions | `grep "pattern" file` |
| `egrep` | Extended regex | Extended regex (same as `grep -E`) | `egrep "pat1\|pat2" file` |
| `fgrep` | Fixed string | No regex, literal strings (same as `grep -F`) | `fgrep "*.txt" file` |

**grep - Basic Regular Expressions:**
```bash
$ grep "error" log.txt           # Simple match
$ grep "^ERROR" log.txt          # Line starts with ERROR
$ grep "failed$" log.txt         # Line ends with failed
$ grep "err.*failed" log.txt     # err followed by failed
```

**egrep - Extended Regular Expressions:**
```bash
$ egrep "error|warning" log.txt  # OR operator (no escaping)
$ egrep "(error|warn):" log.txt  # Grouping
$ egrep "[0-9]+" log.txt         # One or more digits
$ egrep "error{2,}" log.txt      # "error" appearing 2+ times

# Same as grep -E
$ grep -E "error|warning" log.txt
```

**fgrep - Fixed String (Literal):**
```bash
$ fgrep "*.txt" file             # Searches for literal "*.txt"
$ fgrep "$100" file              # Searches for literal "$100"
$ fgrep "[error]" file           # Searches for literal "[error]"

# Same as grep -F
$ grep -F "*.txt" file

# Faster than grep for literal strings (no regex parsing)
```

#### Q13: Explain piping and redirection in UNIX.
**Answer:**

**Piping (|):**
Sends output of one command as input to another.
```bash
# Chain commands
$ ls -l | grep "txt" | wc -l     # Count .txt files

$ ps aux | grep "apache" | awk '{print $2}'  # Get Apache PIDs

$ cat file.txt | sort | uniq     # Remove duplicates
```

**Redirection:**

| Operator | Description | Example |
|----------|-------------|---------|
| `>` | Redirect stdout (overwrite) | `echo "text" > file.txt` |
| `>>` | Redirect stdout (append) | `echo "text" >> file.txt` |
| `<` | Redirect stdin | `command < input.txt` |
| `2>` | Redirect stderr | `command 2> error.log` |
| `2>&1` | Redirect stderr to stdout | `command > output.txt 2>&1` |
| `&>` | Redirect both stdout/stderr | `command &> output.txt` |
| `\|&` | Pipe stdout and stderr | `command \|& grep error` |

**Examples:**
```bash
# Save output to file
$ ls -l > files.txt

# Append to file
$ date >> log.txt

# Discard output
$ command > /dev/null

# Redirect errors
$ command 2> errors.txt

# Redirect both
$ command > output.txt 2>&1
$ command &> output.txt

# Here document
$ cat << EOF > file.txt
Line 1
Line 2
EOF

# Here string
$ grep "pattern" <<< "Search this string"
```

#### Q14: What is the difference between `find` and `locate`?
**Answer:**

| Feature | find | locate |
|---------|------|--------|
| **Search Method** | Searches filesystem in real-time | Searches pre-built database |
| **Speed** | Slower (reads disk) | Faster (reads database) |
| **Accuracy** | Always current | May be outdated |
| **Search Criteria** | Extensive (name, size, time, permissions) | Primarily by name |
| **Actions** | Can execute commands on results | Only lists results |
| **Database** | Not needed | Requires updatedb |
| **New Files** | Finds immediately | Finds after db update |

**find - Real-time Search:**
```bash
$ find /path -name "*.txt"                    # By name
$ find /path -type f -size +100M              # Large files
$ find /path -mtime -7                        # Modified in last 7 days
$ find /path -perm 644                        # By permissions
$ find /path -user john                       # By owner
$ find /path -name "*.log" -exec rm {} \;     # Execute command
$ find /path -name "*.txt" -delete            # Delete matches
```

**locate - Database Search:**
```bash
$ locate filename                             # Fast search
$ locate -i filename                          # Case-insensitive
$ locate "*.conf" | grep "/etc/"              # Filter results

# Update database (run as root)
$ sudo updatedb

# Database location: /var/lib/mlocate/mlocate.db
```

**When to use:**
- **find**: Need current results, complex criteria, execute actions
- **locate**: Quick filename search, don't need absolute precision

#### Q15: What is the difference between `&&` and `||` operators?
**Answer:**

**`&&` (AND Operator):**
Execute next command only if previous succeeds (exit status 0).

```bash
# Compile and run only if compilation succeeds
$ gcc program.c -o program && ./program

# Create directory and enter it
$ mkdir mydir && cd mydir

# Multiple commands
$ command1 && command2 && command3
# command2 runs only if command1 succeeds
# command3 runs only if command2 succeeds
```

**`||` (OR Operator):**
Execute next command only if previous fails (exit status non-zero).

```bash
# Try to copy, show error if fails
$ cp file.txt /backup/ || echo "Copy failed"

# Try commands until one succeeds
$ command1 || command2 || command3
# command2 runs only if command1 fails
# command3 runs only if command2 fails

# Create directory or fail gracefully
$ mkdir /protected/dir || echo "Permission denied"
```

**Combining Both:**
```bash
# Complex logic
$ cd /path/to/dir && make && make install || echo "Build failed"

# Backup with verification
$ tar -czf backup.tar.gz /data && echo "Success" || echo "Failed"

# Try to start service, report status
$ systemctl start apache2 && echo "Started" || echo "Failed to start"
```

**Exit Status:**
```bash
$ command1
$ echo $?           # 0 = success, non-zero = failure

$ true && echo "This runs"        # Runs (true returns 0)
$ false && echo "This doesn't"    # Doesn't run (false returns 1)
$ false || echo "This runs"       # Runs (false returns 1)
```

### Advanced Level Questions

#### Q16: Explain the difference between `exec` and `source` commands.
**Answer:**

**`exec` - Replace Current Process:**
```bash
# Replaces current shell with command
$ exec ls        # After ls completes, terminal closes
$ exec bash      # Replace shell with new bash instance

# Use in scripts to replace script process
#!/bin/bash
echo "Starting..."
exec python3 script.py  # Script replaced by Python process
echo "This never runs"
```

**`source` (or `.`) - Execute in Current Shell:**
```bash
# Execute script in current shell context
$ source script.sh       # Variables/functions remain in shell
$ . script.sh            # Same as source

# Common use: Load environment variables
$ source ~/.bashrc       # Reload bash config
$ source venv/bin/activate  # Activate Python virtual env

# Script.sh content
VAR="value"
export PATH=$PATH:/new/path

# After source, VAR and PATH changes remain in shell
```

**Comparison:**

| Feature | exec | source |
|---------|------|--------|
| Creates new process | No (replaces current) | No (runs in current) |
| Returns to shell | No | Yes |
| Environment changes | Lost (process replaced) | Persist in shell |
| Use case | Replace process | Load configuration |

**Example:**
```bash
# script1.sh
#!/bin/bash
VAR="Hello"
echo $VAR

# Running different ways:
$ ./script1.sh           # New process, VAR doesn't persist
$ echo $VAR              # Empty

$ source script1.sh      # Current process
Hello
$ echo $VAR              # Persists
Hello

$ exec ./script1.sh      # Replace current shell
Hello
# Terminal closes after completion
```

#### Q17: What is a zombie process and how do you handle it?
**Answer:**

**Zombie Process:**
A process that has completed execution but still has an entry in the process table because its parent hasn't read its exit status.

**Characteristics:**
- PID still exists
- Uses no CPU or memory (except process table entry)
- Shows as `<defunct>` or `Z` state
- Cannot be killed with `kill -9`
- Cleaned up when parent reads exit status (`wait()` system call)

**How Zombies are Created:**
```
Parent Process              Child Process
     │                            │
     │ ──── fork() ───────────→   │ (Created)
     │                            │
     │                            │ (Running)
     │                            │
     │                            │ (Exits)
     │                            ↓
     │                       ZOMBIE (waiting)
     │ ──── wait() ──────────     │
     │    (reads exit status)     │
     │                            X (Cleaned up)
```

**Identifying Zombies:**
```bash
$ ps aux | grep Z
$ ps aux | grep defunct

USER  PID  STAT
user  1234  Z+    <defunct>
            ↑ Zombie state
```

**Handling Zombies:**

1. **Kill Parent Process** (zombies are adopted by init and cleaned)
```bash
$ ps -o ppid= -p <zombie_pid>    # Find parent PID
$ kill <parent_pid>              # Kill parent
```

2. **Wait for Parent to Clean Up**
```bash
# Send SIGCHLD to parent (tells it to clean up children)
$ kill -SIGCHLD <parent_pid>
```

3. **Reboot System** (last resort)

**Prevention in Code:**
```c
// C code to prevent zombies
#include <signal.h>

// Ignore SIGCHLD - kernel automatically cleans up
signal(SIGCHLD, SIG_IGN);

// Or use wait() in parent
pid_t pid = fork();
if (pid == 0) {
    // Child process
    exit(0);
} else {
    // Parent process
    wait(NULL);  // Wait for child to complete
}
```

**Why Zombies Exist:**
They allow parents to retrieve child's exit status. This is a feature, not a bug. Problems arise when:
- Parent never calls `wait()`
- Many zombies accumulate
- Process table fills up

#### Q18: Explain the difference between `/dev/null`, `/dev/zero`, and `/dev/random`.
**Answer:**

**`/dev/null` - Null Device (Bit Bucket):**
Discards all data written to it, returns EOF when read.

```bash
# Discard output
$ command > /dev/null          # Discard stdout
$ command 2> /dev/null         # Discard stderr
$ command &> /dev/null         # Discard all output

# Test if file exists (no output)
$ test -f file.txt > /dev/null && echo "Exists"

# Empty a file
$ > /dev/null > logfile.txt
$ cat /dev/null > logfile.txt
```

**`/dev/zero` - Zero Generator:**
Infinite stream of null bytes (0x00).

```bash
# Create file filled with zeros
$ dd if=/dev/zero of=file.img bs=1M count=100  # 100MB file

# Overwrite disk (secure deletion)
$ dd if=/dev/zero of=/dev/sda  # WARNING: Destructive!

# Create swap file
$ dd if=/dev/zero of=/swapfile bs=1M count=1024

# Allocate memory (for testing)
$ cat /dev/zero | head -c 1G > /tmp/testfile
```

**`/dev/random` - Random Generator (Blocking):**
Provides cryptographically secure random numbers. Blocks if entropy pool is depleted.

```bash
# Generate random data
$ head -c 16 /dev/random | xxd
# May block if insufficient entropy

# Generate password
$ tr -dc A-Za-z0-9 < /dev/random | head -c 16
```

**`/dev/urandom` - Random Generator (Non-blocking):**
Like `/dev/random` but doesn't block (less secure for cryptography).

```bash
# Generate random data (won't block)
$ head -c 16 /dev/urandom | xxd

# Generate UUID-like string
$ cat /dev/urandom | tr -dc 'a-f0-9' | fold -w 32 | head -1

# Generate random password
$ tr -dc 'A-Za-z0-9!@#$%' < /dev/urandom | head -c 20
```

**Comparison:**

| Device | Purpose | Behavior | Use Case |
|--------|---------|----------|----------|
| `/dev/null` | Discard data | Discards writes, returns EOF on read | Suppress output |
| `/dev/zero` | Zero bytes | Infinite zeros | Create files, wipe data |
| `/dev/random` | Crypto random | Blocks when low entropy | Encryption keys |
| `/dev/urandom` | Pseudo random | Never blocks | General random data |

#### Q19: What is the difference between `cron` and `at` commands?
**Answer:**

**`cron` - Recurring Scheduled Tasks:**
Used for tasks that run repeatedly on a schedule.

```bash
# Edit crontab
$ crontab -e

# Crontab format: MIN HOUR DAY MONTH WEEKDAY COMMAND
# * * * * * command
# ┬ ┬ ┬ ┬ ┬
# │ │ │ │ └─ Day of week (0-7, Sun=0 or 7)
# │ │ │ └─── Month (1-12)
# │ │ └───── Day of month (1-31)
# │ └─────── Hour (0-23)
# └───────── Minute (0-59)

# Examples:
# Daily backup at 2 AM
0 2 * * * /scripts/backup.sh

# Every 15 minutes
*/15 * * * * /scripts/check.sh

# Every Monday at 9 AM
0 9 * * 1 /scripts/weekly.sh

# First day of month
0 0 1 * * /scripts/monthly.sh

# List crontab
$ crontab -l

# Remove crontab
$ crontab -r
```

**`at` - One-time Scheduled Task:**
Used for tasks that run once at specific time.

```bash
# Schedule one-time task
$ at 10:30 PM
at> /scripts/backup.sh
at> <Ctrl+D>

$ at now + 2 hours
at> echo "Task executed" > /tmp/output.txt
at> <Ctrl+D>

$ at midnight
at> /scripts/cleanup.sh
at> <Ctrl+D>

$ at tomorrow
$ at next week
$ at 4pm July 4

# List scheduled jobs
$ atq
$ at -l

# Remove scheduled job
$ atrm <job_id>

# View job details
$ at -c <job_id>
```

**Comparison:**

| Feature | cron | at |
|---------|------|----|
| **Frequency** | Recurring | One-time |
| **Scheduling** | Regular intervals | Specific time |
| **Configuration** | crontab file | Command line |
| **Persistence** | Permanent until removed | Deleted after execution |
| **Use Case** | Daily backups, monitoring | Scheduled maintenance, reminders |
| **Examples** | Every day, every hour | Tomorrow, next week |

**When to use:**
- **cron**: Regular maintenance, backups, reports, monitoring
- **at**: Delayed execution, one-off tasks, reminders

#### Q20: Explain RAID levels and their differences.
**Answer:**

**RAID (Redundant Array of Independent Disks):** Combines multiple disks for performance, redundancy, or both.

**RAID 0 - Striping:**
```
┌─────┐ ┌─────┐
│Disk1│ │Disk2│
├─────┤ ├─────┤
│ A1  │ │ A2  │  Data split across disks
│ B1  │ │ B2  │
│ C1  │ │ C2  │
└─────┘ └─────┘
```
- **Minimum disks**: 2
- **Capacity**: Sum of all disks
- **Redundancy**: None (one disk fails = all data lost)
- **Performance**: High (parallel reads/writes)
- **Use case**: Video editing, gaming (speed over safety)

**RAID 1 - Mirroring:**
```
┌─────┐ ┌─────┐
│Disk1│ │Disk2│
├─────┤ ├─────┤
│  A  │ │  A  │  Exact copies
│  B  │ │  B  │
│  C  │ │  C  │
└─────┘ └─────┘
```
- **Minimum disks**: 2
- **Capacity**: Size of smallest disk (50% efficiency)
- **Redundancy**: High (can lose all but 1 disk)
- **Performance**: Good reads, slower writes
- **Use case**: Operating systems, critical data

**RAID 5 - Striping with Parity:**
```
┌─────┐ ┌─────┐ ┌─────┐
│Disk1│ │Disk2│ │Disk3│
├─────┤ ├─────┤ ├─────┤
│ A1  │ │ A2  │ │ Ap  │  Distributed parity
│ B1  │ │ Bp  │ │ B2  │
│ Cp  │ │ C1  │ │ C2  │
└─────┘ └─────┘ └─────┘
```
- **Minimum disks**: 3
- **Capacity**: (N-1) × disk size
- **Redundancy**: Can survive 1 disk failure
- **Performance**: Good reads, slower writes (parity calculation)
- **Use case**: File servers, general storage

**RAID 6 - Double Parity:**
```
┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐
│Disk1│ │Disk2│ │Disk3│ │Disk4│
├─────┤ ├─────┤ ├─────┤ ├─────┤
│ A1  │ │ A2  │ │ Ap  │ │ Aq  │  Two parity blocks
│ B1  │ │ Bp  │ │ Bq  │ │ B2  │
└─────┘ └─────┘ └─────┘ └─────┘
```
- **Minimum disks**: 4
- **Capacity**: (N-2) × disk size
- **Redundancy**: Can survive 2 disk failures
- **Performance**: Similar to RAID 5
- **Use case**: Critical data, large arrays

**RAID 10 (1+0) - Mirrored Stripes:**
```
   ┌──RAID 0──┐
   │          │
┌RAID1┐    ┌RAID1┐
│ D1 D2│    │ D3 D4│
└──────┘    └──────┘
```
- **Minimum disks**: 4
- **Capacity**: (N/2) × disk size
- **Redundancy**: Can survive multiple failures (if in different mirrors)
- **Performance**: Excellent (combine RAID 0 + RAID 1 benefits)
- **Use case**: Databases, high-performance servers

**Comparison Table:**

| RAID | Min Disks | Capacity | Redundancy | Read Speed | Write Speed | Use Case |
|------|-----------|----------|------------|------------|-------------|----------|
| **0** | 2 | 100% | None | Fast | Fast | Performance |
| **1** | 2 | 50% | High | Fast | Medium | Reliability |
| **5** | 3 | (N-1)/N | Medium | Fast | Medium | Balanced |
| **6** | 4 | (N-2)/N | High | Fast | Slow | High reliability |
| **10** | 4 | 50% | High | Very Fast | Fast | Performance + reliability |

#### Q21: What is `awk` and provide examples of its usage?
**Answer:**

**`awk`** is a powerful text processing language designed for pattern scanning and processing. It processes data line-by-line and field-by-field.

**Structure:**
```bash
awk 'pattern {action}' file
```

**Built-in Variables:**
- `$0` - Entire line
- `$1, $2, $3...` - Fields (columns)
- `NR` - Number of Records (line number)
- `NF` - Number of Fields
- `FS` - Field Separator (default: whitespace)
- `OFS` - Output Field Separator
- `RS` - Record Separator (default: newline)
- `ORS` - Output Record Separator

**Examples:**

**1. Print specific columns:**
```bash
# Print first column
$ awk '{print $1}' file.txt

# Print first and third columns
$ awk '{print $1, $3}' file.txt

# Print last column
$ awk '{print $NF}' file.txt

# Print line number and line
$ awk '{print NR, $0}' file.txt
```

**2. Custom delimiter:**
```bash
# CSV file (comma delimiter)
$ awk -F, '{print $1, $3}' data.csv

# /etc/passwd (colon delimiter)
$ awk -F: '{print $1, $6}' /etc/passwd
# Prints username and home directory

# Multiple delimiters
$ awk -F'[,:]' '{print $1}' file.txt
```

**3. Pattern matching:**
```bash
# Print lines containing "error"
$ awk '/error/ {print}' log.txt

# Print lines where column 3 > 100
$ awk '$3 > 100 {print $1, $3}' file.txt

# Print lines where column 2 equals "PASS"
$ awk '$2 == "PASS" {print $0}' results.txt

# Regular expression match
$ awk '$1 ~ /^[0-9]+$/ {print}' file.txt
```

**4. Calculations:**
```bash
# Sum of column 2
$ awk '{sum += $2} END {print sum}' numbers.txt

# Average of column 3
$ awk '{sum += $3; count++} END {print sum/count}' data.txt

# Find maximum value
$ awk 'BEGIN {max=0} {if ($1>max) max=$1} END {print max}' numbers.txt

# Count lines
$ awk 'END {print NR}' file.txt
```

**5. BEGIN and END blocks:**
```bash
# BEGIN: executed before processing
# END: executed after processing

$ awk 'BEGIN {print "Report"} {print $0} END {print "End"}' file.txt

$ awk 'BEGIN {FS=":"} {print $1, $7}' /etc/passwd

# Formatted output
$ awk 'BEGIN {printf "%-10s %-10s\n", "Name", "Score"} 
       {printf "%-10s %-10s\n", $1, $2}' data.txt
```

**6. Practical examples:**
```bash
# Extract usernames from /etc/passwd
$ awk -F: '{print $1}' /etc/passwd

# Find large files (column 5 in ls -l)
$ ls -l | awk '$5 > 1000000 {print $9, $5}'

# Process log file: count status codes
$ awk '{print $9}' access.log | sort | uniq -c

# Print lines 10-20
$ awk 'NR>=10 && NR<=20' file.txt

# Calculate disk usage percentage
$ df -h | awk 'NR>1 {print $1, $5}'

# Format output as table
$ ps aux | awk '{printf "%-10s %5s %5s %s\n", $1, $2, $3, $11}'
```

**7. Multiple conditions:**
```bash
# AND condition
$ awk '$3 > 50 && $4 < 100 {print}' file.txt

# OR condition
$ awk '$2 == "PASS" || $2 == "SUCCESS" {print}' file.txt

# NOT condition
$ awk '$2 != "FAIL" {print}' file.txt
```

#### Q22: What is the difference between TCP and UDP?
**Answer:**

**TCP (Transmission Control Protocol)** and **UDP (User Datagram Protocol)** are transport layer protocols.

**TCP - Connection-Oriented:**
```
Client                              Server
  │                                   │
  ├─────── SYN ──────────────────────→│ (Connection request)
  │←────── SYN-ACK ────────────────────┤ (Acknowledge)
  ├─────── ACK ──────────────────────→│ (Established)
  │                                   │
  ├─────── Data ─────────────────────→│
  │←────── ACK ─────────────────────── ┤
  │                                   │
  ├─────── FIN ──────────────────────→│ (Close)
  │←────── ACK ─────────────────────── ┤
```

**UDP - Connectionless:**
```
Client                              Server
  │                                   │
  ├─────── Data ─────────────────────→│ (No handshake)
  ├─────── Data ─────────────────────→│
  ├─────── Data ─────────────────────→│
  │                                   │
```

**Comparison:**

| Feature | TCP | UDP |
|---------|-----|-----|
| **Connection** | Connection-oriented (handshake) | Connectionless |
| **Reliability** | Guaranteed delivery | No guarantee |
| **Ordering** | Maintains packet order | No ordering |
| **Speed** | Slower (overhead) | Faster (less overhead) |
| **Error Checking** | Extensive | Basic checksum |
| **Flow Control** | Yes | No |
| **Congestion Control** | Yes | No |
| **Header Size** | 20 bytes | 8 bytes |
| **Retransmission** | Yes | No |
| **Use Cases** | Web, email, file transfer | Streaming, gaming, DNS |

**When to use:**

**TCP:**
- File transfers (FTP, SFTP)
- Web browsing (HTTP/HTTPS)
- Email (SMTP, IMAP, POP3)
- Remote access (SSH, Telnet)
- When data integrity is critical

**UDP:**
- Video/audio streaming
- Online gaming
- DNS queries
- VoIP (Skype, Zoom)
- IoT sensors
- When speed > reliability

**Port Examples:**
```bash
# TCP ports
22    # SSH
80    # HTTP
443   # HTTPS
21    # FTP
25    # SMTP

# UDP ports
53    # DNS
67/68 # DHCP
161   # SNMP
123   # NTP
```

**Check connections:**
```bash
# View TCP connections
$ netstat -tn

# View UDP connections
$ netstat -un

# View listening ports
$ netstat -tuln
```

#### Q23: Explain the concept of signals in UNIX.
**Answer:**

**Signals** are software interrupts sent to processes to notify them of events or to request specific actions.

**Signal Generation:**
- User (keyboard): Ctrl+C, Ctrl+Z
- Kernel: Segmentation fault, illegal instruction
- Another process: `kill` command
- Hardware: Exceptions, alarms

**Common Signals:**

| Signal | Number | Default Action | Description | Generated By |
|--------|--------|----------------|-------------|--------------|
| SIGHUP | 1 | Terminate | Hangup (terminal closed) | Terminal closed |
| SIGINT | 2 | Terminate | Interrupt | Ctrl+C |
| SIGQUIT | 3 | Core dump | Quit | Ctrl+\ |
| SIGILL | 4 | Core dump | Illegal instruction | CPU |
| SIGKILL | 9 | Terminate | Kill (cannot be caught) | kill -9 |
| SIGSEGV | 11 | Core dump | Segmentation fault | Invalid memory access |
| SIGTERM | 15 | Terminate | Graceful termination | kill (default) |
| SIGCHLD | 17 | Ignore | Child process terminated | Child exit |
| SIGSTOP | 19 | Stop | Stop (cannot be caught) | kill -STOP |
| SIGTSTP | 20 | Stop | Terminal stop | Ctrl+Z |
| SIGCONT | 18 | Continue | Continue stopped process | fg, bg |

**Signal Actions:**
1. **Default Action**: What happens if no handler
2. **Catch**: Process handles signal with custom function
3. **Ignore**: Process ignores signal
4. **Cannot catch/ignore**: SIGKILL (9), SIGSTOP (19)

**Sending Signals:**
```bash
# Send signal by number
$ kill -9 PID           # SIGKILL
$ kill -15 PID          # SIGTERM (default)

# Send signal by name
$ kill -SIGTERM PID
$ kill -KILL PID

# List all signals
$ kill -l

# Send to process group
$ kill -TERM -PID       # Negative PID = process group

# Send to all user processes
$ killall process_name
$ pkill -TERM process_name

# Keyboard signals
Ctrl+C    # SIGINT (2)
Ctrl+Z    # SIGTSTP (20)
Ctrl+\    # SIGQUIT (3)
```

**Signal Handling in Scripts:**
```bash
#!/bin/bash

# Trap signal and execute function
cleanup() {
    echo "Caught signal, cleaning up..."
    rm -f /tmp/tempfile
    exit 0
}

# Trap SIGINT and SIGTERM
trap cleanup SIGINT SIGTERM

# Main script
echo "Running... (Press Ctrl+C)"
while true; do
    echo "Working..."
    sleep 2
done
```

**Practical Examples:**
```bash
# Graceful termination (allows cleanup)
$ kill -TERM PID
$ kill -15 PID

# Force kill (immediate, no cleanup)
$ kill -KILL PID
$ kill -9 PID

# Reload configuration (doesn't terminate)
$ kill -HUP PID
$ systemctl reload nginx  # Sends SIGHUP

# Suspend process
$ kill -STOP PID

# Resume process
$ kill -CONT PID

# Same as Ctrl+C
$ kill -INT PID
```

**Signal in C Program:**
```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

void handle_signal(int sig) {
    printf("Caught signal %d\n", sig);
    // Cleanup code
    exit(0);
}

int main() {
    // Register signal handler
    signal(SIGINT, handle_signal);
    signal(SIGTERM, handle_signal);
    
    // Main loop
    while (1) {
        printf("Running...\n");
        sleep(1);
    }
    
    return 0;
}
```

**Signal vs Kill:**
- Signals are notifications/interrupts
- `kill` command sends signals (poor name!)
- Not all signals kill processes
- Signals can trigger custom actions

#### Q24: What is the difference between `/etc/passwd` and `/etc/shadow`?
**Answer:**

**`/etc/passwd` - User Account Information:**
Readable by all users, contains basic account information.

**Format:**
```
username:x:UID:GID:comment:home:shell
```

**Example:**
```bash
$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
john:x:1000:1000:John Doe:/home/john:/bin/bash
mysql:x:115:120:MySQL Server,,,:/nonexistent:/bin/false
```

**Fields:**
1. **Username**: Login name
2. **Password**: `x` (actual password in `/etc/shadow`)
3. **UID**: User ID (0 = root)
4. **GID**: Primary group ID
5. **GECOS**: User info (full name, phone, etc.)
6. **Home Directory**: User's home path
7. **Shell**: Login shell

**`/etc/shadow` - Encrypted Passwords:**
Readable only by root, contains password hashes and aging info.

**Format:**
```
username:password:lastchange:min:max:warn:inactive:expire
```

**Example:**
```bash
$ sudo cat /etc/shadow
root:$6$rounds=5000$...:18900:0:99999:7:::
john:$6$xyz123...:18900:0:99999:7:::
mysql:*:18900:0:99999:7:::
```

**Fields:**
1. **Username**: Login name
2. **Encrypted Password**: 
   - `$6$` = SHA-512
   - `$5$` = SHA-256
   - `$1$` = MD5
   - `*` or `!` = Account locked
   - Empty = No password required
3. **Last Change**: Days since Jan 1, 1970
4. **Minimum**: Min days between password changes
5. **Maximum**: Max days password is valid
6. **Warning**: Days before expiry to warn user
7. **Inactive**: Days after expiry before account is disabled
8. **Expire**: Account expiration date (days since Jan 1, 1970)

**Comparison:**

| Feature | /etc/passwd | /etc/shadow |
|---------|-------------|-------------|
| **Permissions** | 644 (all can read) | 640 (root only) |
| **Purpose** | Basic account info | Password security |
| **Password Storage** | `x` (placeholder) | Encrypted hash |
| **Security** | Low (readable by all) | High (root only) |
| **Password Aging** | No | Yes |
| **Created** | Original UNIX | Later security addition |

**Why separate files?**
1. **Security**: `/etc/passwd` must be world-readable (many programs read it), but passwords should be secret
2. **Protection**: Prevents password hash exposure to all users
3. **Password Aging**: Allows expiration, locking features

**Related Commands:**
```bash
# View user info
$ getent passwd username

# View shadow entry (requires root)
$ sudo getent shadow username

# Change password
$ passwd

# Lock account
$ sudo passwd -l username
# Sets ! in front of password hash

# Unlock account
$ sudo passwd -u username

# Password expiry info
$ chage -l username

# Set password expiration
$ sudo chage -M 90 username  # Max 90 days
```

#### Q25: Explain file descriptors and standard streams in UNIX.
**Answer:**

**File Descriptors (FD):** Integer values representing open files/resources in a process.

**Standard File Descriptors:**

| FD | Name | Symbol | Purpose | Default |
|----|------|--------|---------|---------|
| 0 | Standard Input | stdin | Input stream | Keyboard |
| 1 | Standard Output | stdout | Output stream | Terminal |
| 2 | Standard Error | stderr | Error messages | Terminal |

**Visualization:**
```
Process
┌──────────────────────┐
│                      │
│  stdin (0)  ←──────────── Keyboard
│  stdout (1) ──────────→  Terminal
│  stderr (2) ──────────→  Terminal
│  fd 3       ←──────────── file1.txt
│  fd 4       ──────────→  file2.txt
│                      │
└──────────────────────┘
```

**Redirection:**

**1. Output Redirection:**
```bash
# Redirect stdout (FD 1)
$ command > output.txt
$ command 1> output.txt      # Same

# Redirect stderr (FD 2)
$ command 2> error.txt

# Redirect both to different files
$ command > output.txt 2> error.txt

# Redirect both to same file
$ command > all.txt 2>&1
$ command &> all.txt         # Shorthand

# Redirect stderr to stdout
$ command 2>&1

# Append instead of overwrite
$ command >> output.txt
$ command 2>> error.txt
```

**2. Input Redirection:**
```bash
# Redirect stdin (FD 0)
$ command < input.txt
$ command 0< input.txt      # Same

# Here document (multi-line input)
$ command << EOF
line 1
line 2
EOF

# Here string (single line)
$ command <<< "input data"
```

**3. Closing File Descriptors:**
```bash
# Close stdout
$ command 1>&-

# Close stderr
$ command 2>&-

# Close stdin
$ command 0>&-
```

**4. Duplicating File Descriptors:**
```bash
# Save stdout to FD 3, redirect to file, restore
$ exec 3>&1           # Save stdout to FD 3
$ exec > output.txt   # Redirect stdout to file
$ echo "In file"      # Goes to file
$ exec 1>&3           # Restore stdout from FD 3
$ exec 3>&-           # Close FD 3
$ echo "On terminal"  # Goes to terminal
```

**Practical Examples:**

**Example 1: Separate stdout and stderr**
```bash
#!/bin/bash
# Save different outputs

echo "Normal message"       # stdout
echo "Error message" >&2    # stderr

# Run: ./script.sh > output.txt 2> errors.txt
```

**Example 2: Redirect all output**
```bash
# Send all output to log file
$ ./script.sh &> logfile.txt

# Discard all output
$ ./script.sh &> /dev/null

# Log and display
$ ./script.sh 2>&1 | tee logfile.txt
```

**Example 3: Custom file descriptors**
```bash
#!/bin/bash

# Open file for reading (FD 3)
exec 3< input.txt

# Read from FD 3
while read -u 3 line; do
    echo "Read: $line"
done

# Close FD 3
exec 3<&-

# Open file for writing (FD 4)
exec 4> output.txt

# Write to FD 4
echo "Line 1" >&4
echo "Line 2" >&4

# Close FD 4
exec 4>&-
```

**Example 4: Error handling**
```bash
#!/bin/bash

# Function that uses stderr
error() {
    echo "ERROR: $1" >&2
    exit 1
}

# Check condition
if [ ! -f "required.txt" ]; then
    error "required.txt not found"
fi
```

**View open file descriptors:**
```bash
# List all FDs for process
$ ls -l /proc/$$/fd
lrwx------ 1 user user 64 Nov 29 10:30 0 -> /dev/pts/0  (stdin)
lrwx------ 1 user user 64 Nov 29 10:30 1 -> /dev/pts/0  (stdout)
lrwx------ 1 user user 64 Nov 29 10:30 2 -> /dev/pts/0  (stderr)
lr-x------ 1 user user 64 Nov 29 10:30 3 -> /path/to/file

# Check open files for process
$ lsof -p PID

# Count open file descriptors
$ ls /proc/$$/fd | wc -l
```

**File Descriptor Limits:**
```bash
# View current limit
$ ulimit -n
1024

# Set limit (current shell)
$ ulimit -n 4096

# System-wide limits
$ cat /proc/sys/fs/file-max

# View per-process limits
$ cat /proc/$$/limits
```

---

## Summary

### Key Takeaways

1. **UNIX Philosophy**: Small, modular tools that do one thing well
2. **Everything is a file**: Devices, directories, sockets all treated as files
3. **Hierarchical filesystem**: Single root `/` with unified namespace
4. **Strong security model**: Users, groups, permissions (rwx)
5. **Process management**: Multi-user, multitasking with signals
6. **Text-based**: Configuration files, logs, tools all use text
7. **Pipes and filters**: Chain commands with `|`
8. **Shell scripting**: Automate tasks with powerful scripting

### Interview Preparation Tips

1. **Practice commands**: Use a Linux VM or WSL regularly
2. **Understand concepts**: Don't just memorize, understand why
3. **Read man pages**: `man command` is your friend
4. **Write scripts**: Automate tasks to gain practical experience
5. **Troubleshoot**: Break things and fix them to learn
6. **System administration**: Learn log files, services, networking
7. **Security**: Understand permissions, users, groups
8. **Performance**: Know how to monitor CPU, memory, disk, network

### Further Study Resources

- **Books**: 
  - "The Linux Command Line" by William Shotts
  - "UNIX and Linux System Administration Handbook"
  - "Advanced Programming in the UNIX Environment"

- **Online**:
  - Linux Documentation Project (TLDP)
  - man pages and info pages
  - ExplainShell.com (explain command syntax)

- **Practice**:
  - OverTheWire wargames
  - HackerRank Linux shell challenges
  - Set up home lab with VMs

---

**End of UNIX Notes**
